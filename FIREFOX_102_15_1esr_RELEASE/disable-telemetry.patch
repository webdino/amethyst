diff --git a/browser/actors/ContentSearchParent.jsm b/browser/actors/ContentSearchParent.jsm
--- a/browser/actors/ContentSearchParent.jsm
+++ b/browser/actors/ContentSearchParent.jsm
@@ -13,7 +13,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 XPCOMUtils.defineLazyGlobalGetters(this, ["XMLHttpRequest"]);
 
 XPCOMUtils.defineLazyModuleGetters(this, {
-  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
   FormHistory: "resource://gre/modules/FormHistory.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   SearchSuggestionController:
@@ -261,10 +260,6 @@ let ContentSearch = {
       };
       win.openTrustedLinkIn(submission.uri.spec, where, params);
     }
-    BrowserSearchTelemetry.recordSearch(browser, engine, data.healthReportKey, {
-      selection: data.selection,
-      url: submission.uri,
-    });
   },
 
   async getSuggestions(engineName, searchString, browser) {
diff --git a/browser/actors/NetErrorParent.jsm b/browser/actors/NetErrorParent.jsm
--- a/browser/actors/NetErrorParent.jsm
+++ b/browser/actors/NetErrorParent.jsm
@@ -297,12 +297,6 @@ class NetErrorParent extends JSWindowAct
       case "Browser:SSLErrorGoBack":
         this.goBackFromErrorPage(this.browser);
         break;
-      case "Browser:SSLErrorReportTelemetry":
-        let reportStatus = message.data.reportStatus;
-        Services.telemetry
-          .getHistogramById("TLS_ERROR_REPORT_UI")
-          .add(reportStatus);
-        break;
       case "GetChangedCertPrefs":
         let hasChangedCertPrefs = this.hasChangedCertPrefs();
         this.sendAsyncMessage("HasChangedCertPrefs", {
diff --git a/browser/actors/moz.build b/browser/actors/moz.build
--- a/browser/actors/moz.build
+++ b/browser/actors/moz.build
@@ -83,8 +83,6 @@ FINAL_TARGET_FILES.actors += [
     "RFPHelperChild.jsm",
     "RFPHelperParent.jsm",
     "ScreenshotsComponentChild.jsm",
-    "SearchSERPTelemetryChild.jsm",
-    "SearchSERPTelemetryParent.jsm",
     "SwitchDocumentDirectionChild.jsm",
     "WebRTCChild.jsm",
     "WebRTCParent.jsm",
diff --git a/browser/base/content/browser-addons.js b/browser/base/content/browser-addons.js
--- a/browser/base/content/browser-addons.js
+++ b/browser/base/content/browser-addons.js
@@ -1112,13 +1112,6 @@ var BrowserAddonUI = {
 
     let { remove, report } = await this.promptRemoveExtension(addon);
 
-    AMTelemetry.recordActionEvent({
-      object: eventObject,
-      action: "uninstall",
-      value: remove ? "accepted" : "cancelled",
-      extra: { addonId },
-    });
-
     if (remove) {
       // Leave the extension in pending uninstall if we are also reporting the
       // add-on.
diff --git a/browser/base/content/browser-pageActions.js b/browser/base/content/browser-pageActions.js
--- a/browser/base/content/browser-pageActions.js
+++ b/browser/base/content/browser-pageActions.js
@@ -971,12 +971,6 @@ var BrowserPageActions = {
     let action = this._contextAction;
     this._contextAction = null;
 
-    AMTelemetry.recordActionEvent({
-      object: "pageAction",
-      action: "manage",
-      extra: { addonId: action.extensionID },
-    });
-
     let viewID = "addons://detail/" + encodeURIComponent(action.extensionID);
     window.BrowserOpenAddonsMgr(viewID);
   },
diff --git a/browser/base/content/browser-places.js b/browser/base/content/browser-places.js
--- a/browser/base/content/browser-places.js
+++ b/browser/base/content/browser-places.js
@@ -1446,11 +1446,6 @@ var BookmarkingUI = {
     );
 
     CustomizableUI.setToolbarVisibility(this.toolbar.id, newState, false);
-    BrowserUsageTelemetry.recordToolbarVisibility(
-      this.toolbar.id,
-      newState,
-      reason
-    );
   },
 
   isOnNewTabPage({ currentURI }) {
diff --git a/browser/base/content/browser.js b/browser/base/content/browser.js
--- a/browser/base/content/browser.js
+++ b/browser/base/content/browser.js
@@ -18,11 +18,7 @@ XPCOMUtils.defineLazyModuleGetters(this,
   AboutNewTab: "resource:///modules/AboutNewTab.jsm",
   AboutReaderParent: "resource:///actors/AboutReaderParent.jsm",
   AddonManager: "resource://gre/modules/AddonManager.jsm",
-  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
   NewTabPagePreloading: "resource:///modules/NewTabPagePreloading.jsm",
-  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
-  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
-  BrowserTelemetryUtils: "resource://gre/modules/BrowserTelemetryUtils.jsm",
   BrowserUIUtils: "resource:///modules/BrowserUIUtils.jsm",
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   CFRPageActions: "resource://activity-stream/lib/CFRPageActions.jsm",
@@ -78,7 +74,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   SubDialogManager: "resource://gre/modules/SubDialog.jsm",
   TabModalPrompt: "chrome://global/content/tabprompts.jsm",
   TabCrashHandler: "resource:///modules/ContentCrashHandlers.jsm",
-  TelemetryEnvironment: "resource://gre/modules/TelemetryEnvironment.jsm",
   Translation: "resource:///modules/translation/TranslationParent.jsm",
   UITour: "resource:///modules/UITour.jsm",
   UpdateUtils: "resource://gre/modules/UpdateUtils.jsm",
@@ -1662,19 +1657,6 @@ var gBrowserInit = {
         if (!windowFrameColor.isContrastRatioAcceptable(new Color(0, 0, 0))) {
           document.documentElement.setAttribute("darkwindowframe", "true");
         }
-      } else if (AppConstants.isPlatformAndVersionAtLeast("win", "10")) {
-        TelemetryEnvironment.onInitialized().then(() => {
-          // 17763 is the build number of Windows 10 version 1809
-          if (
-            TelemetryEnvironment.currentEnvironment.system.os
-              .windowsBuildNumber < 17763
-          ) {
-            document.documentElement.setAttribute(
-              "always-use-accent-color-for-window-border",
-              ""
-            );
-          }
-        });
       }
     }
 
@@ -1865,11 +1847,6 @@ var gBrowserInit = {
   },
 
   _delayedStartup() {
-    let { TelemetryTimestamps } = ChromeUtils.import(
-      "resource://gre/modules/TelemetryTimestamps.jsm"
-    );
-    TelemetryTimestamps.add("delayedStartupStarted");
-
     this._cancelDelayedStartup();
 
     // Bug 1531854 - The hidden window is force-created here
@@ -2142,7 +2119,6 @@ var gBrowserInit = {
     this.delayedStartupFinished = true;
     _resolveDelayedStartup();
     Services.obs.notifyObservers(window, "browser-delayed-startup-finished");
-    TelemetryTimestamps.add("delayedStartupFinished");
     // We've announced that delayed startup has finished. Do not add code past this point.
   },
 
@@ -4215,15 +4191,6 @@ const BrowserSearch = {
       csp,
       inBackground
     );
-
-    if (engine) {
-      BrowserSearchTelemetry.recordSearch(
-        gBrowser.selectedBrowser,
-        engine,
-        "contextmenu",
-        { url }
-      );
-    }
   },
 
   /**
@@ -4238,14 +4205,6 @@ const BrowserSearch = {
       triggeringPrincipal,
       csp
     );
-    if (engine) {
-      BrowserSearchTelemetry.recordSearch(
-        gBrowser.selectedBrowser,
-        engine,
-        "system",
-        { url }
-      );
-    }
   },
 
   /**
@@ -4263,13 +4222,6 @@ const BrowserSearch = {
       engine,
       tab
     );
-
-    BrowserSearchTelemetry.recordSearch(
-      gBrowser.selectedBrowser,
-      result.engine,
-      "webextension",
-      { url: result.url }
-    );
   },
 
   pasteAndSearch(event) {
@@ -6027,7 +5979,6 @@ var TabsProgressListener = {
                 .add(timeElapsed);
             }
             TelemetryStopwatch.finish(histogram, aBrowser);
-            BrowserTelemetryUtils.recordSiteOriginTelemetry(browserWindows());
           }
         }
       } else if (
@@ -6623,24 +6574,20 @@ function onViewToolbarsPopupShowing(aEve
 
 function onViewToolbarCommand(aEvent) {
   let node = aEvent.originalTarget;
-  let menuId;
   let toolbarId;
   let isVisible;
   if (node.dataset.bookmarksToolbarVisibility) {
     isVisible = node.dataset.visibilityEnum;
     toolbarId = "PersonalToolbar";
-    menuId = node.parentNode.parentNode.parentNode.id;
     Services.prefs.setCharPref(
       "browser.toolbars.bookmarks.visibility",
       isVisible
     );
   } else {
-    menuId = node.parentNode.id;
     toolbarId = node.getAttribute("toolbarId");
     isVisible = node.getAttribute("checked") == "true";
   }
   CustomizableUI.setToolbarVisibility(toolbarId, isVisible);
-  BrowserUsageTelemetry.recordToolbarVisibility(toolbarId, isVisible, menuId);
 }
 
 function setToolbarVisibility(
@@ -7409,11 +7356,6 @@ var ToolbarContextMenu = {
     if (id) {
       let viewID = "addons://detail/" + encodeURIComponent(id);
       BrowserOpenAddonsMgr(viewID);
-      AMTelemetry.recordActionEvent({
-        object: "browserAction",
-        action: "manage",
-        extra: { addonId: id },
-      });
     }
   },
 };
diff --git a/browser/components/BrowserGlue.jsm b/browser/components/BrowserGlue.jsm
--- a/browser/components/BrowserGlue.jsm
+++ b/browser/components/BrowserGlue.jsm
@@ -31,8 +31,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   Blocklist: "resource://gre/modules/Blocklist.jsm",
   BookmarkHTMLUtils: "resource://gre/modules/BookmarkHTMLUtils.jsm",
   BookmarkJSONUtils: "resource://gre/modules/BookmarkJSONUtils.jsm",
-  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
-  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
   BrowserUIUtils: "resource:///modules/BrowserUIUtils.jsm",
   BrowserWindowTracker: "resource:///modules/BrowserWindowTracker.jsm",
   BuiltInThemes: "resource:///modules/BuiltInThemes.jsm",
@@ -57,7 +55,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   NetUtil: "resource://gre/modules/NetUtil.jsm",
   NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
   NimbusFeatures: "resource://nimbus/ExperimentAPI.jsm",
-  Normandy: "resource://normandy/Normandy.jsm",
   OnboardingMessageProvider:
     "resource://activity-stream/lib/OnboardingMessageProvider.jsm",
   OsEnvironment: "resource://gre/modules/OsEnvironment.jsm",
@@ -66,7 +63,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   PdfJs: "resource://pdf.js/PdfJs.jsm",
   PermissionUI: "resource:///modules/PermissionUI.jsm",
   PlacesBackups: "resource://gre/modules/PlacesBackups.jsm",
-  PlacesDBUtils: "resource://gre/modules/PlacesDBUtils.jsm",
   PlacesUIUtils: "resource:///modules/PlacesUIUtils.jsm",
   PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
   PluralForm: "resource://gre/modules/PluralForm.jsm",
@@ -81,7 +77,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   Sanitizer: "resource:///modules/Sanitizer.jsm",
   SaveToPocket: "chrome://pocket/content/SaveToPocket.jsm",
   ScreenshotsUtils: "resource:///modules/ScreenshotsUtils.jsm",
-  SearchSERPTelemetry: "resource:///modules/SearchSERPTelemetry.jsm",
   SessionStartup: "resource:///modules/sessionstore/SessionStartup.jsm",
   SessionStore: "resource:///modules/sessionstore/SessionStore.jsm",
   ShellService: "resource:///modules/ShellService.jsm",
@@ -91,7 +86,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
     "resource://messaging-system/lib/SpecialMessageActions.jsm",
   TabCrashHandler: "resource:///modules/ContentCrashHandlers.jsm",
   TabUnloader: "resource:///modules/TabUnloader.jsm",
-  TelemetryUtils: "resource://gre/modules/TelemetryUtils.jsm",
   TRRRacer: "resource:///modules/TRRPerformance.jsm",
   UIState: "resource://services-sync/UIState.jsm",
   UpdateListener: "resource://gre/modules/UpdateListener.jsm",
@@ -212,7 +206,6 @@ let JSWINDOWACTORS = {
         AboutLoginsGetHelp: { wantUntrusted: true },
         AboutLoginsOpenPreferences: { wantUntrusted: true },
         AboutLoginsOpenSite: { wantUntrusted: true },
-        AboutLoginsRecordTelemetryEvent: { wantUntrusted: true },
         AboutLoginsRemoveAllLogins: { wantUntrusted: true },
         AboutLoginsSortChanged: { wantUntrusted: true },
         AboutLoginsSyncEnable: { wantUntrusted: true },
@@ -685,38 +678,6 @@ let JSWINDOWACTORS = {
     enablePreference: "screenshots.browser.component.enabled",
   },
 
-  SearchSERPTelemetry: {
-    parent: {
-      moduleURI: "resource:///actors/SearchSERPTelemetryParent.jsm",
-    },
-    child: {
-      moduleURI: "resource:///actors/SearchSERPTelemetryChild.jsm",
-      events: {
-        DOMContentLoaded: {},
-        pageshow: { mozSystemGroup: true },
-        // The 'unload' event is only used to clean up state, and should not
-        // force actor creation.
-        unload: { createActor: false },
-        load: { mozSystemGroup: true, capture: true },
-      },
-    },
-  },
-
-  ShieldFrame: {
-    parent: {
-      moduleURI: "resource://normandy-content/ShieldFrameParent.jsm",
-    },
-    child: {
-      moduleURI: "resource://normandy-content/ShieldFrameChild.jsm",
-      events: {
-        pageshow: {},
-        pagehide: {},
-        ShieldPageEvent: { wantUntrusted: true },
-      },
-    },
-    matches: ["about:studies*"],
-  },
-
   ASRouter: {
     parent: {
       moduleURI: "resource:///actors/ASRouterParent.jsm",
@@ -1045,24 +1006,6 @@ BrowserGlue.prototype = {
         // the UI has gone should be finalized in _onQuitApplicationGranted.
         this._dispose();
         break;
-      case "keyword-search":
-        // This notification is broadcast by the docshell when it "fixes up" a
-        // URI that it's been asked to load into a keyword search.
-        let engine = null;
-        try {
-          engine = Services.search.getEngineByName(
-            subject.QueryInterface(Ci.nsISupportsString).data
-          );
-        } catch (ex) {
-          Cu.reportError(ex);
-        }
-        let win = BrowserWindowTracker.getTopWindow();
-        BrowserSearchTelemetry.recordSearch(
-          win.gBrowser.selectedBrowser,
-          engine,
-          "urlbar"
-        );
-        break;
       case "browser-search-engine-modified":
         // Ensure we cleanup the hiddenOneOffs pref when removing
         // an engine, and that newly added engines are visible.
@@ -1130,7 +1073,6 @@ BrowserGlue.prototype = {
       "distribution-customization-complete",
       "handle-xul-text-link",
       "profile-before-change",
-      "keyword-search",
       "browser-search-engine-modified",
       "restart-in-safe-mode",
       "xpi-signature-changed",
@@ -1258,10 +1200,6 @@ BrowserGlue.prototype = {
 
     BuiltInThemes.maybeInstallActiveBuiltInTheme();
 
-    if (AppConstants.MOZ_NORMANDY) {
-      Normandy.init();
-    }
-
     SaveToPocket.init();
 
     AboutHomeStartupCache.init();
@@ -1540,48 +1478,6 @@ BrowserGlue.prototype = {
 
     ChromeUtils.addProfilerMarker("earlyBlankFirstPaint", startTime);
     win.openTime = Cu.now();
-
-    let { TelemetryTimestamps } = ChromeUtils.import(
-      "resource://gre/modules/TelemetryTimestamps.jsm"
-    );
-    TelemetryTimestamps.add("blankWindowShown");
-  },
-
-  _firstWindowTelemetry(aWindow) {
-    let scaling = aWindow.devicePixelRatio * 100;
-    try {
-      Services.telemetry.getHistogramById("DISPLAY_SCALING").add(scaling);
-    } catch (ex) {}
-  },
-
-  _collectStartupConditionsTelemetry() {
-    let nowSeconds = Math.round(Date.now() / 1000);
-    // Don't include cases where we don't have the pref. This rules out the first install
-    // as well as the first run of a build since this was introduced. These could by some
-    // definitions be referred to as "cold" startups, but probably not since we likely
-    // just wrote many of the files we use to disk. This way we should approximate a lower
-    // bound to the number of cold startups rather than an upper bound.
-    let lastCheckSeconds = Services.prefs.getIntPref(
-      "browser.startup.lastColdStartupCheck",
-      nowSeconds
-    );
-    Services.prefs.setIntPref(
-      "browser.startup.lastColdStartupCheck",
-      nowSeconds
-    );
-    try {
-      let secondsSinceLastOSRestart =
-        Services.startup.secondsSinceLastOSRestart;
-      let isColdStartup =
-        nowSeconds - secondsSinceLastOSRestart > lastCheckSeconds;
-      Services.telemetry.scalarSet("startup.is_cold", isColdStartup);
-      Services.telemetry.scalarSet(
-        "startup.seconds_since_last_os_restart",
-        secondsSinceLastOSRestart
-      );
-    } catch (ex) {
-      Cu.reportError(ex);
-    }
   },
 
   // the first browser window has finished initializing
@@ -1665,22 +1561,14 @@ BrowserGlue.prototype = {
 
     NewTabUtils.init();
 
-    Services.telemetry.setEventRecordingEnabled(
-      "security.ui.protections",
-      true
-    );
-
     PageActions.init();
 
     DoHController.init();
 
     SnapshotMonitor.init();
 
-    this._firstWindowTelemetry(aWindow);
     this._firstWindowLoaded();
 
-    this._collectStartupConditionsTelemetry();
-
     // Set the default favicon size for UI views that use the page-icon protocol.
     PlacesUtils.favicons.setDefaultIconURIPreferredSize(
       16 * aWindow.devicePixelRatio
@@ -1732,10 +1620,6 @@ BrowserGlue.prototype = {
       this._updateCBCategory
     );
     Services.prefs.addObserver(
-      "media.autoplay.default",
-      this._updateAutoplayPref
-    );
-    Services.prefs.addObserver(
       "privacy.trackingprotection",
       this._setPrefExpectations
     );
@@ -1750,17 +1634,6 @@ BrowserGlue.prototype = {
     NimbusFeatures.tcpByDefault.onUpdate(this._setDefaultCookieBehavior);
   },
 
-  _updateAutoplayPref() {
-    const blocked = Services.prefs.getIntPref("media.autoplay.default", 1);
-    const telemetry = Services.telemetry.getHistogramById(
-      "AUTOPLAY_DEFAULT_SETTING_CHANGE"
-    );
-    const labels = { 0: "allow", 1: "blockAudible", 5: "blockAll" };
-    if (blocked in labels) {
-      telemetry.add(labels[blocked]);
-    }
-  },
-
   _setDefaultCookieBehavior() {
     let defaultPrefs = Services.prefs.getDefaultBranch("");
 
@@ -1772,11 +1645,6 @@ BrowserGlue.prototype = {
     // rollout.
     // Avoid overwriting cookie behavior set by enterprise policy.
     if (NimbusFeatures.tcpByDefault.isEnabled() && !hasCookieBehaviorPolicy()) {
-      Services.telemetry.scalarSet(
-        "privacy.dfpi_rollout_tcpByDefault_feature",
-        true
-      );
-
       // Enable TCP by updating the default pref state for cookie behaviour. This
       // means we won't override user choice.
       defaultPrefs.setIntPref(
@@ -1786,15 +1654,10 @@ BrowserGlue.prototype = {
 
       return;
     }
-    Services.telemetry.scalarSet(
-      "privacy.dfpi_rollout_tcpByDefault_feature",
-      false
-    );
 
     // For the initial rollout of dFPI, set the default cookieBehavior based on the pref
     // set during onboarding when the user chooses to enable protections or not.
     if (!Services.prefs.prefHasUserValue(PREF_DFPI_ENABLED_BY_DEFAULT)) {
-      Services.telemetry.scalarSet("privacy.dfpi_rollout_enabledByDefault", 2);
       return;
     }
     let dFPIEnabled = Services.prefs.getBoolPref(PREF_DFPI_ENABLED_BY_DEFAULT);
@@ -1805,11 +1668,6 @@ BrowserGlue.prototype = {
         ? Ci.nsICookieService.BEHAVIOR_REJECT_TRACKER_AND_PARTITION_FOREIGN
         : BrowserGlue._defaultCookieBehaviorAtStartup
     );
-
-    Services.telemetry.scalarSet(
-      "privacy.dfpi_rollout_enabledByDefault",
-      dFPIEnabled ? 1 : 0
-    );
   },
 
   _setPrefExpectations() {
@@ -1829,138 +1687,6 @@ BrowserGlue.prototype = {
     ContentBlockingCategoriesPrefs.updateCBCategory();
   },
 
-  _recordContentBlockingTelemetry() {
-    Services.telemetry.setEventRecordingEnabled(
-      "security.ui.protectionspopup",
-      Services.prefs.getBoolPref(
-        "security.protectionspopup.recordEventTelemetry"
-      )
-    );
-    Services.telemetry.setEventRecordingEnabled(
-      "security.ui.app_menu",
-      Services.prefs.getBoolPref("security.app_menu.recordEventTelemetry")
-    );
-
-    let tpEnabled = Services.prefs.getBoolPref(
-      "privacy.trackingprotection.enabled"
-    );
-    Services.telemetry
-      .getHistogramById("TRACKING_PROTECTION_ENABLED")
-      .add(tpEnabled);
-
-    let tpPBDisabled = Services.prefs.getBoolPref(
-      "privacy.trackingprotection.pbmode.enabled"
-    );
-    Services.telemetry
-      .getHistogramById("TRACKING_PROTECTION_PBM_DISABLED")
-      .add(!tpPBDisabled);
-
-    let cookieBehavior = Services.prefs.getIntPref(
-      "network.cookie.cookieBehavior"
-    );
-    Services.telemetry.getHistogramById("COOKIE_BEHAVIOR").add(cookieBehavior);
-
-    let fpEnabled = Services.prefs.getBoolPref(
-      "privacy.trackingprotection.fingerprinting.enabled"
-    );
-    let cmEnabled = Services.prefs.getBoolPref(
-      "privacy.trackingprotection.cryptomining.enabled"
-    );
-    let categoryPref;
-    switch (
-      Services.prefs.getStringPref("browser.contentblocking.category", null)
-    ) {
-      case "standard":
-        categoryPref = 0;
-        break;
-      case "strict":
-        categoryPref = 1;
-        break;
-      case "custom":
-        categoryPref = 2;
-        break;
-      default:
-        // Any other value is unsupported.
-        categoryPref = 3;
-        break;
-    }
-
-    Services.telemetry.scalarSet(
-      "contentblocking.fingerprinting_blocking_enabled",
-      fpEnabled
-    );
-    Services.telemetry.scalarSet(
-      "contentblocking.cryptomining_blocking_enabled",
-      cmEnabled
-    );
-    Services.telemetry.scalarSet("contentblocking.category", categoryPref);
-  },
-
-  _recordDataSanitizationPrefs() {
-    Services.telemetry.scalarSet(
-      "datasanitization.network_cookie_lifetimePolicy",
-      Services.prefs.getIntPref("network.cookie.lifetimePolicy")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_sanitize_sanitizeOnShutdown",
-      Services.prefs.getBoolPref("privacy.sanitize.sanitizeOnShutdown")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_cookies",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.cookies")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_history",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.history")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_formdata",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.formdata")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_downloads",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.downloads")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_cache",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.cache")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_sessions",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.sessions")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_offlineApps",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.offlineApps")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_siteSettings",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.siteSettings")
-    );
-    Services.telemetry.scalarSet(
-      "datasanitization.privacy_clearOnShutdown_openWindows",
-      Services.prefs.getBoolPref("privacy.clearOnShutdown.openWindows")
-    );
-
-    let exceptions = 0;
-    for (let permission of Services.perms.all) {
-      // We consider just permissions set for http, https and file URLs.
-      if (
-        permission.type == "cookie" &&
-        permission.capability == Ci.nsICookiePermission.ACCESS_SESSION &&
-        ["http", "https", "file"].some(scheme =>
-          permission.principal.schemeIs(scheme)
-        )
-      ) {
-        exceptions++;
-      }
-    }
-    Services.telemetry.scalarSet(
-      "datasanitization.session_permission_exceptions",
-      exceptions
-    );
-  },
-
   /**
    * Application shutdown handler.
    */
@@ -1984,13 +1710,10 @@ BrowserGlue.prototype = {
         }
       },
 
-      () => BrowserUsageTelemetry.uninit(),
-      () => SearchSERPTelemetry.uninit(),
       () => Interactions.uninit(),
       () => PageDataService.uninit(),
       () => PageThumbs.uninit(),
       () => NewTabUtils.uninit(),
-      () => Normandy.uninit(),
       () => RFPHelper.uninit(),
       () => ASRouterNewTabHook.destroy(),
       () => UpdateListener.reset(),
@@ -2090,14 +1813,9 @@ BrowserGlue.prototype = {
     const _checkHTTPSOnlyPref = async () => {
       const enabled = Services.prefs.getBoolPref(PREF_ENABLED, false);
       const was_enabled = Services.prefs.getBoolPref(PREF_WAS_ENABLED, false);
-      let value = 0;
       if (enabled) {
-        value = 1;
         Services.prefs.setBoolPref(PREF_WAS_ENABLED, true);
-      } else if (was_enabled) {
-        value = 2;
       }
-      Services.telemetry.scalarSet("security.https_only_mode_enabled", value);
     };
 
     Services.prefs.addObserver(PREF_ENABLED, _checkHTTPSOnlyPref);
@@ -2113,17 +1831,9 @@ BrowserGlue.prototype = {
         PREF_PBM_WAS_ENABLED,
         false
       );
-      let valuePBM = 0;
       if (enabledPBM) {
-        valuePBM = 1;
         Services.prefs.setBoolPref(PREF_PBM_WAS_ENABLED, true);
-      } else if (was_enabledPBM) {
-        valuePBM = 2;
       }
-      Services.telemetry.scalarSet(
-        "security.https_only_mode_enabled_pbm",
-        valuePBM
-      );
     };
 
     Services.prefs.addObserver(PREF_PBM_ENABLED, _checkHTTPSOnlyPBMPref);
@@ -2224,17 +1934,9 @@ BrowserGlue.prototype = {
         false
       );
       const was_enabled = Services.prefs.getBoolPref(PREF_WAS_ENABLED, false);
-      let value = 0;
       if (feature_enabled && functionality_enabled) {
-        value = 1;
         Services.prefs.setBoolPref(PREF_WAS_ENABLED, true);
-      } else if (was_enabled) {
-        value = 2;
       }
-      Services.telemetry.scalarSet(
-        "security.global_privacy_control_enabled",
-        value
-      );
     };
 
     Services.prefs.addObserver(FEATURE_PREF_ENABLED, _checkGPCPref);
@@ -2242,23 +1944,6 @@ BrowserGlue.prototype = {
     _checkGPCPref();
   },
 
-  _monitorPrivacySegmentationPref() {
-    const PREF_ENABLED = "browser.privacySegmentation.enabled";
-    const EVENT_CATEGORY = "privacy_segmentation";
-
-    let checkPrivacySegmentationPref = () => {
-      let isEnabled = Services.prefs.getBoolPref(PREF_ENABLED, false);
-      Services.telemetry.recordEvent(
-        EVENT_CATEGORY,
-        isEnabled ? "enable" : "disable",
-        "pref"
-      );
-    };
-
-    Services.telemetry.setEventRecordingEnabled(EVENT_CATEGORY, true);
-    Services.prefs.addObserver(PREF_ENABLED, checkPrivacySegmentationPref);
-  },
-
   // All initial windows have opened.
   _onWindowsRestored: function BG__onWindowsRestored() {
     if (this._windowsWereRestored) {
@@ -2266,9 +1951,6 @@ BrowserGlue.prototype = {
     }
     this._windowsWereRestored = true;
 
-    BrowserUsageTelemetry.init();
-    SearchSERPTelemetry.init();
-
     Interactions.init();
     PageDataService.init();
     ExtensionsUI.init();
@@ -2336,7 +2018,6 @@ BrowserGlue.prototype = {
     this._setupSearchDetection();
 
     this._monitorGPCPref();
-    this._monitorPrivacySegmentationPref();
   },
 
   /**
@@ -2386,13 +2067,6 @@ BrowserGlue.prototype = {
         },
       },
 
-      {
-        condition: TelemetryUtils.isTelemetryEnabled,
-        task: () => {
-          PlacesDBUtils.telemetry().catch(console.error);
-        },
-      },
-
       // Begin listening for incoming push messages.
       {
         task: () => {
@@ -2408,31 +2082,6 @@ BrowserGlue.prototype = {
         },
       },
 
-      {
-        task: () => {
-          this._recordContentBlockingTelemetry();
-        },
-      },
-
-      {
-        task: () => {
-          this._recordDataSanitizationPrefs();
-        },
-      },
-
-      {
-        task: () => {
-          let enableCertErrorUITelemetry = Services.prefs.getBoolPref(
-            "security.certerrors.recordEventTelemetry",
-            true
-          );
-          Services.telemetry.setEventRecordingEnabled(
-            "security.ui.certerror",
-            enableCertErrorUITelemetry
-          );
-        },
-      },
-
       // Load the Login Manager data from disk off the main thread, some time
       // after startup.  If the data is required before this runs, for example
       // because a restored page contains a password field, it will be loaded on
@@ -2455,71 +2104,6 @@ BrowserGlue.prototype = {
         },
       },
 
-      // Report pinning status and the type of shortcut used to launch
-      {
-        condition: AppConstants.platform == "win",
-        task: async () => {
-          let shellService = Cc[
-            "@mozilla.org/browser/shell-service;1"
-          ].getService(Ci.nsIWindowsShellService);
-          let winTaskbar = Cc["@mozilla.org/windows-taskbar;1"].getService(
-            Ci.nsIWinTaskbar
-          );
-
-          try {
-            Services.telemetry.scalarSet(
-              "os.environment.is_taskbar_pinned",
-              await shellService.isCurrentAppPinnedToTaskbarAsync(
-                winTaskbar.defaultGroupId
-              )
-            );
-            Services.telemetry.scalarSet(
-              "os.environment.is_taskbar_pinned_private",
-              await shellService.isCurrentAppPinnedToTaskbarAsync(
-                winTaskbar.defaultPrivateGroupId
-              )
-            );
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-
-          let classification;
-          let shortcut;
-          try {
-            shortcut = Services.appinfo.processStartupShortcut;
-            classification = shellService.classifyShortcut(shortcut);
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-
-          if (!classification) {
-            if (shortcut) {
-              classification = "OtherShortcut";
-            } else {
-              classification = "Other";
-            }
-          }
-
-          Services.telemetry.scalarSet(
-            "os.environment.launch_method",
-            classification
-          );
-        },
-      },
-
-      // Report whether Firefox is the default handler for various files types,
-      // in particular, ".pdf".
-      {
-        condition: AppConstants.platform == "win",
-        task: () => {
-          Services.telemetry.keyedScalarSet(
-            "os.environment.is_default_handler",
-            ".pdf",
-            ShellService.isDefaultHandlerFor(".pdf")
-          );
-        },
-      },
-
       // Install built-in themes. We already installed the active built-in
       // theme, if any, before UI startup.
       {
@@ -2545,23 +2129,6 @@ BrowserGlue.prototype = {
         },
       },
 
-      // Report macOS Dock status
-      {
-        condition: AppConstants.platform == "macosx",
-        task: () => {
-          try {
-            Services.telemetry.scalarSet(
-              "os.environment.is_kept_in_dock",
-              Cc["@mozilla.org/widget/macdocksupport;1"].getService(
-                Ci.nsIMacDockSupport
-              ).isAppInDock
-            );
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-        },
-      },
-
       {
         task: () => {
           this._maybeShowDefaultBrowserPrompt();
@@ -2818,21 +2385,6 @@ BrowserGlue.prototype = {
   _scheduleBestEffortUserIdleTasks() {
     const idleTasks = [
       () => {
-        // Telemetry for primary-password - we do this after a delay as it
-        // can cause IO if NSS/PSM has not already initialized.
-        let tokenDB = Cc["@mozilla.org/security/pk11tokendb;1"].getService(
-          Ci.nsIPK11TokenDB
-        );
-        let token = tokenDB.getInternalKeyToken();
-        let mpEnabled = token.hasPassword;
-        if (mpEnabled) {
-          Services.telemetry
-            .getHistogramById("MASTER_PASSWORD_ENABLED")
-            .add(mpEnabled);
-        }
-      },
-
-      () => {
         let { GMPInstallManager } = ChromeUtils.import(
           "resource://gre/modules/GMPInstallManager.jsm"
         );
@@ -2861,13 +2413,9 @@ BrowserGlue.prototype = {
         }
       },
 
-      () => BrowserUsageTelemetry.reportProfileCount(),
-
       () => OsEnvironment.reportAllowedAppSources(),
 
       () => Services.search.runBackgroundChecks(),
-
-      () => BrowserUsageTelemetry.reportInstallationTelemetry(),
     ];
 
     for (let task of idleTasks) {
@@ -3059,26 +2607,6 @@ BrowserGlue.prototype = {
       checkboxLabel,
       warnOnClose
     );
-    Services.telemetry.setEventRecordingEnabled("close_tab_warning", true);
-    let warnCheckbox = warnOnClose.value ? "checked" : "unchecked";
-
-    let sessionWillBeRestored =
-      Services.prefs.getIntPref("browser.startup.page") == 3 ||
-      Services.prefs.getBoolPref("browser.sessionstore.resume_session_once");
-    Services.telemetry.recordEvent(
-      "close_tab_warning",
-      "shown",
-      "application",
-      null,
-      {
-        source: this._quitSource,
-        button: buttonPressed == 0 ? "close" : "cancel",
-        warn_checkbox: warnCheckbox,
-        closing_wins: "" + windowcount,
-        closing_tabs: "" + (pagecount + pinnedcount),
-        will_restore: sessionWillBeRestored ? "yes" : "no",
-      }
-    );
 
     // If the user has unticked the box, and has confirmed closing, stop showing
     // the warning.
@@ -4265,15 +3793,6 @@ BrowserGlue.prototype = {
       return NimbusFeatures.upgradeDialog.isEnabled() ? "" : "disabled";
     })();
 
-    // Record why the dialog is showing or not.
-    Services.telemetry.setEventRecordingEnabled("upgrade_dialog", true);
-    Services.telemetry.recordEvent(
-      "upgrade_dialog",
-      "trigger",
-      "reason",
-      dialogReason || "satisfied"
-    );
-
     // Show the upgrade dialog if allowed and remember the version.
     if (!dialogReason) {
       Services.prefs.setIntPref(dialogVersionPref, dialogVersion);
@@ -4648,39 +4167,6 @@ BrowserGlue.prototype = {
   },
 
   _collectTelemetryPiPEnabled() {
-    Services.telemetry.setEventRecordingEnabled(
-      "pictureinpicture.settings",
-      true
-    );
-    Services.telemetry.setEventRecordingEnabled("pictureinpicture", true);
-
-    const TOGGLE_ENABLED_PREF =
-      "media.videocontrols.picture-in-picture.video-toggle.enabled";
-
-    const observe = (subject, topic, data) => {
-      const enabled = Services.prefs.getBoolPref(TOGGLE_ENABLED_PREF, false);
-      Services.telemetry.scalarSet("pictureinpicture.toggle_enabled", enabled);
-
-      // Record events when preferences change
-      if (topic === "nsPref:changed") {
-        if (enabled) {
-          Services.telemetry.recordEvent(
-            "pictureinpicture.settings",
-            "enable",
-            "player"
-          );
-        } else {
-          Services.telemetry.recordEvent(
-            "pictureinpicture.settings",
-            "disable",
-            "player"
-          );
-        }
-      }
-    };
-
-    Services.prefs.addObserver(TOGGLE_ENABLED_PREF, observe);
-    observe();
   },
 
   QueryInterface: ChromeUtils.generateQI([
@@ -5108,35 +4594,6 @@ ContentPermissionPrompt.prototype = {
       request.cancel();
       throw ex;
     }
-
-    let schemeHistogram = Services.telemetry.getKeyedHistogramById(
-      "PERMISSION_REQUEST_ORIGIN_SCHEME"
-    );
-    let scheme = 0;
-    try {
-      if (request.principal.schemeIs("http")) {
-        scheme = 1;
-      } else if (request.principal.schemeIs("https")) {
-        scheme = 2;
-      }
-    } catch (ex) {
-      // If the request principal is not available at this point,
-      // the request has likely been cancelled before being shown to the
-      // user. We shouldn't record this request.
-      if (ex.result != Cr.NS_ERROR_FAILURE) {
-        Cu.reportError(ex);
-      }
-      return;
-    }
-    schemeHistogram.add(type, scheme);
-
-    let userInputHistogram = Services.telemetry.getKeyedHistogramById(
-      "PERMISSION_REQUEST_HANDLING_USER_INPUT"
-    );
-    userInputHistogram.add(
-      type,
-      request.hasValidTransientUserGestureActivation
-    );
   },
 };
 
@@ -5201,15 +4658,6 @@ var DefaultBrowserCheck = {
     } else if (checkboxState) {
       shellService.shouldCheckDefaultBrowser = false;
     }
-
-    try {
-      let resultEnum = buttonNumClicked * 2 + !checkboxState;
-      Services.telemetry
-        .getHistogramById("BROWSER_SET_DEFAULT_RESULT")
-        .add(resultEnum);
-    } catch (ex) {
-      /* Don't break if Telemetry is acting up. */
-    }
   },
 
   /**
@@ -5299,27 +4747,6 @@ var DefaultBrowserCheck = {
       }
     }
 
-    if (isStartupCheck) {
-      try {
-        // Report default browser status on startup to telemetry
-        // so we can track whether we are the default.
-        Services.telemetry
-          .getHistogramById("BROWSER_IS_USER_DEFAULT")
-          .add(isDefault);
-        Services.telemetry
-          .getHistogramById("BROWSER_IS_USER_DEFAULT_ERROR")
-          .add(isDefaultError);
-        Services.telemetry
-          .getHistogramById("BROWSER_SET_DEFAULT_ALWAYS_CHECK")
-          .add(shouldCheck);
-        Services.telemetry
-          .getHistogramById("BROWSER_SET_DEFAULT_DIALOG_PROMPT_RAWCOUNT")
-          .add(promptCount);
-      } catch (ex) {
-        /* Don't break the default prompt if telemetry is broken. */
-      }
-    }
-
     return willPrompt;
   },
 };
@@ -5520,7 +4947,6 @@ var AboutHomeStartupCache = {
     this._enabled = NimbusFeatures.abouthomecache.isEnabled();
 
     if (!this._enabled) {
-      this.recordResult(this.CACHE_RESULT_SCALARS.DISABLED);
       return;
     }
 
@@ -5540,13 +4966,11 @@ var AboutHomeStartupCache = {
 
     if (!willLoadAboutHome) {
       this.log.trace("Not configured to load about:home by default.");
-      this.recordResult(this.CACHE_RESULT_SCALARS.NOT_LOADING_ABOUTHOME);
       return;
     }
 
     if (!Services.prefs.getBoolPref(this.PRELOADED_NEWTAB_PREF, false)) {
       this.log.trace("Preloaded about:newtab disabled.");
-      this.recordResult(this.CACHE_RESULT_SCALARS.PRELOADING_DISABLED);
       return;
     }
 
@@ -5681,11 +5105,6 @@ var AboutHomeStartupCache = {
       this._cacheTask.arm();
     }
 
-    Services.telemetry.scalarSet(
-      "browser.startup.abouthome_cache_shutdownwrite",
-      this._cacheTask.isArmed
-    );
-
     if (this._cacheTask.isArmed) {
       this.log.trace("Finalizing cache task on shutdown");
       this._finalized = true;
@@ -6176,61 +5595,6 @@ var AboutHomeStartupCache = {
     }
   },
 
-  /**
-   * Records the final result of how the cache operated for the user
-   * during this session to Telemetry.
-   */
-  recordResult(result) {
-    // Note: this can be called very early on in the lifetime of
-    // AboutHomeStartupCache, so things like this.log might not exist yet.
-    Services.telemetry.scalarSet(
-      "browser.startup.abouthome_cache_result",
-      result
-    );
-  },
-
-  /**
-   * Called when the parent process receives a message from the privileged
-   * about content process saying whether or not reading from the cache
-   * was successful.
-   *
-   * @param success (boolean)
-   *   True if reading from the cache succeeded.
-   */
-  onUsageResult(success) {
-    this.log.trace(`Received usage result. Success = ${success}`);
-    if (success) {
-      if (
-        this._cacheDeferredResultScalar !=
-        this.CACHE_RESULT_SCALARS.VALID_AND_USED
-      ) {
-        this.log.error(
-          "Somehow got a success result despite having never " +
-            "successfully sent down the cache streams"
-        );
-        this.recordResult(this._cacheDeferredResultScalar);
-      } else {
-        this.recordResult(this.CACHE_RESULT_SCALARS.VALID_AND_USED);
-      }
-
-      return;
-    }
-
-    if (
-      this._cacheDeferredResultScalar ==
-      this.CACHE_RESULT_SCALARS.VALID_AND_USED
-    ) {
-      // We failed to read from the cache despite having successfully
-      // sent it down to the content process. We presume then that the
-      // streams just didn't provide any bytes in time.
-      this.recordResult(this.CACHE_RESULT_SCALARS.LATE);
-    } else {
-      // We failed to read the cache, but already knew why. We can
-      // now record that value.
-      this.recordResult(this._cacheDeferredResultScalar);
-    }
-  },
-
   QueryInterface: ChromeUtils.generateQI([
     "nsICacheEntryOpenallback",
     "nsIObserver",
@@ -6259,10 +5623,6 @@ var AboutHomeStartupCache = {
         this._cacheDeferred = null;
         break;
       }
-      case this.CACHE_USAGE_RESULT_MESSAGE: {
-        this.onUsageResult(message.data.success);
-        break;
-      }
     }
   },
 
diff --git a/browser/components/aboutlogins/AboutLoginsChild.jsm b/browser/components/aboutlogins/AboutLoginsChild.jsm
--- a/browser/components/aboutlogins/AboutLoginsChild.jsm
+++ b/browser/components/aboutlogins/AboutLoginsChild.jsm
@@ -21,30 +21,12 @@ XPCOMUtils.defineLazyServiceGetter(
   "nsIClipboardHelper"
 );
 
-const TELEMETRY_EVENT_CATEGORY = "pwmgr";
 const TELEMETRY_MIN_MS_BETWEEN_OPEN_MANAGEMENT = 5000;
 
 let gLastOpenManagementBrowserId = null;
 let gLastOpenManagementEventTime = Number.NEGATIVE_INFINITY;
 let gPrimaryPasswordPromise;
 
-function recordTelemetryEvent(event) {
-  try {
-    let { method, object, extra = {}, value = null } = event;
-    Services.telemetry.recordEvent(
-      TELEMETRY_EVENT_CATEGORY,
-      method,
-      object,
-      value,
-      extra
-    );
-  } catch (ex) {
-    Cu.reportError(
-      "AboutLoginsChild: error recording telemetry event: " + ex.message
-    );
-  }
-}
-
 class AboutLoginsChild extends JSWindowActorChild {
   handleEvent(event) {
     switch (event.type) {
@@ -88,10 +70,6 @@ class AboutLoginsChild extends JSWindowA
         this.#aboutLoginsOpenPreferences();
         break;
       }
-      case "AboutLoginsRecordTelemetryEvent": {
-        this.#aboutLoginsRecordTelemetryEvent(event);
-        break;
-      }
       case "AboutLoginsRemoveAllLogins": {
         this.#aboutLoginsRemoveAllLogins();
         break;
@@ -193,50 +171,14 @@ class AboutLoginsChild extends JSWindowA
 
   #aboutLoginsImportFromBrowser() {
     this.sendAsyncMessage("AboutLogins:ImportFromBrowser");
-    recordTelemetryEvent({
-      object: "import_from_browser",
-      method: "mgmt_menu_item_used",
-    });
   }
 
   #aboutLoginsImportFromFile() {
     this.sendAsyncMessage("AboutLogins:ImportFromFile");
-    recordTelemetryEvent({
-      object: "import_from_csv",
-      method: "mgmt_menu_item_used",
-    });
   }
 
   #aboutLoginsOpenPreferences() {
     this.sendAsyncMessage("AboutLogins:OpenPreferences");
-    recordTelemetryEvent({
-      object: "preferences",
-      method: "mgmt_menu_item_used",
-    });
-  }
-
-  #aboutLoginsRecordTelemetryEvent(event) {
-    let { method } = event.detail;
-
-    if (method == "open_management") {
-      let { docShell } = this.browsingContext;
-      // Compare to the last time open_management was recorded for the same
-      // outerWindowID to not double-count them due to a redirect to remove
-      // the entryPoint query param (since replaceState isn't allowed for
-      // about:). Don't use performance.now for the tab since you can't
-      // compare that number between different tabs and this JSM is shared.
-      let now = docShell.now();
-      if (
-        this.browsingContext.browserId == gLastOpenManagementBrowserId &&
-        now - gLastOpenManagementEventTime <
-          TELEMETRY_MIN_MS_BETWEEN_OPEN_MANAGEMENT
-      ) {
-        return;
-      }
-      gLastOpenManagementEventTime = now;
-      gLastOpenManagementBrowserId = this.browsingContext.browserId;
-    }
-    recordTelemetryEvent(event.detail);
   }
 
   #aboutLoginsRemoveAllLogins() {
@@ -287,7 +229,6 @@ class AboutLoginsChild extends JSWindowA
   #primaryPasswordResponse(data) {
     if (gPrimaryPasswordPromise) {
       gPrimaryPasswordPromise.resolve(data.result);
-      recordTelemetryEvent(data.telemetryEvent);
     }
   }
 
diff --git a/browser/components/aboutlogins/content/aboutLogins.js b/browser/components/aboutlogins/content/aboutLogins.js
--- a/browser/components/aboutlogins/content/aboutLogins.js
+++ b/browser/components/aboutlogins/content/aboutLogins.js
@@ -3,7 +3,6 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 import {
-  recordTelemetryEvent,
   setKeyboardAccessForNonDialogElements,
 } from "./aboutLoginsUtils.js";
 
@@ -196,10 +195,6 @@ window.addEventListener("AboutLoginsRemo
 });
 
 window.addEventListener("AboutLoginsExportPasswordsDialog", async event => {
-  recordTelemetryEvent({
-    object: "export",
-    method: "mgmt_menu_item_used",
-  });
   let dialog = document.querySelector("confirmation-dialog");
   let options = {
     title: "about-logins-confirm-export-dialog-title",
@@ -221,11 +216,6 @@ window.addEventListener("AboutLoginsExpo
 let searchParamsChanged = false;
 let { protocol, pathname, searchParams } = new URL(document.location);
 
-recordTelemetryEvent({
-  method: "open_management",
-  object: searchParams.get("entryPoint") || "direct",
-});
-
 if (searchParams.has("entryPoint")) {
   // Remove this parameter from the URL (after recording above) to make it
   // cleaner for bookmarking and switch-to-tab and so that bookmarked values
diff --git a/browser/components/aboutlogins/content/aboutLoginsUtils.js b/browser/components/aboutlogins/content/aboutLoginsUtils.js
--- a/browser/components/aboutlogins/content/aboutLoginsUtils.js
+++ b/browser/components/aboutlogins/content/aboutLoginsUtils.js
@@ -2,22 +2,6 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-/**
- * Dispatches a custom event to the AboutLoginsChild.jsm script which
- * will record the event.
- * @param {object} event.method The telemety event method
- * @param {object} event.object The telemety event object
- * @param {object} event.value [optional] The telemety event value
- */
-export function recordTelemetryEvent(event) {
-  document.dispatchEvent(
-    new CustomEvent("AboutLoginsRecordTelemetryEvent", {
-      bubbles: true,
-      detail: event,
-    })
-  );
-}
-
 export function setKeyboardAccessForNonDialogElements(enableKeyboardAccess) {
   const pageElements = document.querySelectorAll(
     "login-item, login-list, menu-button, login-filter, fxaccounts-button, [tabindex]"
diff --git a/browser/components/aboutlogins/content/components/login-filter.js b/browser/components/aboutlogins/content/components/login-filter.js
--- a/browser/components/aboutlogins/content/components/login-filter.js
+++ b/browser/components/aboutlogins/content/components/login-filter.js
@@ -2,8 +2,6 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-import { recordTelemetryEvent } from "../aboutLoginsUtils.js";
-
 export default class LoginFilter extends HTMLElement {
   get #loginList() {
     return document.querySelector("login-list");
@@ -92,8 +90,6 @@ export default class LoginFilter extends
         detail: value,
       })
     );
-
-    recordTelemetryEvent({ object: "list", method: "filter" });
   }
 }
 customElements.define("login-filter", LoginFilter);
diff --git a/browser/components/aboutlogins/content/components/login-item.js b/browser/components/aboutlogins/content/components/login-item.js
--- a/browser/components/aboutlogins/content/components/login-item.js
+++ b/browser/components/aboutlogins/content/components/login-item.js
@@ -3,7 +3,6 @@
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
 import {
-  recordTelemetryEvent,
   promptForPrimaryPassword,
 } from "../aboutLoginsUtils.js";
 
@@ -362,9 +361,6 @@ export default class LoginItem extends H
             }
           }
           this._updatePasswordRevealState();
-
-          let method = this._revealCheckbox.checked ? "show" : "hide";
-          this._recordTelemetryEvent({ object: "password", method });
           return;
         }
 
@@ -380,10 +376,6 @@ export default class LoginItem extends H
             }
           } else if (!this.hasPendingChanges()) {
             window.dispatchEvent(new CustomEvent("AboutLoginsClearSelection"));
-            this._recordTelemetryEvent({
-              object: "new_login",
-              method: "cancel",
-            });
           } else {
             this.showConfirmationDialog("discard-changes", () => {
               window.dispatchEvent(
@@ -440,10 +432,6 @@ export default class LoginItem extends H
             this._copyUsernameTimeoutId = timeoutId;
           }
 
-          this._recordTelemetryEvent({
-            object: copyButton.dataset.telemetryObject,
-            method: "copy",
-          });
           return;
         }
         if (classList.contains("delete-button")) {
@@ -468,10 +456,6 @@ export default class LoginItem extends H
           this._toggleEditing();
           this.render();
 
-          this._recordTelemetryEvent({
-            object: "existing_login",
-            method: "edit",
-          });
           return;
         }
         if (
@@ -492,19 +476,6 @@ export default class LoginItem extends H
         if (classList.contains("origin-input")) {
           this._handleOriginClick();
         }
-        if (classList.contains("alert-learn-more-link")) {
-          if (event.currentTarget.closest(".breach-alert")) {
-            this._recordTelemetryEvent({
-              object: "existing_login",
-              method: "learn_more_breach",
-            });
-          } else if (event.currentTarget.closest(".vulnerable-alert")) {
-            this._recordTelemetryEvent({
-              object: "existing_login",
-              method: "learn_more_vuln",
-            });
-          }
-        }
         break;
       }
       case "submit": {
@@ -527,11 +498,6 @@ export default class LoginItem extends H
               detail: loginUpdates,
             })
           );
-
-          this._recordTelemetryEvent({
-            object: "existing_login",
-            method: "save",
-          });
         } else {
           document.dispatchEvent(
             new CustomEvent("AboutLoginsCreateLogin", {
@@ -539,8 +505,6 @@ export default class LoginItem extends H
               detail: loginUpdates,
             })
           );
-
-          this._recordTelemetryEvent({ object: "new_login", method: "save" });
         }
         break;
       }
@@ -556,8 +520,6 @@ export default class LoginItem extends H
           this._revealCheckbox.checked = false;
         }
         this._updatePasswordRevealState();
-        let method = this._revealCheckbox.checked ? "show" : "hide";
-        this._recordTelemetryEvent({ object: "password", method });
         break;
       }
     }
@@ -623,10 +585,6 @@ export default class LoginItem extends H
         try {
           onConfirm();
         } catch (ex) {}
-        this._recordTelemetryEvent({
-          object: wasExistingLogin ? "existing_login" : "new_login",
-          method,
-        });
       },
       () => {}
     );
@@ -770,10 +728,6 @@ export default class LoginItem extends H
   }
 
   _handleOriginClick() {
-    this._recordTelemetryEvent({
-      object: "existing_login",
-      method: "open_site",
-    });
   }
 
   /**
@@ -810,23 +764,6 @@ export default class LoginItem extends H
     });
   }
 
-  _recordTelemetryEvent(eventObject) {
-    // Breach alerts have higher priority than vulnerable logins, the
-    // following conditionals must reflect this priority.
-    const extra = eventObject.hasOwnProperty("extra") ? eventObject.extra : {};
-    if (this._breachesMap && this._breachesMap.has(this._login.guid)) {
-      Object.assign(extra, { breached: "true" });
-      eventObject.extra = extra;
-    } else if (
-      this._vulnerableLoginsMap &&
-      this._vulnerableLoginsMap.has(this._login.guid)
-    ) {
-      Object.assign(extra, { vulnerable: "true" });
-      eventObject.extra = extra;
-    }
-    recordTelemetryEvent(eventObject);
-  }
-
   /**
    * Toggles the login-item view from editing to non-editing mode.
    *
diff --git a/browser/components/aboutlogins/content/components/login-list.js b/browser/components/aboutlogins/content/components/login-list.js
--- a/browser/components/aboutlogins/content/components/login-list.js
+++ b/browser/components/aboutlogins/content/components/login-list.js
@@ -4,7 +4,6 @@
 
 import LoginListItemFactory from "./login-list-item.js";
 import LoginListSectionFactory from "./login-list-section.js";
-import { recordTelemetryEvent } from "../aboutLoginsUtils.js";
 
 const collator = new Intl.Collator();
 const monthFormatter = new Intl.DateTimeFormat(undefined, { month: "long" });
@@ -289,7 +288,6 @@ export default class LoginList extends H
               cancelable: true,
             })
           );
-          recordTelemetryEvent({ object: "new_login", method: "new" });
           return;
         }
 
@@ -307,25 +305,11 @@ export default class LoginList extends H
             detail: login,
           })
         );
-
-        let extra = {};
-        if (listItem.classList.contains("breached")) {
-          extra = { breached: "true" };
-        } else if (listItem.classList.contains("vulnerable")) {
-          extra = { vulnerable: "true" };
-        }
-        recordTelemetryEvent({
-          object: "existing_login",
-          method: "select",
-          extra,
-        });
         break;
       }
       case "change": {
         this._applyHeaders();
         this._applySortAndScrollToTop();
-        const extra = { sort_key: this._sortSelect.value };
-        recordTelemetryEvent({ object: "list", method: "sort", extra });
         document.dispatchEvent(
           new CustomEvent("AboutLoginsSortChanged", {
             bubbles: true,
diff --git a/browser/components/customizableui/CustomizableUI.jsm b/browser/components/customizableui/CustomizableUI.jsm
--- a/browser/components/customizableui/CustomizableUI.jsm
+++ b/browser/components/customizableui/CustomizableUI.jsm
@@ -21,7 +21,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   PanelMultiView: "resource:///modules/PanelMultiView.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   ShortcutUtils: "resource://gre/modules/ShortcutUtils.jsm",
-  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
   HomePage: "resource:///modules/HomePage.jsm",
 });
 
@@ -4559,9 +4558,6 @@ var CustomizableUI = {
         if (!item.hasAttribute("onclick")) {
           subviewItem.addEventListener("click", event => {
             let newEvent = new doc.defaultView.MouseEvent(event.type, event);
-
-            // Telemetry should only pay attention to the original event.
-            BrowserUsageTelemetry.ignoreEvent(newEvent);
             item.dispatchEvent(newEvent);
           });
         }
@@ -4583,9 +4579,6 @@ var CustomizableUI = {
               event.sourceEvent,
               0
             );
-
-            // Telemetry should only pay attention to the original event.
-            BrowserUsageTelemetry.ignoreEvent(newEvent);
             item.dispatchEvent(newEvent);
           });
         }
diff --git a/browser/components/customizableui/CustomizeMode.jsm b/browser/components/customizableui/CustomizeMode.jsm
--- a/browser/components/customizableui/CustomizeMode.jsm
+++ b/browser/components/customizableui/CustomizeMode.jsm
@@ -42,21 +42,11 @@ ChromeUtils.defineModuleGetter(
 );
 ChromeUtils.defineModuleGetter(
   this,
-  "AMTelemetry",
-  "resource://gre/modules/AddonManager.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "DragPositionManager",
   "resource:///modules/DragPositionManager.jsm"
 );
 ChromeUtils.defineModuleGetter(
   this,
-  "BrowserUsageTelemetry",
-  "resource:///modules/BrowserUsageTelemetry.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "SessionStore",
   "resource:///modules/sessionstore/SessionStore.jsm"
 );
@@ -707,10 +697,6 @@ CustomizeMode.prototype = {
     }
 
     CustomizableUI.addWidgetToArea(widgetToAdd, CustomizableUI.AREA_NAVBAR);
-    BrowserUsageTelemetry.recordWidgetChange(
-      widgetToAdd,
-      CustomizableUI.AREA_NAVBAR
-    );
     if (!this._customizing) {
       CustomizableUI.dispatchToolboxEvent("customizationchange");
     }
@@ -741,7 +727,6 @@ CustomizeMode.prototype = {
 
     let panel = CustomizableUI.AREA_FIXED_OVERFLOW_PANEL;
     CustomizableUI.addWidgetToArea(aNode.id, panel);
-    BrowserUsageTelemetry.recordWidgetChange(aNode.id, panel, aReason);
     if (!this._customizing) {
       CustomizableUI.dispatchToolboxEvent("customizationchange");
     }
@@ -783,7 +768,6 @@ CustomizeMode.prototype = {
     }
 
     CustomizableUI.removeWidgetFromArea(aNode.id);
-    BrowserUsageTelemetry.recordWidgetChange(aNode.id, null, aReason);
     if (!this._customizing) {
       CustomizableUI.dispatchToolboxEvent("customizationchange");
     }
@@ -1399,13 +1383,11 @@ CustomizeMode.prototype = {
   },
 
   openAddonsManagerThemes() {
-    AMTelemetry.recordLinkEvent({ object: "customize", value: "manageThemes" });
     this.window.BrowserOpenAddonsMgr("addons://list/theme");
   },
 
   getMoreThemes(aEvent) {
     aEvent.target.parentNode.parentNode.hidePopup();
-    AMTelemetry.recordLinkEvent({ object: "customize", value: "getThemes" });
     let getMoreURL = Services.urlFormatter.formatURLPref(
       "lightweightThemes.getMoreURL"
     );
@@ -2045,7 +2027,6 @@ CustomizeMode.prototype = {
         }
 
         CustomizableUI.removeWidgetFromArea(aDraggedItemId, "drag");
-        BrowserUsageTelemetry.recordWidgetChange(aDraggedItemId, null, "drag");
         // Special widgets are removed outright, we can return here:
         if (CustomizableUI.isSpecialWidget(aDraggedItemId)) {
           return;
@@ -2104,11 +2085,6 @@ CustomizeMode.prototype = {
     // widget to the end of the area.
     if (aTargetNode == areaCustomizationTarget) {
       CustomizableUI.addWidgetToArea(aDraggedItemId, aTargetArea.id);
-      BrowserUsageTelemetry.recordWidgetChange(
-        aDraggedItemId,
-        aTargetArea.id,
-        "drag"
-      );
       this._onDragEnd(aEvent);
       return;
     }
@@ -2157,18 +2133,8 @@ CustomizeMode.prototype = {
     // that the widget is moving within a customizable area.
     if (aTargetArea == aOriginArea) {
       CustomizableUI.moveWidgetWithinArea(aDraggedItemId, position);
-      BrowserUsageTelemetry.recordWidgetChange(
-        aDraggedItemId,
-        aTargetArea.id,
-        "drag"
-      );
     } else {
       CustomizableUI.addWidgetToArea(aDraggedItemId, aTargetArea.id, position);
-      BrowserUsageTelemetry.recordWidgetChange(
-        aDraggedItemId,
-        aTargetArea.id,
-        "drag"
-      );
     }
 
     this._onDragEnd(aEvent);
@@ -2610,11 +2576,6 @@ CustomizeMode.prototype = {
         "nav-bar",
         insertionPoint
       );
-      BrowserUsageTelemetry.recordWidgetChange(
-        "downloads-button",
-        "nav-bar",
-        "move-downloads"
-      );
     }
   },
 
diff --git a/browser/components/customizableui/SearchWidgetTracker.jsm b/browser/components/customizableui/SearchWidgetTracker.jsm
--- a/browser/components/customizableui/SearchWidgetTracker.jsm
+++ b/browser/components/customizableui/SearchWidgetTracker.jsm
@@ -21,11 +21,6 @@ ChromeUtils.defineModuleGetter(
   "CustomizableUI",
   "resource:///modules/CustomizableUI.jsm"
 );
-ChromeUtils.defineModuleGetter(
-  this,
-  "BrowserUsageTelemetry",
-  "resource:///modules/BrowserUsageTelemetry.jsm"
-);
 
 const WIDGET_ID = "search-container";
 const PREF_NAME = "browser.search.widget.inNavBar";
@@ -90,14 +85,8 @@ const SearchWidgetTracker = {
         CustomizableUI.AREA_NAVBAR,
         CustomizableUI.getPlacementOfWidget("urlbar-container").position + 1
       );
-      BrowserUsageTelemetry.recordWidgetChange(
-        WIDGET_ID,
-        CustomizableUI.AREA_NAVBAR,
-        "searchpref"
-      );
     } else {
       CustomizableUI.removeWidgetFromArea(WIDGET_ID);
-      BrowserUsageTelemetry.recordWidgetChange(WIDGET_ID, null, "searchpref");
     }
   },
 
diff --git a/browser/components/extensions/parent/ext-browserAction.js b/browser/components/extensions/parent/ext-browserAction.js
--- a/browser/components/extensions/parent/ext-browserAction.js
+++ b/browser/components/extensions/parent/ext-browserAction.js
@@ -18,11 +18,6 @@ ChromeUtils.defineModuleGetter(
 );
 ChromeUtils.defineModuleGetter(
   this,
-  "ExtensionTelemetry",
-  "resource://gre/modules/ExtensionTelemetry.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "setTimeout",
   "resource://gre/modules/Timer.jsm"
 );
@@ -31,11 +26,6 @@ ChromeUtils.defineModuleGetter(
   "ViewPopup",
   "resource:///modules/ExtensionPopups.jsm"
 );
-ChromeUtils.defineModuleGetter(
-  this,
-  "BrowserUsageTelemetry",
-  "resource:///modules/BrowserUsageTelemetry.jsm"
-);
 
 var { DefaultWeakMap } = ExtensionUtils;
 
@@ -153,34 +143,12 @@ this.browserAction = class extends Exten
   }
 
   static onUpdate(id, manifest) {
-    if (!("browser_action" in manifest || "action" in manifest)) {
-      // If the new version has no browser action then mark this widget as
-      // hidden in the telemetry. If it is already marked hidden then this will
-      // do nothing.
-      BrowserUsageTelemetry.recordWidgetChange(
-        actionWidgetId(makeWidgetId(id)),
-        null,
-        "addon"
-      );
-    }
   }
 
   static onDisable(id) {
-    BrowserUsageTelemetry.recordWidgetChange(
-      actionWidgetId(makeWidgetId(id)),
-      null,
-      "addon"
-    );
   }
 
   static onUninstall(id) {
-    // If the telemetry already has this widget as hidden then this will not
-    // record anything.
-    BrowserUsageTelemetry.recordWidgetChange(
-      actionWidgetId(makeWidgetId(id)),
-      null,
-      "addon"
-    );
   }
 
   onShutdown() {
@@ -258,12 +226,6 @@ this.browserAction = class extends Exten
       },
 
       onViewShowing: async event => {
-        const { extension } = this;
-
-        ExtensionTelemetry.browserActionPopupOpen.stopwatchStart(
-          extension,
-          this
-        );
         let document = event.target.ownerDocument;
         let tabbrowser = document.defaultView.gBrowser;
 
@@ -276,30 +238,14 @@ this.browserAction = class extends Exten
             let attachPromise = popup.attach(event.target);
             event.detail.addBlocker(attachPromise);
             await attachPromise;
-            ExtensionTelemetry.browserActionPopupOpen.stopwatchFinish(
-              extension,
-              this
-            );
             if (this.eventQueue.length) {
-              ExtensionTelemetry.browserActionPreloadResult.histogramAdd({
-                category: "popupShown",
-                extension,
-              });
               this.eventQueue = [];
             }
           } catch (e) {
-            ExtensionTelemetry.browserActionPopupOpen.stopwatchCancel(
-              extension,
-              this
-            );
             Cu.reportError(e);
             event.preventDefault();
           }
         } else {
-          ExtensionTelemetry.browserActionPopupOpen.stopwatchCancel(
-            extension,
-            this
-          );
           // This isn't not a hack, but it seems to provide the correct behavior
           // with the fewest complications.
           event.preventDefault();
@@ -313,12 +259,6 @@ this.browserAction = class extends Exten
       // Make sure the browser telemetry has the correct state for this widget.
       // Defer loading BrowserUsageTelemetry until after startup is complete.
       ExtensionParent.browserStartupPromise.then(() => {
-        let placement = CustomizableUI.getPlacementOfWidget(widget.id);
-        BrowserUsageTelemetry.recordWidgetChange(
-          widget.id,
-          placement?.area || null,
-          "addon"
-        );
       });
     }
 
@@ -430,10 +370,6 @@ this.browserAction = class extends Exten
       case "mouseout":
         if (this.pendingPopup) {
           if (this.eventQueue.length) {
-            ExtensionTelemetry.browserActionPreloadResult.histogramAdd({
-              category: `clearAfter${this.eventQueue.pop()}`,
-              extension: this.extension,
-            });
             this.eventQueue = [];
           }
           this.clearPopup();
diff --git a/browser/components/extensions/parent/ext-pageAction.js b/browser/components/extensions/parent/ext-pageAction.js
--- a/browser/components/extensions/parent/ext-pageAction.js
+++ b/browser/components/extensions/parent/ext-pageAction.js
@@ -8,11 +8,6 @@
 
 ChromeUtils.defineModuleGetter(
   this,
-  "ExtensionTelemetry",
-  "resource://gre/modules/ExtensionTelemetry.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "PageActions",
   "resource:///modules/PageActions.jsm"
 );
@@ -21,11 +16,6 @@ ChromeUtils.defineModuleGetter(
   "PanelPopup",
   "resource:///modules/ExtensionPopups.jsm"
 );
-ChromeUtils.defineModuleGetter(
-  this,
-  "BrowserUsageTelemetry",
-  "resource:///modules/BrowserUsageTelemetry.jsm"
-);
 
 var { DefaultWeakMap } = ExtensionUtils;
 
@@ -68,22 +58,12 @@ this.pageAction = class extends Extensio
   }
 
   static onUpdate(id, manifest) {
-    if (!("page_action" in manifest)) {
-      // If the new version has no page action then mark this widget as hidden
-      // in the telemetry. If it is already marked hidden then this will do
-      // nothing.
-      BrowserUsageTelemetry.recordWidgetChange(makeWidgetId(id), null, "addon");
-    }
   }
 
   static onDisable(id) {
-    BrowserUsageTelemetry.recordWidgetChange(makeWidgetId(id), null, "addon");
   }
 
   static onUninstall(id) {
-    // If the telemetry already has this widget as hidden then this will not
-    // record anything.
-    BrowserUsageTelemetry.recordWidgetChange(makeWidgetId(id), null, "addon");
   }
 
   async onManifestEntry(entryName) {
@@ -160,13 +140,6 @@ this.pageAction = class extends Extensio
         // Make sure the browser telemetry has the correct state for this widget.
         // Defer loading BrowserUsageTelemetry until after startup is complete.
         ExtensionParent.browserStartupPromise.then(() => {
-          BrowserUsageTelemetry.recordWidgetChange(
-            widgetId,
-            this.browserPageAction.pinnedToUrlbar
-              ? "page-action-buttons"
-              : null,
-            "addon"
-          );
         });
       }
 
@@ -297,7 +270,6 @@ this.pageAction = class extends Extensio
   async handleClick(window, clickInfo) {
     const { extension } = this;
 
-    ExtensionTelemetry.pageActionPopupOpen.stopwatchStart(extension, this);
     let tab = window.gBrowser.selectedTab;
     let popupURL = this.action.triggerClickOrPopup(tab, clickInfo);
 
@@ -308,7 +280,6 @@ this.pageAction = class extends Extensio
     if (popupURL) {
       if (this.popupNode && this.popupNode.panel.state !== "closed") {
         // The panel is being toggled closed.
-        ExtensionTelemetry.pageActionPopupOpen.stopwatchCancel(extension, this);
         window.BrowserPageActions.togglePanelForAction(
           this.browserPageAction,
           this.popupNode.panel
@@ -335,9 +306,6 @@ this.pageAction = class extends Extensio
         this.browserPageAction,
         this.popupNode.panel
       );
-      ExtensionTelemetry.pageActionPopupOpen.stopwatchFinish(extension, this);
-    } else {
-      ExtensionTelemetry.pageActionPopupOpen.stopwatchCancel(extension, this);
     }
   }
 
diff --git a/browser/components/newtab/aboutwelcome/AboutWelcomeChild.jsm b/browser/components/newtab/aboutwelcome/AboutWelcomeChild.jsm
--- a/browser/components/newtab/aboutwelcome/AboutWelcomeChild.jsm
+++ b/browser/components/newtab/aboutwelcome/AboutWelcomeChild.jsm
@@ -286,12 +286,6 @@ class AboutWelcomeChild extends JSWindow
    * @param {object} eventData
    */
   AWSendEventTelemetry(eventData) {
-    this.AWSendToParent("TELEMETRY_EVENT", {
-      ...eventData,
-      event_context: {
-        ...eventData.event_context,
-      },
-    });
   }
 
   /**
diff --git a/browser/components/newtab/aboutwelcome/AboutWelcomeParent.jsm b/browser/components/newtab/aboutwelcome/AboutWelcomeParent.jsm
--- a/browser/components/newtab/aboutwelcome/AboutWelcomeParent.jsm
+++ b/browser/components/newtab/aboutwelcome/AboutWelcomeParent.jsm
@@ -19,8 +19,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   MigrationUtils: "resource:///modules/MigrationUtils.jsm",
   SpecialMessageActions:
     "resource://messaging-system/lib/SpecialMessageActions.jsm",
-  AboutWelcomeTelemetry:
-    "resource://activity-stream/aboutwelcome/lib/AboutWelcomeTelemetry.jsm",
   AboutWelcomeDefaults:
     "resource://activity-stream/aboutwelcome/lib/AboutWelcomeDefaults.jsm",
   PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
@@ -36,12 +34,6 @@ XPCOMUtils.defineLazyGetter(this, "log",
   return new Logger("AboutWelcomeParent");
 });
 
-XPCOMUtils.defineLazyGetter(
-  this,
-  "Telemetry",
-  () => new AboutWelcomeTelemetry()
-);
-
 const DID_SEE_ABOUT_WELCOME_PREF = "trailhead.firstrun.didSeeAboutWelcome";
 const AWTerminate = {
   WINDOW_CLOSED: "welcome-window-closed",
@@ -218,15 +210,6 @@ class AboutWelcomeParent extends JSWindo
       this.AboutWelcomeObserver.stop();
     }
     this.RegionHomeObserver?.stop();
-
-    Telemetry.sendTelemetry({
-      event: "SESSION_END",
-      event_context: {
-        reason: this.AboutWelcomeObserver.terminateReason,
-        page: "about:welcome",
-      },
-      message_id: this.AWMessageId,
-    });
   }
 
   /**
@@ -254,12 +237,6 @@ class AboutWelcomeParent extends JSWindo
         return FxAccounts.config.promiseMetricsFlowURI("aboutwelcome");
       case "AWPage:IMPORTABLE_SITES":
         return getImportableSites();
-      case "AWPage:TELEMETRY_EVENT":
-        Telemetry.sendTelemetry(data);
-        break;
-      case "AWPage:GET_ATTRIBUTION_DATA":
-        let attributionData = await AboutWelcomeDefaults.getAttributionContent();
-        return attributionData;
       case "AWPage:SELECT_THEME":
         await BuiltInThemes.ensureBuiltInThemes();
         return AddonManager.getAddonByID(
diff --git a/browser/components/newtab/lib/ASRouterTargeting.jsm b/browser/components/newtab/lib/ASRouterTargeting.jsm
--- a/browser/components/newtab/lib/ASRouterTargeting.jsm
+++ b/browser/components/newtab/lib/ASRouterTargeting.jsm
@@ -14,7 +14,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 XPCOMUtils.defineLazyModuleGetters(this, {
   ASRouterPreferences: "resource://activity-stream/lib/ASRouterPreferences.jsm",
   AddonManager: "resource://gre/modules/AddonManager.jsm",
-  ClientEnvironment: "resource://normandy/lib/ClientEnvironment.jsm",
   NewTabUtils: "resource://gre/modules/NewTabUtils.jsm",
   ProfileAge: "resource://gre/modules/ProfileAge.jsm",
   ShellService: "resource:///modules/ShellService.jsm",
@@ -589,7 +588,7 @@ const TargetingGetters = {
     );
   },
   get userId() {
-    return ClientEnvironment.userId;
+    return "";
   },
   get profileRestartCount() {
     // Counter starts at 1 when a profile is created, substract 1 so the value
diff --git a/browser/components/newtab/lib/PlacesFeed.jsm b/browser/components/newtab/lib/PlacesFeed.jsm
--- a/browser/components/newtab/lib/PlacesFeed.jsm
+++ b/browser/components/newtab/lib/PlacesFeed.jsm
@@ -22,11 +22,6 @@ ChromeUtils.defineModuleGetter(
 );
 ChromeUtils.defineModuleGetter(
   this,
-  "PartnerLinkAttribution",
-  "resource:///modules/PartnerLinkAttribution.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "PlacesUtils",
   "resource://gre/modules/PlacesUtils.jsm"
 );
@@ -409,23 +404,6 @@ class PlacesFeed {
     }
   }
 
-  /**
-   * Sends an attribution request for Top Sites interactions.
-   * @param {object} data
-   *   Attribution paramters from a Top Site.
-   */
-  makeAttributionRequest(data) {
-    let args = Object.assign(
-      {
-        campaignID: Services.prefs.getStringPref(
-          "browser.partnerlink.campaign.topsites"
-        ),
-      },
-      data
-    );
-    PartnerLinkAttribution.makeRequest(args);
-  }
-
   async fillSearchTopSiteTerm({ _target, data }) {
     const searchEngine = await Services.search.getEngineByAlias(data.label);
     _target.browser.ownerGlobal.gURLBar.search(data.label, {
@@ -597,9 +575,6 @@ class PlacesFeed {
         this.openLink(action);
         break;
       }
-      case at.PARTNER_LINK_ATTRIBUTION:
-        this.makeAttributionRequest(action.data);
-        break;
     }
   }
 }
diff --git a/browser/components/newtab/lib/Spotlight.jsm b/browser/components/newtab/lib/Spotlight.jsm
--- a/browser/components/newtab/lib/Spotlight.jsm
+++ b/browser/components/newtab/lib/Spotlight.jsm
@@ -8,40 +8,12 @@ const { XPCOMUtils } = ChromeUtils.impor
 );
 
 XPCOMUtils.defineLazyModuleGetters(this, {
-  AboutWelcomeTelemetry:
-    "resource://activity-stream/aboutwelcome/lib/AboutWelcomeTelemetry.jsm",
   RemoteImages: "resource://activity-stream/lib/RemoteImages.jsm",
   SpecialMessageActions:
     "resource://messaging-system/lib/SpecialMessageActions.jsm",
 });
 
-XPCOMUtils.defineLazyGetter(
-  this,
-  "AWTelemetry",
-  () => new AboutWelcomeTelemetry()
-);
-
 const Spotlight = {
-  sendUserEventTelemetry(event, message, dispatch) {
-    const message_id =
-      message.template === "multistage" ? message.content.id : message.id;
-    const ping = {
-      message_id,
-      event,
-    };
-    dispatch({
-      type: "SPOTLIGHT_TELEMETRY",
-      data: { action: "spotlight_user_event", ...ping },
-    });
-  },
-
-  defaultDispatch(message) {
-    if (message.type === "SPOTLIGHT_TELEMETRY") {
-      const { message_id, event } = message.data;
-      AWTelemetry.sendTelemetry({ message_id, event });
-    }
-  },
-
   /**
    * Shows spotlight tab or window modal specific to the given browser
    * @param browser             The browser for spotlight display
@@ -49,23 +21,15 @@ const Spotlight = {
    * @param dispatchCFRAction   A function to dispatch resulting actions
    * @return                    boolean value capturing if spotlight was displayed
    */
-  async showSpotlightDialog(browser, message, dispatch = this.defaultDispatch) {
+  async showSpotlightDialog(browser, message) {
     const win = browser.ownerGlobal;
     if (win.gDialogBox.isOpen) {
       return false;
     }
     const spotlight_url = "chrome://browser/content/spotlight.html";
 
-    const dispatchCFRAction =
-      // This also blocks CFR impressions, which is fine for current use cases.
-      message.content?.metrics === "block" ? () => {} : dispatch;
     let params = { primaryBtn: false, secondaryBtn: false };
 
-    // There are two events named `IMPRESSION` the first one refers to telemetry
-    // while the other refers to ASRouter impressions used for the frequency cap
-    this.sendUserEventTelemetry("IMPRESSION", message, dispatchCFRAction);
-    dispatchCFRAction({ type: "IMPRESSION", data: message });
-
     const unload = await RemoteImages.patchMessage(message.content.logo);
 
     if (message.content?.modal === "tab") {
@@ -88,12 +52,10 @@ const Spotlight = {
 
     // If dismissed report telemetry and exit
     if (!params.secondaryBtn && !params.primaryBtn) {
-      this.sendUserEventTelemetry("DISMISS", message, dispatchCFRAction);
       return true;
     }
 
     if (params.secondaryBtn) {
-      this.sendUserEventTelemetry("DISMISS", message, dispatchCFRAction);
       SpecialMessageActions.handleAction(
         message.content.body.secondary.action,
         browser
@@ -101,7 +63,6 @@ const Spotlight = {
     }
 
     if (params.primaryBtn) {
-      this.sendUserEventTelemetry("CLICK", message, dispatchCFRAction);
       SpecialMessageActions.handleAction(
         message.content.body.primary.action,
         browser
diff --git a/browser/components/newtab/lib/TelemetryFeed.jsm b/browser/components/newtab/lib/TelemetryFeed.jsm
--- a/browser/components/newtab/lib/TelemetryFeed.jsm
+++ b/browser/components/newtab/lib/TelemetryFeed.jsm
@@ -29,11 +29,6 @@ ChromeUtils.defineModuleGetter(
 );
 ChromeUtils.defineModuleGetter(
   this,
-  "PingCentre",
-  "resource:///modules/PingCentre.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "UTEventReporting",
   "resource://activity-stream/lib/UTEventReporting.jsm"
 );
@@ -299,16 +294,6 @@ this.TelemetryFeed = class TelemetryFeed
   }
 
   /**
-   * Lazily initialize PingCentre for Activity Stream to send pings
-   */
-  get pingCentre() {
-    Object.defineProperty(this, "pingCentre", {
-      value: new PingCentre({ topic: ACTIVITY_STREAM_ID }),
-    });
-    return this.pingCentre;
-  }
-
-  /**
    * Lazily initialize UTEventReporting to send pings
    */
   get utEvents() {
@@ -798,32 +783,7 @@ this.TelemetryFeed = class TelemetryFeed
     }
   }
 
-  /**
-   * Generates an endpoint for Structured Ingestion telemetry pipeline. Note that
-   * Structured Ingestion requires a different endpoint for each ping. See more
-   * details about endpoint schema at:
-   * https://github.com/mozilla/gcp-ingestion/blob/master/docs/edge.md#postput-request
-   *
-   * @param {String} namespace Namespace of the ping, such as "activity-stream" or "messaging-system".
-   * @param {String} pingType  Type of the ping, such as "impression-stats".
-   * @param {String} version   Endpoint version for this ping type.
-   */
-  _generateStructuredIngestionEndpoint(namespace, pingType, version) {
-    const uuid = Services.uuid.generateUUID().toString();
-    // Structured Ingestion does not support the UUID generated by Services.uuid,
-    // because it contains leading and trailing braces. Need to trim them first.
-    const docID = uuid.slice(1, -1);
-    const extension = `${namespace}/${pingType}/${version}/${docID}`;
-    return `${this.structuredIngestionEndpointBase}/${extension}`;
-  }
-
   sendStructuredIngestionEvent(eventObject, namespace, pingType, version) {
-    if (this.telemetryEnabled) {
-      this.pingCentre.sendStructuredIngestionPing(
-        eventObject,
-        this._generateStructuredIngestionEndpoint(namespace, pingType, version)
-      );
-    }
   }
 
   handleImpressionStats(action) {
@@ -1160,9 +1120,6 @@ this.TelemetryFeed = class TelemetryFeed
     }
 
     // Only uninit if the getter has initialized it
-    if (Object.prototype.hasOwnProperty.call(this, "pingCentre")) {
-      this.pingCentre.uninit();
-    }
     if (Object.prototype.hasOwnProperty.call(this, "utEvents")) {
       this.utEvents.uninit();
     }
diff --git a/browser/components/pocket/content/pktTelemetry.jsm b/browser/components/pocket/content/pktTelemetry.jsm
--- a/browser/components/pocket/content/pktTelemetry.jsm
+++ b/browser/components/pocket/content/pktTelemetry.jsm
@@ -12,11 +12,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 ChromeUtils.defineModuleGetter(
   this,
-  "PingCentre",
-  "resource:///modules/PingCentre.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "pktApi",
   "chrome://pocket/content/pktApi.jsm"
 );
@@ -33,10 +28,6 @@ const STRUCTURED_INGESTION_ENDPOINT_PREF
 const POCKET_TELEMETRY_TOPIC = "pocket";
 const PREF_IMPRESSION_ID = "browser.newtabpage.activity-stream.impressionId";
 
-XPCOMUtils.defineLazyGetter(this, "pingCentre", () => {
-  return new PingCentre({ topic: POCKET_TELEMETRY_TOPIC });
-});
-
 var pktTelemetry = {
   get structuredIngestionEndpointBase() {
     if (!this._structuredIngestionEndpointBase) {
@@ -92,34 +83,11 @@ var pktTelemetry = {
     );
   },
 
-  _generateUUID() {
-    return String(Services.uuid.generateUUID());
-  },
-
-  /**
-   * Generates an endpoint for Structured Ingestion telemetry pipeline. Note that
-   * Structured Ingestion requires a different endpoint for each ping. See more
-   * details about endpoint schema at:
-   * https://github.com/mozilla/gcp-ingestion/blob/master/docs/edge.md#postput-request
-   */
-  _generateStructuredIngestionEndpoint() {
-    const uuid = this._generateUUID();
-    // Structured Ingestion does not support the UUID generated by gUUIDGenerator,
-    // because it contains leading and trailing braces. Need to trim them first.
-    const docID = uuid.slice(1, -1);
-    const extension = `${STRUCTURED_INGESTION_NAMESPACE_AS}/pocket-button/1/${docID}`;
-    return `${this.structuredIngestionEndpointBase}/${extension}`;
-  },
-
   /**
    * sendStructuredIngestionEvent - Sent a ping for an impression stats
    *
    * @param {ob} eventObject The data object to be included in the ping.
    */
   sendStructuredIngestionEvent(eventObject) {
-    pingCentre.sendStructuredIngestionPing(
-      eventObject,
-      this._generateStructuredIngestionEndpoint()
-    );
   },
 };
diff --git a/browser/components/preferences/preferences.js b/browser/components/preferences/preferences.js
--- a/browser/components/preferences/preferences.js
+++ b/browser/components/preferences/preferences.js
@@ -60,7 +60,6 @@ XPCOMUtils.defineLazyServiceGetters(this
 });
 
 XPCOMUtils.defineLazyModuleGetters(this, {
-  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
   BrowserUtils: "resource://gre/modules/BrowserUtils.jsm",
   ContextualIdentityService:
     "resource://gre/modules/ContextualIdentityService.jsm",
@@ -257,10 +256,6 @@ function init_all() {
       }
       let mainWindow = window.browsingContext.topChromeWindow;
       mainWindow.BrowserOpenAddonsMgr();
-      AMTelemetry.recordLinkEvent({
-        object: "aboutPreferences",
-        value: "about:addons",
-      });
     });
 
     document.dispatchEvent(
diff --git a/browser/components/search/content/autocomplete-popup.js b/browser/components/search/content/autocomplete-popup.js
--- a/browser/components/search/content/autocomplete-popup.js
+++ b/browser/components/search/content/autocomplete-popup.js
@@ -183,13 +183,6 @@
         return;
       }
 
-      // Check for middle-click or modified clicks on the search bar
-      BrowserSearchTelemetry.recordSearchSuggestionSelectionMethod(
-        aEvent,
-        "searchbar",
-        this.selectedIndex
-      );
-
       // Handle search bar popup clicks
       let search = this.input.controller.getValueAt(this.selectedIndex);
 
diff --git a/browser/components/search/content/searchbar.js b/browser/components/search/content/searchbar.js
--- a/browser/components/search/content/searchbar.js
+++ b/browser/components/search/content/searchbar.js
@@ -348,12 +348,6 @@
       let selectedIndex = this.telemetrySelectedIndex;
       let isOneOff = false;
 
-      BrowserSearchTelemetry.recordSearchSuggestionSelectionMethod(
-        aEvent,
-        "searchbar",
-        selectedIndex
-      );
-
       if (selectedIndex == -1) {
         isOneOff = this.textbox.popup.oneOffButtons.eventTargetIsAOneOff(
           aEvent
@@ -416,12 +410,6 @@
 
       this.telemetrySelectedIndex = -1;
 
-      BrowserSearchTelemetry.recordSearch(
-        gBrowser.selectedBrowser,
-        engine,
-        "searchbar",
-        details
-      );
       // null parameter below specifies HTML response for search
       let params = {
         postData: submission.postData,
diff --git a/browser/components/search/moz.build b/browser/components/search/moz.build
--- a/browser/components/search/moz.build
+++ b/browser/components/search/moz.build
@@ -5,9 +5,7 @@
 # file, You can obtain one at http://mozilla.org/MPL/2.0/.
 
 EXTRA_JS_MODULES += [
-    "BrowserSearchTelemetry.jsm",
     "SearchOneOffs.jsm",
-    "SearchSERPTelemetry.jsm",
     "SearchUIUtils.jsm",
 ]
 
diff --git a/browser/components/sessionstore/SessionStore.jsm b/browser/components/sessionstore/SessionStore.jsm
--- a/browser/components/sessionstore/SessionStore.jsm
+++ b/browser/components/sessionstore/SessionStore.jsm
@@ -221,9 +221,6 @@ const { PrivateBrowsingUtils } = ChromeU
   "resource://gre/modules/PrivateBrowsingUtils.jsm"
 );
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
-const { TelemetryTimestamps } = ChromeUtils.import(
-  "resource://gre/modules/TelemetryTimestamps.jsm"
-);
 const { XPCOMUtils } = ChromeUtils.import(
   "resource://gre/modules/XPCOMUtils.jsm"
 );
@@ -802,7 +799,6 @@ var SessionStoreInternal = {
       throw new Error("SessionStore.init() must only be called once!");
     }
 
-    TelemetryTimestamps.add("sessionRestoreInitialized");
     OBSERVING.forEach(function(aTopic) {
       Services.obs.addObserver(this, aTopic, true);
     }, this);
@@ -1596,7 +1592,6 @@ var SessionStoreInternal = {
           );
           this._deferredAllWindowsRestored.resolve();
         } else {
-          TelemetryTimestamps.add("sessionRestoreRestoring");
           this._restoreCount = aInitialState.windows
             ? aInitialState.windows.length
             : 0;
diff --git a/browser/components/uitour/UITour.jsm b/browser/components/uitour/UITour.jsm
--- a/browser/components/uitour/UITour.jsm
+++ b/browser/components/uitour/UITour.jsm
@@ -15,7 +15,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   AboutReaderParent: "resource:///actors/AboutReaderParent.jsm",
   AddonManager: "resource://gre/modules/AddonManager.jsm",
   AppConstants: "resource://gre/modules/AppConstants.jsm",
-  BrowserUsageTelemetry: "resource:///modules/BrowserUsageTelemetry.jsm",
   BuiltInThemes: "resource:///modules/BuiltInThemes.jsm",
   CustomizableUI: "resource:///modules/CustomizableUI.jsm",
   fxAccounts: "resource://gre/modules/FxAccounts.jsm",
@@ -1889,11 +1888,6 @@ var UITour = {
       aTarget.widgetName,
       CustomizableUI.AREA_NAVBAR
     );
-    BrowserUsageTelemetry.recordWidgetChange(
-      aTarget.widgetName,
-      CustomizableUI.AREA_NAVBAR,
-      "uitour"
-    );
     this.sendPageCallback(aBrowser, aCallbackID);
   },
 
diff --git a/browser/components/urlbar/UrlbarController.jsm b/browser/components/urlbar/UrlbarController.jsm
--- a/browser/components/urlbar/UrlbarController.jsm
+++ b/browser/components/urlbar/UrlbarController.jsm
@@ -12,7 +12,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 const { Services } = ChromeUtils.import("resource://gre/modules/Services.jsm");
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
-  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
   FormHistory: "resource://gre/modules/FormHistory.jsm",
   PlacesUtils: "resource://gre/modules/PlacesUtils.jsm",
   UrlbarPrefs: "resource:///modules/UrlbarPrefs.jsm",
@@ -89,11 +88,6 @@ class UrlbarController {
 
     this._listeners = new Set();
     this._userSelectionBehavior = "none";
-
-    this.engagementEvent = new TelemetryEvent(
-      this,
-      options.eventTelemetryCategory
-    );
   }
 
   get NOTIFICATIONS() {
@@ -507,86 +501,6 @@ class UrlbarController {
   }
 
   /**
-   * Records details of the selected result in telemetry. We only record the
-   * selection behavior, type and index.
-   *
-   * @param {Event} event
-   *   The event which triggered the result to be selected.
-   * @param {UrlbarResult} result
-   *   The selected result.
-   */
-  recordSelectedResult(event, result) {
-    let resultIndex = result ? result.rowIndex : -1;
-    let selectedResult = -1;
-    if (resultIndex >= 0) {
-      // Except for the history popup, the urlbar always has a selection.  The
-      // first result at index 0 is the "heuristic" result that indicates what
-      // will happen when you press the Enter key.  Treat it as no selection.
-      selectedResult = resultIndex > 0 || !result.heuristic ? resultIndex : -1;
-    }
-    BrowserSearchTelemetry.recordSearchSuggestionSelectionMethod(
-      event,
-      "urlbar",
-      selectedResult,
-      this._userSelectionBehavior
-    );
-
-    if (!result) {
-      return;
-    }
-
-    // Do not modify existing telemetry types.  To add a new type:
-    //
-    // * Set telemetryType appropriately. Since telemetryType is used as the
-    //   probe name, it must be alphanumeric with optional underscores.
-    // * Add a new keyed scalar probe into the urlbar.picked category for the
-    //   newly added telemetryType.
-    // * Add a test named browser_UsageTelemetry_urlbar_newType.js to
-    //   browser/modules/test/browser.
-    // * Add the telemetryType to UrlbarUtils.SELECTED_RESULT_TYPES, which is
-    //   used by the histograms below. These histograms are deprecated, but the
-    //   code below logs an error if telemetryType is not in
-    //   SELECTED_RESULT_TYPES.
-    //
-    // The "topsite" type overrides the other ones, because it starts from a
-    // unique user interaction, that we want to count apart. We do this here
-    // rather than in telemetryTypeFromResult because other consumers, like
-    // events telemetry, are reporting this information separately.
-    let telemetryType =
-      result.providerName == "UrlbarProviderTopSites"
-        ? "topsite"
-        : UrlbarUtils.telemetryTypeFromResult(result);
-    Services.telemetry.keyedScalarAdd(
-      `urlbar.picked.${telemetryType}`,
-      resultIndex,
-      1
-    );
-    if (this.input.searchMode && !this.input.searchMode.isPreview) {
-      Services.telemetry.keyedScalarAdd(
-        `urlbar.picked.searchmode.${this.input.searchMode.entry}`,
-        resultIndex,
-        1
-      );
-    }
-
-    // These histograms should be removed after a deprecation time where we'll
-    // confirm goodness of the new scalar above.
-    if (!(telemetryType in UrlbarUtils.SELECTED_RESULT_TYPES)) {
-      Cu.reportError(`Unsupported telemetry type ${telemetryType}`);
-      return;
-    }
-    Services.telemetry
-      .getHistogramById("FX_URLBAR_SELECTED_RESULT_INDEX")
-      .add(resultIndex);
-    Services.telemetry
-      .getHistogramById("FX_URLBAR_SELECTED_RESULT_TYPE_2")
-      .add(UrlbarUtils.SELECTED_RESULT_TYPES[telemetryType]);
-    Services.telemetry
-      .getKeyedHistogramById("FX_URLBAR_SELECTED_RESULT_INDEX_BY_TYPE_2")
-      .add(telemetryType, resultIndex);
-  }
-
-  /**
    * Handles deletion of results from the last query context and the view. There
    * are two kinds of results that can be deleted:
    *
@@ -706,265 +620,3 @@ class UrlbarController {
     }
   }
 }
-
-/**
- * Tracks and records telemetry events for the given category, if provided,
- * otherwise it's a no-op.
- * It is currently designed around the "urlbar" category, even if it can
- * potentially be extended to other categories.
- * To record an event, invoke start() with a starting event, then either
- * invoke record() with a final event, or discard() to drop the recording.
- * @see Events.yaml
- */
-class TelemetryEvent {
-  constructor(controller, category) {
-    this._controller = controller;
-    this._category = category;
-    this._isPrivate = controller.input.isPrivate;
-  }
-
-  /**
-   * Start measuring the elapsed time from a user-generated event.
-   * After this has been invoked, any subsequent calls to start() are ignored,
-   * until either record() or discard() are invoked. Thus, it is safe to keep
-   * invoking this on every input event as the user is typing, for example.
-   * @param {event} event A DOM event.
-   * @param {string} [searchString] Pass a search string related to the event if
-   *        you have one.  The event by itself sometimes isn't enough to
-   *        determine the telemetry details we should record.
-   * @note This should never throw, or it may break the urlbar.
-   * @see the in-tree urlbar telemetry documentation.
-   */
-  start(event, searchString = null) {
-    // In case of a "returned" interaction ongoing, the user may either
-    // continue the search, or restart with a new search string. In that case
-    // we want to change the interaction type to "restarted".
-    // Detecting all the possible ways of clearing the input would be tricky,
-    // thus this makes a guess by just checking the first char matches; even if
-    // the user backspaces a part of the string, we still count that as a
-    // "returned" interaction.
-    if (
-      this._startEventInfo &&
-      this._startEventInfo.interactionType == "returned" &&
-      (!searchString || this._startEventInfo.searchString[0] != searchString[0])
-    ) {
-      this._startEventInfo.interactionType = "restarted";
-    }
-
-    // start is invoked on a user-generated event, but we only count the first
-    // one.  Once an engagement or abandoment happens, we clear _startEventInfo.
-    if (!this._category || this._startEventInfo) {
-      return;
-    }
-    if (!event) {
-      Cu.reportError("Must always provide an event");
-      return;
-    }
-    const validEvents = [
-      "click",
-      "command",
-      "drop",
-      "input",
-      "keydown",
-      "mousedown",
-      "tabswitch",
-      "focus",
-    ];
-    if (!validEvents.includes(event.type)) {
-      Cu.reportError("Can't start recording from event type: " + event.type);
-      return;
-    }
-
-    let interactionType = "topsites";
-    if (event.interactionType) {
-      interactionType = event.interactionType;
-    } else if (event.type == "input") {
-      interactionType = UrlbarUtils.isPasteEvent(event) ? "pasted" : "typed";
-    } else if (event.type == "drop") {
-      interactionType = "dropped";
-    } else if (searchString) {
-      interactionType = "typed";
-    }
-
-    this._startEventInfo = {
-      timeStamp: event.timeStamp || Cu.now(),
-      interactionType,
-      searchString,
-    };
-
-    let { queryContext } = this._controller._lastQueryContextWrapper || {};
-    this._controller.manager.notifyEngagementChange(
-      this._isPrivate,
-      "start",
-      queryContext
-    );
-  }
-
-  /**
-   * Record an engagement telemetry event.
-   * When the user picks a result from a search through the mouse or keyboard,
-   * an engagement event is recorded. If instead the user abandons a search, by
-   * blurring the input field, an abandonment event is recorded.
-   * @param {event} [event] A DOM event.
-   * @param {object} details An object describing action details.
-   * @param {string} details.searchString The user's search string. Note that
-   *        this string is not sent with telemetry data. It is only used
-   *        locally to discern other data, such as the number of characters and
-   *        words in the string.
-   * @param {string} details.selIndex Index of the selected result, undefined
-   *        for "blur".
-   * @param {string} details.selType type of the selected element, undefined
-   *        for "blur". One of "unknown", "autofill", "visiturl", "bookmark",
-   *        "history", "keyword", "searchengine", "searchsuggestion",
-   *        "switchtab", "remotetab", "extension", "oneoff".
-   * @param {string} details.provider The name of the provider for the selected
-   *        result.
-   * @note event can be null, that usually happens for paste&go or drop&go.
-   *       If there's no _startEventInfo this is a no-op.
-   */
-  record(event, details) {
-    // This should never throw, or it may break the urlbar.
-    try {
-      this._internalRecord(event, details);
-    } catch (ex) {
-      Cu.reportError("Could not record event: " + ex);
-    } finally {
-      this._startEventInfo = null;
-      this._discarded = false;
-    }
-  }
-
-  _internalRecord(event, details) {
-    if (!this._category || !this._startEventInfo) {
-      if (this._discarded && this._category) {
-        let { queryContext } = this._controller._lastQueryContextWrapper || {};
-        this._controller.manager.notifyEngagementChange(
-          this._isPrivate,
-          "discard",
-          queryContext
-        );
-      }
-      return;
-    }
-    if (
-      !event &&
-      this._startEventInfo.interactionType != "pasted" &&
-      this._startEventInfo.interactionType != "dropped"
-    ) {
-      // If no event is passed, we must be executing either paste&go or drop&go.
-      throw new Error("Event must be defined, unless input was pasted/dropped");
-    }
-    if (!details) {
-      throw new Error("Invalid event details: " + details);
-    }
-
-    let endTime = (event && event.timeStamp) || Cu.now();
-    let startTime = this._startEventInfo.timeStamp || endTime;
-    // Synthesized events in tests may have a bogus timeStamp, causing a
-    // subtraction between monotonic and non-monotonic timestamps; that's why
-    // abs is necessary here. It should only happen in tests, anyway.
-    let elapsed = Math.abs(Math.round(endTime - startTime));
-
-    let action;
-    if (!event) {
-      action =
-        this._startEventInfo.interactionType == "dropped"
-          ? "drop_go"
-          : "paste_go";
-    } else if (event.type == "blur") {
-      action = "blur";
-    } else {
-      action = MouseEvent.isInstance(event) ? "click" : "enter";
-    }
-    let method = action == "blur" ? "abandonment" : "engagement";
-    let value = this._startEventInfo.interactionType;
-
-    // Rather than listening to the pref, just update status when we record an
-    // event, if the pref changed from the last time.
-    let recordingEnabled = UrlbarPrefs.get("eventTelemetry.enabled");
-    if (this._eventRecordingEnabled != recordingEnabled) {
-      this._eventRecordingEnabled = recordingEnabled;
-      Services.telemetry.setEventRecordingEnabled("urlbar", recordingEnabled);
-    }
-
-    // numWords is not a perfect measurement, since it will return an incorrect
-    // value for languages that do not use spaces or URLs containing spaces in
-    // its query parameters, for example.
-    let extra = {
-      elapsed: elapsed.toString(),
-      numChars: details.searchString.length.toString(),
-      numWords: details.searchString
-        .trim()
-        .split(UrlbarTokenizer.REGEXP_SPACES)
-        .filter(t => t)
-        .length.toString(),
-    };
-    if (method == "engagement") {
-      extra.selIndex = details.selIndex.toString();
-      extra.selType = details.selType;
-      extra.provider = details.provider || "";
-    }
-
-    // We invoke recordEvent regardless, if recording is disabled this won't
-    // report the events remotely, but will count it in the event_counts scalar.
-    Services.telemetry.recordEvent(
-      this._category,
-      method,
-      action,
-      value,
-      extra
-    );
-
-    Services.telemetry.scalarAdd(
-      method == "engagement"
-        ? TELEMETRY_SCALAR_ENGAGEMENT
-        : TELEMETRY_SCALAR_ABANDONMENT,
-      1
-    );
-
-    let { queryContext } = this._controller._lastQueryContextWrapper || {};
-    this._controller.manager.notifyEngagementChange(
-      this._isPrivate,
-      method,
-      queryContext,
-      details
-    );
-  }
-
-  /**
-   * Resets the currently tracked user-generated event that was registered via
-   * start(), so it won't be recorded.  If there's no tracked event, this is a
-   * no-op.
-   */
-  discard() {
-    if (this._startEventInfo) {
-      this._startEventInfo = null;
-      this._discarded = true;
-    }
-  }
-
-  /**
-   * Extracts a telemetry type from an element for event telemetry.
-   * @param {Element} element The element to analyze.
-   * @returns {string} a string type for the telemetry event.
-   */
-  typeFromElement(element) {
-    if (!element) {
-      return "none";
-    }
-    let row = element.closest(".urlbarView-row");
-    if (row.result && row.result.providerName != "UrlbarProviderTopSites") {
-      // Element handlers go here.
-      if (element.classList.contains("urlbarView-button-help")) {
-        return row.result.type == UrlbarUtils.RESULT_TYPE.TIP
-          ? "tiphelp"
-          : "help";
-      }
-      if (element.classList.contains("urlbarView-button-block")) {
-        return "block";
-      }
-    }
-    // Now handle the result.
-    return UrlbarUtils.telemetryTypeFromResult(row.result);
-  }
-}
diff --git a/browser/components/urlbar/UrlbarInput.jsm b/browser/components/urlbar/UrlbarInput.jsm
--- a/browser/components/urlbar/UrlbarInput.jsm
+++ b/browser/components/urlbar/UrlbarInput.jsm
@@ -12,16 +12,12 @@ const { XPCOMUtils } = ChromeUtils.impor
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
-  BrowserSearchTelemetry: "resource:///modules/BrowserSearchTelemetry.jsm",
   BrowserUIUtils: "resource:///modules/BrowserUIUtils.jsm",
-  CONTEXTUAL_SERVICES_PING_TYPES:
-    "resource:///modules/PartnerLinkAttribution.jsm",
   ExtensionSearchHandler: "resource://gre/modules/ExtensionSearchHandler.jsm",
   ObjectUtils: "resource://gre/modules/ObjectUtils.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   PromiseUtils: "resource://gre/modules/PromiseUtils.jsm",
   ReaderMode: "resource://gre/modules/ReaderMode.jsm",
-  PartnerLinkAttribution: "resource:///modules/PartnerLinkAttribution.jsm",
   SearchUIUtils: "resource:///modules/SearchUIUtils.jsm",
   SearchUtils: "resource://gre/modules/SearchUtils.jsm",
   Services: "resource://gre/modules/Services.jsm",
@@ -571,11 +567,7 @@ class UrlbarInput {
     }
 
     let url;
-    let selType = this.controller.engagementEvent.typeFromElement(element);
-    let typedValue = this.value;
     if (oneOffParams?.engine) {
-      selType = "oneoff";
-      typedValue = this._lastSearchString;
       // If there's a selected one-off button then load a search using
       // the button's engine.
       result = this._resultForCurrentValue;
@@ -586,7 +578,6 @@ class UrlbarInput {
         oneOffParams.engine,
         searchString
       );
-      this._recordSearch(oneOffParams.engine, event, { url });
 
       UrlbarUtils.addToFormHistory(
         this,
@@ -615,9 +606,6 @@ class UrlbarInput {
       return;
     }
 
-    let selectedResult = result || this.view.selectedResult;
-    this.controller.recordSelectedResult(event, selectedResult);
-
     let where = oneOffParams?.openWhere || this._whereToOpen(event);
     if (selectedPrivateResult) {
       where = "window";
@@ -626,13 +614,6 @@ class UrlbarInput {
     openParams.allowInheritPrincipal = false;
     url = this._maybeCanonizeURL(event, url) || url.trim();
 
-    this.controller.engagementEvent.record(event, {
-      searchString: typedValue,
-      selIndex: this.view.selectedRowIndex,
-      selType,
-      provider: selectedResult?.providerName,
-    });
-
     let isValidUrl = false;
     try {
       new URL(url);
@@ -811,15 +792,7 @@ class UrlbarInput {
       this.view.close({ elementPicked: true });
     }
 
-    this.controller.recordSelectedResult(event, result);
-
     if (isCanonized) {
-      this.controller.engagementEvent.record(event, {
-        searchString: this._lastSearchString,
-        selIndex,
-        selType: "canonized",
-        provider: result.providerName,
-      });
       this._loadURL(this.value, event, where, openParams, browser);
       return;
     }
@@ -880,12 +853,6 @@ class UrlbarInput {
 
         // We cache the search string because switching tab may clear it.
         let searchString = this._lastSearchString;
-        this.controller.engagementEvent.record(event, {
-          searchString,
-          selIndex,
-          selType: "tabswitch",
-          provider: result.providerName,
-        });
 
         let switched = this.window.switchToTabHavingURI(
           Services.io.newURI(url),
@@ -948,14 +915,7 @@ class UrlbarInput {
           openParams.private = true;
         }
 
-        const actionDetails = {
-          isSuggestion: !!result.payload.suggestion,
-          isFormHistory: result.source == UrlbarUtils.RESULT_SOURCE.HISTORY,
-          alias: result.payload.keyword,
-          url,
-        };
         const engine = Services.search.getEngineByName(result.payload.engine);
-        this._recordSearch(engine, event, actionDetails);
 
         if (!result.payload.inPrivateWindow) {
           UrlbarUtils.addToFormHistory(
@@ -967,26 +927,15 @@ class UrlbarInput {
         break;
       }
       case UrlbarUtils.RESULT_TYPE.TIP: {
-        let scalarName;
         if (element.classList.contains("urlbarView-button-help")) {
           url = result.payload.helpUrl;
           if (!url) {
             Cu.reportError("helpUrl not specified");
             return;
           }
-          scalarName = `${result.payload.type}-help`;
-        } else {
-          scalarName = `${result.payload.type}-picked`;
         }
-        Services.telemetry.keyedScalarAdd("urlbar.tips", scalarName, 1);
         if (!url) {
           this.handleRevert();
-          this.controller.engagementEvent.record(event, {
-            searchString: this._lastSearchString,
-            selIndex,
-            selType: "tip",
-            provider: result.providerName,
-          });
           let provider = UrlbarProvidersManager.getProvider(
             result.providerName
           );
@@ -1016,24 +965,11 @@ class UrlbarInput {
 
         // If we won't be navigating, this is the end of the engagement.
         if (!url || !result.payload.shouldNavigate) {
-          this.controller.engagementEvent.record(event, {
-            selIndex,
-            searchString: this._lastSearchString,
-            selType: this.controller.engagementEvent.typeFromElement(element),
-            provider: result.providerName,
-          });
           return;
         }
         break;
       }
       case UrlbarUtils.RESULT_TYPE.OMNIBOX: {
-        this.controller.engagementEvent.record(event, {
-          searchString: this._lastSearchString,
-          selIndex,
-          selType: "extension",
-          provider: result.providerName,
-        });
-
         // The urlbar needs to revert to the loaded url when a command is
         // handled by the extension.
         this.handleRevert();
@@ -1072,42 +1008,6 @@ class UrlbarInput {
       }
     }
 
-    this.controller.engagementEvent.record(event, {
-      searchString: this._lastSearchString,
-      selIndex,
-      selType: this.controller.engagementEvent.typeFromElement(element),
-      provider: result.providerName,
-    });
-
-    if (result.payload.sendAttributionRequest) {
-      PartnerLinkAttribution.makeRequest({
-        targetURL: result.payload.url,
-        source: "urlbar",
-        campaignID: Services.prefs.getStringPref(
-          "browser.partnerlink.campaign.topsites"
-        ),
-      });
-      if (!this.isPrivate && result.providerName === "UrlbarProviderTopSites") {
-        // The position is 1-based for telemetry
-        const position = selIndex + 1;
-        Services.telemetry.keyedScalarAdd(
-          SCALAR_CATEGORY_TOPSITES,
-          `urlbar_${position}`,
-          1
-        );
-        PartnerLinkAttribution.sendContextualServicesPing(
-          {
-            position,
-            source: "urlbar",
-            tile_id: result.payload.sponsoredTileId || -1,
-            reporting_url: result.payload.sponsoredClickUrl,
-            advertiser: result.payload.title.toLocaleLowerCase(),
-          },
-          CONTEXTUAL_SERVICES_PING_TYPES.TOPSITES_SELECTION
-        );
-      }
-    }
-
     this._loadURL(
       url,
       event,
@@ -1374,10 +1274,6 @@ class UrlbarInput {
       throw new Error("The current value doesn't start with the search string");
     }
 
-    if (event) {
-      this.controller.engagementEvent.start(event, searchString);
-    }
-
     if (this._suppressStartQuery) {
       return;
     }
@@ -1651,13 +1547,6 @@ class UrlbarInput {
         // when switching back to the current tab and across sessions.
         this.window.gBrowser.userTypedValue = this.untrimmedValue;
         this.valueIsTyped = true;
-        if (!searchMode.isPreview && !areSearchModesSame) {
-          try {
-            BrowserSearchTelemetry.recordSearchMode(searchMode);
-          } catch (ex) {
-            Cu.reportError(ex);
-          }
-        }
       }
     }
   }
@@ -2301,48 +2190,6 @@ class UrlbarInput {
   }
 
   /**
-   * Get the url to load for the search query and records in telemetry that it
-   * is being loaded.
-   *
-   * @param {nsISearchEngine} engine
-   *   The engine to generate the query for.
-   * @param {Event} event
-   *   The event that triggered this query.
-   * @param {object} searchActionDetails
-   *   The details associated with this search query.
-   * @param {boolean} searchActionDetails.isSuggestion
-   *   True if this query was initiated from a suggestion from the search engine.
-   * @param {boolean} searchActionDetails.alias
-   *   True if this query was initiated via a search alias.
-   * @param {boolean} searchActionDetails.isFormHistory
-   *   True if this query was initiated from a form history result.
-   * @param {string} searchActionDetails.url
-   *   The url this query was triggered with.
-   */
-  _recordSearch(engine, event, searchActionDetails = {}) {
-    const isOneOff = this.view.oneOffSearchButtons.eventTargetIsAOneOff(event);
-
-    let source = "urlbar";
-    if (this._isHandoffSession) {
-      source = "urlbar-handoff";
-    } else if (this.searchMode && !isOneOff) {
-      // Without checking !isOneOff, we might record the string
-      // oneoff_urlbar-searchmode in the SEARCH_COUNTS probe (in addition to
-      // oneoff_urlbar and oneoff_searchbar). The extra information is not
-      // necessary; the intent is the same regardless of whether the user is
-      // in search mode when they do a key-modified click/enter on a one-off.
-      source = "urlbar-searchmode";
-    }
-
-    BrowserSearchTelemetry.recordSearch(
-      this.window.gBrowser.selectedBrowser,
-      engine,
-      source,
-      { ...searchActionDetails, isOneOff }
-    );
-  }
-
-  /**
    * Shortens the given value, usually by removing http:// and trailing slashes.
    *
    * @param {string} val
@@ -2825,33 +2672,10 @@ class UrlbarInput {
 
   // Event handlers below.
 
-  _on_command(event) {
-    // Something is executing a command, likely causing a focus change. This
-    // should not be recorded as an abandonment. If the user is entering search
-    // mode from a one-off, then they are in the same engagement and we should
-    // not discard.
-    if (
-      !event.target.classList.contains("searchbar-engine-one-off-item") ||
-      this.searchMode?.entry != "oneoff"
-    ) {
-      this.controller.engagementEvent.discard();
-    }
-  }
-
   _on_blur(event) {
     this.focusedViaMousedown = false;
     this._isHandoffSession = false;
 
-    // We cannot count every blur events after a missed engagement as abandoment
-    // because the user may have clicked on some view element that executes
-    // a command causing a focus change. For example opening preferences from
-    // the oneoff settings button.
-    // For now we detect that case by discarding the event on command, but we
-    // may want to figure out a more robust way to detect abandonment.
-    this.controller.engagementEvent.record(event, {
-      searchString: this._lastSearchString,
-    });
-
     this.removeAttribute("focused");
 
     if (this._autofillPlaceholder && this.window.gBrowser.userTypedValue) {
@@ -3445,9 +3269,6 @@ class UrlbarInput {
       this.value = droppedURL;
       this.setPageProxyState("invalid");
       this.focus();
-      // To simplify tracking of events, register an initial event for event
-      // telemetry, to replace the missing input event.
-      this.controller.engagementEvent.start(event);
       this.handleNavigation({ triggeringPrincipal: principal });
       // For safety reasons, in the drop case we don't want to immediately show
       // the the dropped value, instead we want to keep showing the current page
diff --git a/browser/components/urlbar/UrlbarSearchOneOffs.jsm b/browser/components/urlbar/UrlbarSearchOneOffs.jsm
--- a/browser/components/urlbar/UrlbarSearchOneOffs.jsm
+++ b/browser/components/urlbar/UrlbarSearchOneOffs.jsm
@@ -185,7 +185,6 @@ class UrlbarSearchOneOffs extends Search
         "searchbar-engine-one-off-add-engine"
       )
     ) {
-      this.input.controller.engagementEvent.discard();
       this.selectedButton.doCommand();
       this.selectedButton = null;
       return;
diff --git a/browser/components/urlbar/UrlbarView.jsm b/browser/components/urlbar/UrlbarView.jsm
--- a/browser/components/urlbar/UrlbarView.jsm
+++ b/browser/components/urlbar/UrlbarView.jsm
@@ -466,15 +466,6 @@ class UrlbarView {
     this.input.removeAttribute("open");
     this.input.endLayoutExtend();
 
-    // Search Tips can open the view without the Urlbar being focused. If the
-    // tip is ignored (e.g. the page content is clicked or the window loses
-    // focus) we should discard the telemetry event created when the view was
-    // opened.
-    if (!this.input.focused && !elementPicked) {
-      this.controller.engagementEvent.discard();
-      this.controller.engagementEvent.record(null, {});
-    }
-
     this.window.removeEventListener("resize", this);
     this.window.removeEventListener("blur", this);
 
@@ -550,7 +541,6 @@ class UrlbarView {
       }
     }
 
-    this.controller.engagementEvent.discard();
     queryOptions.searchString = this.input.value;
     queryOptions.autofillIgnoresSelection = true;
     queryOptions.event.interactionType = "returned";
diff --git a/browser/extensions/report-site-issue/experimentalAPIs/browserInfo.js b/browser/extensions/report-site-issue/experimentalAPIs/browserInfo.js
--- a/browser/extensions/report-site-issue/experimentalAPIs/browserInfo.js
+++ b/browser/extensions/report-site-issue/experimentalAPIs/browserInfo.js
@@ -7,10 +7,7 @@
 /* global AppConstants, ExtensionAPI, Services */
 
 function isTelemetryEnabled() {
-  return Services.prefs.getBoolPref(
-    "datareporting.healthreport.uploadEnabled",
-    false
-  );
+  return false;
 }
 
 function isWebRenderEnabled() {
diff --git a/browser/fxr/content/prefs.js b/browser/fxr/content/prefs.js
--- a/browser/fxr/content/prefs.js
+++ b/browser/fxr/content/prefs.js
@@ -80,9 +80,7 @@ function initSubmitHealthReport() {
   } else {
     checkbox.addEventListener("change", updateSubmitHealthReport);
 
-    checkbox.checked =
-      Services.prefs.getBoolPref(PREF_UPLOAD_ENABLED) &&
-      AppConstants.MOZ_TELEMETRY_REPORTING;
+    checkbox.checked = false;
   }
 }
 
diff --git a/browser/modules/Discovery.jsm b/browser/modules/Discovery.jsm
--- a/browser/modules/Discovery.jsm
+++ b/browser/modules/Discovery.jsm
@@ -22,20 +22,16 @@ ChromeUtils.defineModuleGetter(
 );
 
 const RECOMMENDATION_ENABLED = "browser.discovery.enabled";
-const TELEMETRY_ENABLED = "datareporting.healthreport.uploadEnabled";
 const TAAR_COOKIE_NAME = "taarId";
 
 const Discovery = {
   set enabled(val) {
     val = !!val;
-    if (val && !gTelemetryEnabled) {
-      throw Error("unable to turn on recommendations");
-    }
     Services.prefs.setBoolPref(RECOMMENDATION_ENABLED, val);
   },
 
   get enabled() {
-    return gTelemetryEnabled && gRecommendationEnabled;
+    return false;
   },
 
   reset() {
@@ -49,20 +45,6 @@ const Discovery = {
 
 XPCOMUtils.defineLazyPreferenceGetter(
   this,
-  "gRecommendationEnabled",
-  RECOMMENDATION_ENABLED,
-  false,
-  Discovery.update
-);
-XPCOMUtils.defineLazyPreferenceGetter(
-  this,
-  "gTelemetryEnabled",
-  TELEMETRY_ENABLED,
-  false,
-  Discovery.update
-);
-XPCOMUtils.defineLazyPreferenceGetter(
-  this,
   "gCachedClientID",
   "toolkit.telemetry.cachedClientID",
   "",
diff --git a/browser/modules/ExtensionsUI.jsm b/browser/modules/ExtensionsUI.jsm
--- a/browser/modules/ExtensionsUI.jsm
+++ b/browser/modules/ExtensionsUI.jsm
@@ -15,7 +15,6 @@ const { EventEmitter } = ChromeUtils.imp
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManager: "resource://gre/modules/AddonManager.jsm",
   AddonManagerPrivate: "resource://gre/modules/AddonManager.jsm",
-  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
   AppMenuNotifications: "resource://gre/modules/AppMenuNotifications.jsm",
   ExtensionData: "resource://gre/modules/Extension.jsm",
   ExtensionPermissions: "resource://gre/modules/ExtensionPermissions.jsm",
@@ -137,10 +136,6 @@ var ExtensionsUI = {
       type: "sideload",
     });
 
-    AMTelemetry.recordManageEvent(addon, "sideload_prompt", {
-      num_strings: strings.msgs.length,
-    });
-
     this.showAddonsManager(tabbrowser, strings, addon.iconURL, "sideload").then(
       async answer => {
         if (answer) {
@@ -164,11 +159,6 @@ var ExtensionsUI = {
   },
 
   showUpdate(browser, info) {
-    AMTelemetry.recordInstallEvent(info.install, {
-      step: "permissions_prompt",
-      num_strings: info.strings.msgs.length,
-    });
-
     this.showAddonsManager(
       browser,
       info.strings,
@@ -239,17 +229,6 @@ var ExtensionsUI = {
         histkey = "installWeb";
       }
 
-      if (info.type == "sideload") {
-        AMTelemetry.recordManageEvent(info.addon, "sideload_prompt", {
-          num_strings: strings.msgs.length,
-        });
-      } else {
-        AMTelemetry.recordInstallEvent(info.install, {
-          step: "permissions_prompt",
-          num_strings: strings.msgs.length,
-        });
-      }
-
       this.showPermissionsPrompt(browser, strings, icon, histkey).then(
         answer => {
           if (answer) {
@@ -548,24 +527,12 @@ var ExtensionsUI = {
           origins: [],
         };
 
-        let value;
         // The checkbox has been changed at this point, otherwise we would
         // have exited early above.
         if (checkbox.checked) {
           await ExtensionPermissions.add(addon.id, incognitoPermission);
-          value = "on";
         } else if (hasIncognito) {
           await ExtensionPermissions.remove(addon.id, incognitoPermission);
-          value = "off";
-        }
-        if (value !== undefined) {
-          AMTelemetry.recordActionEvent({
-            addon,
-            object: "doorhanger",
-            action: "privateBrowsingAllowed",
-            view: "postInstall",
-            value,
-          });
         }
         // Reload the extension if it is already enabled.  This ensures any change
         // on the private browsing permission is properly handled.
diff --git a/browser/modules/PartnerLinkAttribution.jsm b/browser/modules/PartnerLinkAttribution.jsm
--- a/browser/modules/PartnerLinkAttribution.jsm
+++ b/browser/modules/PartnerLinkAttribution.jsm
@@ -17,22 +17,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   Services: "resource://gre/modules/Services.jsm",
-  Region: "resource://gre/modules/Region.jsm",
-  PingCentre: "resource:///modules/PingCentre.jsm",
-});
-
-// Endpoint base URL for Structured Ingestion
-XPCOMUtils.defineLazyPreferenceGetter(
-  this,
-  "structuredIngestionEndpointBase",
-  "browser.newtabpage.activity-stream.telemetry.structuredIngestion.endpoint",
-  ""
-);
-const NAMESPACE_CONTEXUAL_SERVICES = "contextual-services";
-
-// PingCentre client to send custom pings
-XPCOMUtils.defineLazyGetter(this, "pingcentre", () => {
-  return new PingCentre({ topic: "contextual-services" });
 });
 
 // `contextId` is a unique identifier used by Contextual Services
@@ -56,105 +40,6 @@ const CONTEXTUAL_SERVICES_PING_TYPES = {
 
 var PartnerLinkAttribution = {
   /**
-   * Sends an attribution request to an anonymizing proxy.
-   *
-   * @param {string} targetURL
-   *   The URL we are routing through the anonmyzing proxy.
-   * @param {string} source
-   *   The source of the anonmized request, e.g. "urlbar".
-   * @param {string} [campaignID]
-   *   The campaign ID for attribution. This should be a valid path on the
-   *   anonymizing proxy. For example, if `campaignID` was `foo`, we'd send an
-   *   attribution request to https://topsites.mozilla.com/cid/foo.
-   *   Optional. If it's not provided, we default to the topsites campaign.
-   */
-  async makeRequest({ targetURL, source, campaignID }) {
-    let partner = targetURL.match(/^https?:\/\/(?:www.)?([^.]*)/)[1];
-
-    function record(method, objectString) {
-      recordTelemetryEvent({
-        method,
-        objectString,
-        value: partner,
-      });
-    }
-    record("click", source);
-
-    let attributionUrl = Services.prefs.getStringPref(
-      "browser.partnerlink.attributionURL"
-    );
-    if (!attributionUrl) {
-      record("attribution", "abort");
-      return;
-    }
-
-    // The default campaign is topsites.
-    if (!campaignID) {
-      campaignID = Services.prefs.getStringPref(
-        "browser.partnerlink.campaign.topsites"
-      );
-    }
-    attributionUrl = attributionUrl + campaignID;
-    let result = await sendRequest(attributionUrl, source, targetURL);
-    record("attribution", result ? "success" : "failure");
-  },
-
-  /**
-   * Makes a request to the attribution URL for a search engine search.
-   *
-   * @param {nsISearchEngine} engine
-   *   The search engine to save the attribution for.
-   * @param {nsIURI} targetUrl
-   *   The target URL to filter and include in the attribution.
-   */
-  async makeSearchEngineRequest(engine, targetUrl) {
-    let cid;
-    if (engine.attribution?.cid) {
-      cid = engine.attribution.cid;
-    } else if (engine.sendAttributionRequest) {
-      cid = Services.prefs.getStringPref(
-        "browser.partnerlink.campaign.topsites"
-      );
-    } else {
-      return;
-    }
-
-    let searchUrlQueryParamName = engine.searchUrlQueryParamName;
-    if (!searchUrlQueryParamName) {
-      Cu.reportError("makeSearchEngineRequest can't find search terms key");
-      return;
-    }
-
-    let url = targetUrl;
-    if (typeof url == "string") {
-      url = Services.io.newURI(url);
-    }
-
-    let targetParams = new URLSearchParams(url.query);
-    if (!targetParams.has(searchUrlQueryParamName)) {
-      Cu.reportError(
-        "makeSearchEngineRequest can't remove target search terms"
-      );
-      return;
-    }
-
-    let attributionUrl = Services.prefs.getStringPref(
-      "browser.partnerlink.attributionURL",
-      ""
-    );
-    attributionUrl = attributionUrl + cid;
-
-    targetParams.delete(searchUrlQueryParamName);
-    let strippedTargetUrl = `${url.prePath}${url.filePath}`;
-    let newParams = targetParams.toString();
-    if (newParams) {
-      strippedTargetUrl += "?" + newParams;
-    }
-
-    await sendRequest(attributionUrl, "searchurl", strippedTargetUrl);
-  },
-
-  /**
    * Sends a Contextual Services ping to the Mozilla data pipeline.
    *
    * Note:
@@ -175,52 +60,6 @@ var PartnerLinkAttribution = {
       return;
     }
 
-    const endpoint = makeEndpointUrl(pingType, "1");
     payload.context_id = contextId;
-    pingcentre.sendStructuredIngestionPing(payload, endpoint);
-  },
-
-  /**
-   * Gets the underlying PingCentre client, only used for tests.
-   */
-  get _pingCentre() {
-    return pingcentre;
   },
 };
-
-async function sendRequest(attributionUrl, source, targetURL) {
-  const request = new Request(attributionUrl);
-  request.headers.set("X-Region", Region.home);
-  request.headers.set("X-Source", source);
-  request.headers.set("X-Target-URL", targetURL);
-  const response = await fetch(request);
-  return response.ok;
-}
-
-function recordTelemetryEvent({ method, objectString, value }) {
-  Services.telemetry.setEventRecordingEnabled("partner_link", true);
-  Services.telemetry.recordEvent("partner_link", method, objectString, value);
-}
-
-/**
- * Makes a new endpoint URL for a ping submission. Note that each submission
- * to Structured Ingesttion requires a new endpoint. See more details about
- * the specs:
- *
- * https://docs.telemetry.mozilla.org/concepts/pipeline/http_edge_spec.html?highlight=docId#postput-request
- *
- * @param {String} pingType
- *   The ping type. Must be one of CONTEXTUAL_SERVICES_PING_TYPES
- * @param {String} version
- *   The schema version of the ping.
- */
-function makeEndpointUrl(pingType, version) {
-  // Structured Ingestion does not support the UUID generated by gUUIDGenerator.
-  // Stripping off the leading and trailing braces to make it happy.
-  const docID = Services.uuid
-    .generateUUID()
-    .toString()
-    .slice(1, -1);
-  const extension = `${NAMESPACE_CONTEXUAL_SERVICES}/${pingType}/${version}/${docID}`;
-  return `${structuredIngestionEndpointBase}/${extension}`;
-}
diff --git a/browser/modules/PingCentre.jsm b/browser/modules/PingCentre.jsm
--- a/browser/modules/PingCentre.jsm
+++ b/browser/modules/PingCentre.jsm
@@ -27,11 +27,8 @@ ChromeUtils.defineModuleGetter(
 
 const PREF_BRANCH = "browser.ping-centre.";
 
-const TELEMETRY_PREF = `${PREF_BRANCH}telemetry`;
 const LOGGING_PREF = `${PREF_BRANCH}log`;
 
-const FHR_UPLOAD_ENABLED_PREF = "datareporting.healthreport.uploadEnabled";
-
 /**
  * Observe various notifications and send them to a telemetry endpoint.
  *
@@ -48,35 +45,19 @@ class PingCentre {
     this._topic = options.topic;
     this._prefs = Services.prefs.getBranch("");
 
-    this._enabled = this._prefs.getBoolPref(TELEMETRY_PREF);
-    this._onTelemetryPrefChange = this._onTelemetryPrefChange.bind(this);
-    this._prefs.addObserver(TELEMETRY_PREF, this._onTelemetryPrefChange);
-
-    this._fhrEnabled = this._prefs.getBoolPref(FHR_UPLOAD_ENABLED_PREF);
-    this._onFhrPrefChange = this._onFhrPrefChange.bind(this);
-    this._prefs.addObserver(FHR_UPLOAD_ENABLED_PREF, this._onFhrPrefChange);
-
     this.logging = this._prefs.getBoolPref(LOGGING_PREF);
     this._onLoggingPrefChange = this._onLoggingPrefChange.bind(this);
     this._prefs.addObserver(LOGGING_PREF, this._onLoggingPrefChange);
   }
 
   get enabled() {
-    return this._enabled && this._fhrEnabled;
+    return false;
   }
 
   _onLoggingPrefChange(aSubject, aTopic, prefKey) {
     this.logging = this._prefs.getBoolPref(prefKey);
   }
 
-  _onTelemetryPrefChange(aSubject, aTopic, prefKey) {
-    this._enabled = this._prefs.getBoolPref(prefKey);
-  }
-
-  _onFhrPrefChange(aSubject, aTopic, prefKey) {
-    this._fhrEnabled = this._prefs.getBoolPref(prefKey);
-  }
-
   _createExperimentsPayload() {
     let activeExperiments = TelemetryEnvironment.getActiveExperiments();
     let experiments = {};
@@ -146,12 +127,7 @@ class PingCentre {
 
   uninit() {
     try {
-      this._prefs.removeObserver(TELEMETRY_PREF, this._onTelemetryPrefChange);
       this._prefs.removeObserver(LOGGING_PREF, this._onLoggingPrefChange);
-      this._prefs.removeObserver(
-        FHR_UPLOAD_ENABLED_PREF,
-        this._onFhrPrefChange
-      );
     } catch (e) {
       Cu.reportError(e);
     }
@@ -160,8 +136,6 @@ class PingCentre {
 
 this.PingCentre = PingCentre;
 this.PingCentreConstants = {
-  FHR_UPLOAD_ENABLED_PREF,
-  TELEMETRY_PREF,
   LOGGING_PREF,
 };
 const EXPORTED_SYMBOLS = ["PingCentre", "PingCentreConstants"];
diff --git a/browser/modules/moz.build b/browser/modules/moz.build
--- a/browser/modules/moz.build
+++ b/browser/modules/moz.build
@@ -122,7 +122,6 @@ EXTRA_JS_MODULES += [
     "AppUpdater.jsm",
     "AsyncTabSwitcher.jsm",
     "BrowserUIUtils.jsm",
-    "BrowserUsageTelemetry.jsm",
     "BrowserWindowTracker.jsm",
     "ContentCrashHandlers.jsm",
     "Discovery.jsm",
@@ -136,7 +135,6 @@ EXTRA_JS_MODULES += [
     "PageActions.jsm",
     "PartnerLinkAttribution.jsm",
     "PermissionUI.jsm",
-    "PingCentre.jsm",
     "ProcessHangMonitor.jsm",
     "Sanitizer.jsm",
     "SelectionChangedMenulist.jsm",
diff --git a/docshell/base/nsAboutRedirector.cpp b/docshell/base/nsAboutRedirector.cpp
--- a/docshell/base/nsAboutRedirector.cpp
+++ b/docshell/base/nsAboutRedirector.cpp
@@ -163,8 +163,6 @@ static const RedirEntry kRedirMap[] = {
 #  endif
          nsIAboutModule::ALLOW_SCRIPT},
 #endif
-    {"telemetry", "chrome://global/content/aboutTelemetry.xhtml",
-     nsIAboutModule::ALLOW_SCRIPT | nsIAboutModule::IS_SECURE_CHROME_UI},
     {"url-classifier", "chrome://global/content/aboutUrlClassifier.xhtml",
      nsIAboutModule::ALLOW_SCRIPT},
     {"webrtc", "chrome://global/content/aboutwebrtc/aboutWebrtc.html",
diff --git a/dom/base/Document.cpp b/dom/base/Document.cpp
--- a/dom/base/Document.cpp
+++ b/dom/base/Document.cpp
@@ -301,7 +301,6 @@
 #include "nsIBFCacheEntry.h"
 #include "nsIBaseWindow.h"
 #include "nsIBrowserChild.h"
-#include "nsIBrowserUsage.h"
 #include "nsICSSLoaderObserver.h"
 #include "nsICategoryManager.h"
 #include "nsICertOverrideService.h"
@@ -17441,18 +17440,7 @@ bool Document::AutomaticStorageAccessPer
     return false;
   }
 
-  nsCOMPtr<nsIBrowserUsage> bu = do_ImportModule(
-      "resource:///modules/BrowserUsageTelemetry.jsm", fallible);
-  if (NS_WARN_IF(!bu)) {
-    return false;
-  }
-
   uint32_t uniqueDomainsVisitedInPast24Hours = 0;
-  nsresult rv = bu->GetUniqueDomainsVisitedInPast24Hours(
-      &uniqueDomainsVisitedInPast24Hours);
-  if (NS_WARN_IF(NS_FAILED(rv))) {
-    return false;
-  }
 
   Maybe<size_t> maybeOriginsThirdPartyHasAccessTo =
       AntiTrackingUtils::CountSitesAllowStorageAccess(aPrincipal);
diff --git a/dom/ipc/ContentChild.cpp b/dom/ipc/ContentChild.cpp
--- a/dom/ipc/ContentChild.cpp
+++ b/dom/ipc/ContentChild.cpp
@@ -30,7 +30,6 @@
 #include "mozilla/LoadInfo.h"
 #include "mozilla/Logging.h"
 #include "mozilla/LookAndFeel.h"
-#include "mozilla/MemoryTelemetry.h"
 #include "mozilla/NullPrincipal.h"
 #include "mozilla/PerfStats.h"
 #include "mozilla/PerformanceMetricsCollector.h"
diff --git a/dom/security/DOMSecurityMonitor.cpp b/dom/security/DOMSecurityMonitor.cpp
--- a/dom/security/DOMSecurityMonitor.cpp
+++ b/dom/security/DOMSecurityMonitor.cpp
@@ -76,7 +76,6 @@ void DOMSecurityMonitor::AuditParsingOfH
                        "inactive-css-tooltip-helper.js"),
       "resource://devtools/client/shared/widgets/Spectrum.js"_ns,
       "resource://gre/modules/narrate/VoiceSelect.jsm"_ns,
-      "resource://normandy-vendor/ReactDOM.js"_ns,
       // ------------------------------------------------------------------
       // test pages
       // ------------------------------------------------------------------
diff --git a/toolkit/components/build/components.conf b/toolkit/components/build/components.conf
--- a/toolkit/components/build/components.conf
+++ b/toolkit/components/build/components.conf
@@ -182,13 +182,3 @@ if not defined('MOZ_DISABLE_PARENTAL_CON
             'headers': ['/toolkit/components/parentalcontrols/nsParentalControlsService.h'],
         },
     ]
-
-if MOZ_HAS_TERMINATOR:
-    Classes += [
-        {
-            'cid': '{2e59cc70-f83a-412f-89d4-453885837217}',
-            'contract_ids': ['@mozilla.org/toolkit/shutdown-terminator;1'],
-            'type': 'mozilla::nsTerminator',
-            'headers': ['nsTerminator.h'],
-        },
-    ]
diff --git a/toolkit/components/extensions/Extension.jsm b/toolkit/components/extensions/Extension.jsm
--- a/toolkit/components/extensions/Extension.jsm
+++ b/toolkit/components/extensions/Extension.jsm
@@ -57,7 +57,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   ExtensionProcessScript: "resource://gre/modules/ExtensionProcessScript.jsm",
   ExtensionStorage: "resource://gre/modules/ExtensionStorage.jsm",
   ExtensionStorageIDB: "resource://gre/modules/ExtensionStorageIDB.jsm",
-  ExtensionTelemetry: "resource://gre/modules/ExtensionTelemetry.jsm",
   LightweightThemeManager: "resource://gre/modules/LightweightThemeManager.jsm",
   Log: "resource://gre/modules/Log.jsm",
   NetUtil: "resource://gre/modules/NetUtil.jsm",
@@ -2891,7 +2890,6 @@ class Extension extends ExtensionData {
     });
     sharedData.set("extensions/pending", pendingExtensions);
 
-    ExtensionTelemetry.extensionStartup.stopwatchStart(this);
     try {
       this.state = "Startup: Loading manifest";
       await this.loadManifest();
@@ -3045,7 +3043,6 @@ class Extension extends ExtensionData {
 
       throw e;
     } finally {
-      ExtensionTelemetry.extensionStartup.stopwatchFinish(this);
       // Mark readyPromise as resolved in case it has not happened before,
       // e.g. due to an early return or an error.
       resolveReadyPromise(null);
diff --git a/toolkit/components/extensions/ExtensionContent.jsm b/toolkit/components/extensions/ExtensionContent.jsm
--- a/toolkit/components/extensions/ExtensionContent.jsm
+++ b/toolkit/components/extensions/ExtensionContent.jsm
@@ -15,7 +15,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 XPCOMUtils.defineLazyModuleGetters(this, {
   AppConstants: "resource://gre/modules/AppConstants.jsm",
   ExtensionProcessScript: "resource://gre/modules/ExtensionProcessScript.jsm",
-  ExtensionTelemetry: "resource://gre/modules/ExtensionTelemetry.jsm",
   LanguageDetector: "resource:///modules/translation/LanguageDetector.jsm",
   Schemas: "resource://gre/modules/Schemas.jsm",
   WebNavigationFrames: "resource://gre/modules/WebNavigationFrames.jsm",
@@ -565,10 +564,6 @@ class Script {
 
     // The evaluations below may throw, in which case the promise will be
     // automatically rejected.
-    ExtensionTelemetry.contentScriptInjection.stopwatchStart(
-      extension,
-      context
-    );
     try {
       for (let script of scripts) {
         result = script.executeInGlobal(context.cloneScope);
@@ -583,11 +578,6 @@ class Script {
           1
         );
       }
-    } finally {
-      ExtensionTelemetry.contentScriptInjection.stopwatchFinish(
-        extension,
-        context
-      );
     }
 
     return result;
@@ -687,7 +677,6 @@ class UserScript extends Script {
 
     // The evaluations below may throw, in which case the promise will be
     // automatically rejected.
-    ExtensionTelemetry.userScriptInjection.stopwatchStart(extension, context);
     try {
       let userScriptSandbox = this.sandboxes.get(context);
 
@@ -713,11 +702,6 @@ class UserScript extends Script {
       for (let script of sandboxScripts) {
         script.executeInGlobal(userScriptSandbox);
       }
-    } finally {
-      ExtensionTelemetry.userScriptInjection.stopwatchFinish(
-        extension,
-        context
-      );
     }
   }
 
diff --git a/toolkit/components/extensions/ExtensionParent.jsm b/toolkit/components/extensions/ExtensionParent.jsm
--- a/toolkit/components/extensions/ExtensionParent.jsm
+++ b/toolkit/components/extensions/ExtensionParent.jsm
@@ -35,7 +35,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   PerformanceCounters: "resource://gre/modules/PerformanceCounters.jsm",
   PrivateBrowsingUtils: "resource://gre/modules/PrivateBrowsingUtils.jsm",
   Schemas: "resource://gre/modules/Schemas.jsm",
-  getErrorNameForTelemetry: "resource://gre/modules/ExtensionTelemetry.jsm",
 });
 
 XPCOMUtils.defineLazyServiceGetters(this, {
@@ -2016,12 +2015,6 @@ StartupCache = {
       if (!DOMException.isInstance(e) || e.name !== "NotFoundError") {
         Cu.reportError(e);
       }
-
-      Services.telemetry.keyedScalarAdd(
-        "extensions.startupCache.read_errors",
-        getErrorNameForTelemetry(e),
-        1
-      );
     }
 
     this._data = result;
diff --git a/toolkit/components/extensions/ExtensionStorageIDB.jsm b/toolkit/components/extensions/ExtensionStorageIDB.jsm
--- a/toolkit/components/extensions/ExtensionStorageIDB.jsm
+++ b/toolkit/components/extensions/ExtensionStorageIDB.jsm
@@ -16,7 +16,6 @@ const { IndexedDB } = ChromeUtils.import
 XPCOMUtils.defineLazyModuleGetters(this, {
   ExtensionStorage: "resource://gre/modules/ExtensionStorage.jsm",
   ExtensionUtils: "resource://gre/modules/ExtensionUtils.jsm",
-  getTrimmedString: "resource://gre/modules/ExtensionTelemetry.jsm",
   Services: "resource://gre/modules/Services.jsm",
   OS: "resource://gre/modules/osfile.jsm",
 });
@@ -62,36 +61,6 @@ var ErrorsTelemetry = {
   },
 
   /**
-   * Get the DOMException error name for a given error object.
-   *
-   * @param {Error | undefined} error
-   *        The Error object to convert into a string, or undefined if there was no error.
-   *
-   * @returns {string | undefined}
-   *          The DOMException error name (sliced to a maximum of 80 chars),
-   *          "OtherError" if the error object is not a DOMException instance,
-   *          or `undefined` if there wasn't an error.
-   */
-  getErrorName(error) {
-    if (!error) {
-      return undefined;
-    }
-
-    if (
-      DOMException.isInstance(error) ||
-      error instanceof DataMigrationAbortedError
-    ) {
-      if (error.name.length > 80) {
-        return getTrimmedString(error.name);
-      }
-
-      return error.name;
-    }
-
-    return "OtherError";
-  },
-
-  /**
    * Record telemetry related to a data migration result.
    *
    * @param {object} telemetryData
@@ -124,32 +93,6 @@ var ErrorsTelemetry = {
 
       this.lazyInit();
       this.resultHistogram.add(histogramCategory);
-
-      const extra = { backend };
-
-      if (dataMigrated != null) {
-        extra.data_migrated = dataMigrated ? "y" : "n";
-      }
-
-      if (hasJSONFile != null) {
-        extra.has_jsonfile = hasJSONFile ? "y" : "n";
-      }
-
-      if (hasOldData != null) {
-        extra.has_olddata = hasOldData ? "y" : "n";
-      }
-
-      if (error) {
-        extra.error_name = this.getErrorName(error);
-      }
-
-      Services.telemetry.recordEvent(
-        "extensions.data",
-        "migrateResult",
-        "storageLocal",
-        getTrimmedString(extensionId),
-        extra
-      );
     } catch (err) {
       // Report any telemetry error on the browser console, but
       // we treat it as a non-fatal error and we don't re-throw
@@ -171,14 +114,6 @@ var ErrorsTelemetry = {
    */
   recordStorageLocalError({ extensionId, storageMethod, error }) {
     this.lazyInit();
-
-    Services.telemetry.recordEvent(
-      "extensions.data",
-      "storageLocalError",
-      storageMethod,
-      getTrimmedString(extensionId),
-      { error_name: this.getErrorName(error) }
-    );
   },
 };
 
diff --git a/toolkit/components/extensions/child/ext-storage.js b/toolkit/components/extensions/child/ext-storage.js
--- a/toolkit/components/extensions/child/ext-storage.js
+++ b/toolkit/components/extensions/child/ext-storage.js
@@ -14,22 +14,14 @@ ChromeUtils.defineModuleGetter(
   "ExtensionStorageIDB",
   "resource://gre/modules/ExtensionStorageIDB.jsm"
 );
-ChromeUtils.defineModuleGetter(
-  this,
-  "ExtensionTelemetry",
-  "resource://gre/modules/ExtensionTelemetry.jsm"
-);
 
 // Wrap a storage operation in a TelemetryStopWatch.
-async function measureOp(telemetryMetric, extension, fn) {
+async function measureOp(extension, fn) {
   const stopwatchKey = {};
-  telemetryMetric.stopwatchStart(extension, stopwatchKey);
   try {
     let result = await fn();
-    telemetryMetric.stopwatchFinish(extension, stopwatchKey);
     return result;
   } catch (err) {
-    telemetryMetric.stopwatchCancel(extension, stopwatchKey);
     throw err;
   }
 }
@@ -39,7 +31,6 @@ this.storage = class extends ExtensionAP
     return {
       get(keys) {
         return measureOp(
-          ExtensionTelemetry.storageLocalGetJSON,
           context.extension,
           () => {
             return context.childManager
@@ -52,7 +43,6 @@ this.storage = class extends ExtensionAP
       },
       set(items) {
         return measureOp(
-          ExtensionTelemetry.storageLocalSetJSON,
           context.extension,
           () => {
             return context.childManager.callParentAsyncFunction(
@@ -100,7 +90,6 @@ this.storage = class extends ExtensionAP
     return {
       get(keys) {
         return measureOp(
-          ExtensionTelemetry.storageLocalGetIDB,
           context.extension,
           async () => {
             const db = await getDB();
@@ -110,7 +99,6 @@ this.storage = class extends ExtensionAP
       },
       set(items) {
         return measureOp(
-          ExtensionTelemetry.storageLocalSetIDB,
           context.extension,
           async () => {
             const db = await getDB();
diff --git a/toolkit/components/extensions/parent/ext-backgroundPage.js b/toolkit/components/extensions/parent/ext-backgroundPage.js
--- a/toolkit/components/extensions/parent/ext-backgroundPage.js
+++ b/toolkit/components/extensions/parent/ext-backgroundPage.js
@@ -15,11 +15,6 @@ var {
 
 ChromeUtils.defineModuleGetter(
   this,
-  "ExtensionTelemetry",
-  "resource://gre/modules/ExtensionTelemetry.jsm"
-);
-ChromeUtils.defineModuleGetter(
-  this,
   "PrivateBrowsingUtils",
   "resource://gre/modules/PrivateBrowsingUtils.jsm"
 );
@@ -93,7 +88,6 @@ class BackgroundPage extends HiddenExten
 
   async build() {
     const { extension } = this;
-    ExtensionTelemetry.backgroundPageLoad.stopwatchStart(extension, this);
 
     let context;
     try {
@@ -113,10 +107,8 @@ class BackgroundPage extends HiddenExten
       });
 
       context = await contextPromise;
-      ExtensionTelemetry.backgroundPageLoad.stopwatchFinish(extension, this);
     } catch (e) {
       // Extension was down before the background page has loaded.
-      ExtensionTelemetry.backgroundPageLoad.stopwatchCancel(extension, this);
       throw e;
     }
 
diff --git a/toolkit/components/extensions/parent/ext-telemetry.js b/toolkit/components/extensions/parent/ext-telemetry.js
--- a/toolkit/components/extensions/parent/ext-telemetry.js
+++ b/toolkit/components/extensions/parent/ext-telemetry.js
@@ -89,20 +89,7 @@ this.telemetry = class extends Extension
         },
         canUpload() {
           desktopCheck();
-          // Note: remove the ternary and direct pref check when
-          // TelemetryController.canUpload() is implemented (bug 1440089).
-          try {
-            const result =
-              "canUpload" in TelemetryController
-                ? TelemetryController.canUpload()
-                : Services.prefs.getBoolPref(
-                    TelemetryUtils.Preferences.FhrUploadEnabled,
-                    false
-                  );
-            return result;
-          } catch (ex) {
-            throw new ExtensionUtils.ExtensionError(ex);
-          }
+          return false;
         },
         scalarAdd(name, value) {
           desktopCheck();
diff --git a/toolkit/components/glean/src/init/mod.rs b/toolkit/components/glean/src/init/mod.rs
--- a/toolkit/components/glean/src/init/mod.rs
+++ b/toolkit/components/glean/src/init/mod.rs
@@ -42,7 +42,7 @@ pub extern "C" fn fog_init(
     data_path_override: &nsACString,
     app_id_override: &nsACString,
 ) -> nsresult {
-    let upload_enabled = static_prefs::pref!("datareporting.healthreport.uploadEnabled");
+    let upload_enabled = false;
     let recording_enabled = static_prefs::pref!("telemetry.fog.test.localhost_port") < 0;
     let uploader = Some(Box::new(ViaductUploader) as Box<dyn glean::net::PingUploader>);
 
@@ -336,7 +336,7 @@ fn fog_test_reset_internal(
 ) -> Result<(), nsresult> {
     let (mut conf, client_info) = build_configuration(data_path_override, app_id_override)?;
 
-    let upload_enabled = static_prefs::pref!("datareporting.healthreport.uploadEnabled");
+    let upload_enabled = false;
     let recording_enabled = static_prefs::pref!("telemetry.fog.test.localhost_port") < 0;
     conf.upload_enabled = upload_enabled || recording_enabled;
 
diff --git a/toolkit/components/glean/src/init/upload_pref.rs b/toolkit/components/glean/src/init/upload_pref.rs
--- a/toolkit/components/glean/src/init/upload_pref.rs
+++ b/toolkit/components/glean/src/init/upload_pref.rs
@@ -81,7 +81,7 @@ impl UploadPrefObserver {
                 || pref_name == "telemetry.fog.test.localhost_port"
         );
 
-        let upload_enabled = static_prefs::pref!("datareporting.healthreport.uploadEnabled");
+        let upload_enabled = false;
         let recording_enabled = static_prefs::pref!("telemetry.fog.test.localhost_port") < 0;
         log::info!(
             "New upload_enabled {}, recording_enabled {}",
diff --git a/toolkit/components/messaging-system/targeting/Targeting.jsm b/toolkit/components/messaging-system/targeting/Targeting.jsm
--- a/toolkit/components/messaging-system/targeting/Targeting.jsm
+++ b/toolkit/components/messaging-system/targeting/Targeting.jsm
@@ -14,7 +14,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   ASRouterTargeting: "resource://activity-stream/lib/ASRouterTargeting.jsm",
   FilterExpressions:
     "resource://gre/modules/components-utils/FilterExpressions.jsm",
-  ClientEnvironment: "resource://normandy/lib/ClientEnvironment.jsm",
   ClientEnvironmentBase:
     "resource://gre/modules/components-utils/ClientEnvironment.jsm",
   AppConstants: "resource://gre/modules/AppConstants.jsm",
@@ -45,7 +44,7 @@ const TargetingEnvironment = {
   },
 
   get userId() {
-    return ClientEnvironment.userId;
+    return "";
   },
 
   get version() {
diff --git a/toolkit/components/moz.build b/toolkit/components/moz.build
--- a/toolkit/components/moz.build
+++ b/toolkit/components/moz.build
@@ -101,9 +101,6 @@ if CONFIG["BUILD_CTYPES"]:
 
 DIRS += ["autocomplete", "printingui", "satchel", "captivedetect"]
 
-if CONFIG["OS_TARGET"] != "Android":
-    DIRS += ["terminator"]
-
 if CONFIG["MOZ_UPDATE_AGENT"]:
     DIRS += ["taskscheduler"]
 
@@ -122,7 +119,7 @@ if CONFIG["MOZ_WIDGET_TOOLKIT"] != "andr
     ]
 
 if CONFIG["MOZ_BUILD_APP"] == "browser":
-    DIRS += ["normandy", "messaging-system"]
+    DIRS += ["messaging-system"]
 
 DIRS += ["nimbus"]
 
diff --git a/toolkit/components/nimbus/lib/ExperimentManager.jsm b/toolkit/components/nimbus/lib/ExperimentManager.jsm
--- a/toolkit/components/nimbus/lib/ExperimentManager.jsm
+++ b/toolkit/components/nimbus/lib/ExperimentManager.jsm
@@ -33,8 +33,6 @@ const TELEMETRY_EVENT_OBJECT = "nimbus_e
 const TELEMETRY_EXPERIMENT_ACTIVE_PREFIX = "nimbus-";
 const TELEMETRY_DEFAULT_EXPERIMENT_TYPE = "nimbus";
 
-const STUDIES_OPT_OUT_PREF = "app.shield.optoutstudies.enabled";
-
 function featuresCompat(branch) {
   if (!branch || (!branch.feature && !branch.features)) {
     return [];
@@ -57,7 +55,6 @@ class _ExperimentManager {
     this.id = id;
     this.store = store || new ExperimentStore();
     this.sessions = new Map();
-    Services.prefs.addObserver(STUDIES_OPT_OUT_PREF, this);
   }
 
   /**
@@ -431,21 +428,6 @@ class _ExperimentManager {
   }
 
   /**
-   * Unenroll from all active studies if user opts out.
-   */
-  observe(aSubject, aTopic, aPrefName) {
-    if (Services.prefs.getBoolPref(STUDIES_OPT_OUT_PREF)) {
-      return;
-    }
-    for (const { slug } of this.store.getAllActive()) {
-      this.unenroll(slug, "studies-opt-out");
-    }
-    for (const { slug } of this.store.getAllRollouts()) {
-      this.unenroll(slug, "studies-opt-out");
-    }
-  }
-
-  /**
    * Send Telemetry for undesired event
    *
    * @param {string} eventName
diff --git a/toolkit/components/nimbus/lib/RemoteSettingsExperimentLoader.jsm b/toolkit/components/nimbus/lib/RemoteSettingsExperimentLoader.jsm
--- a/toolkit/components/nimbus/lib/RemoteSettingsExperimentLoader.jsm
+++ b/toolkit/components/nimbus/lib/RemoteSettingsExperimentLoader.jsm
@@ -20,7 +20,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   TargetingContext: "resource://messaging-system/targeting/Targeting.jsm",
   ExperimentManager: "resource://nimbus/lib/ExperimentManager.jsm",
   RemoteSettings: "resource://services-settings/remote-settings.js",
-  CleanupManager: "resource://normandy/lib/CleanupManager.jsm",
   NimbusFeatures: "resource://nimbus/ExperimentAPI.jsm",
   JsonSchema: "resource://gre/modules/JsonSchema.jsm",
 });
@@ -41,8 +40,6 @@ XPCOMUtils.defineLazyServiceGetter(
 
 const COLLECTION_ID_PREF = "messaging-system.rsexperimentloader.collection_id";
 const COLLECTION_ID_FALLBACK = "nimbus-desktop-experiments";
-const ENABLED_PREF = "messaging-system.rsexperimentloader.enabled";
-const STUDIES_OPT_OUT_PREF = "app.shield.optoutstudies.enabled";
 
 const TIMER_NAME = "rs-experiment-loader-timer";
 const TIMER_LAST_UPDATE_PREF = `app.update.lastUpdateTime.${TIMER_NAME}`;
@@ -89,22 +86,6 @@ class _RemoteSettingsExperimentLoader {
 
     XPCOMUtils.defineLazyPreferenceGetter(
       this,
-      "enabled",
-      ENABLED_PREF,
-      false,
-      this.onEnabledPrefChange.bind(this)
-    );
-
-    XPCOMUtils.defineLazyPreferenceGetter(
-      this,
-      "studiesEnabled",
-      STUDIES_OPT_OUT_PREF,
-      false,
-      this.onEnabledPrefChange.bind(this)
-    );
-
-    XPCOMUtils.defineLazyPreferenceGetter(
-      this,
       "intervalInSeconds",
       RUN_INTERVAL_PREF,
       21600,
@@ -113,15 +94,6 @@ class _RemoteSettingsExperimentLoader {
   }
 
   async init() {
-    if (this._initialized || !this.enabled || !this.studiesEnabled) {
-      return;
-    }
-
-    this.setTimer();
-    CleanupManager.addCleanupHandler(() => this.uninit());
-    this._initialized = true;
-
-    await this.updateRecipes();
   }
 
   uninit() {
@@ -307,22 +279,6 @@ class _RemoteSettingsExperimentLoader {
   }
 
   /**
-   * Handles feature status based on feature pref and STUDIES_OPT_OUT_PREF.
-   * Changing any of them to false will turn off any recipe fetching and
-   * processing.
-   */
-  onEnabledPrefChange(prefName, oldValue, newValue) {
-    if (this._initialized && !newValue) {
-      this.uninit();
-    } else if (!this._initialized && newValue && this.enabled) {
-      // If the feature pref is turned on then turn on recipe processing.
-      // If the opt in pref is turned on then turn on recipe processing only if
-      // the feature pref is also enabled.
-      this.init();
-    }
-  }
-
-  /**
    * Sets a timer to update recipes every this.intervalInSeconds
    */
   setTimer() {
diff --git a/toolkit/components/normandy/Normandy.jsm b/toolkit/components/normandy/Normandy.jsm
--- a/toolkit/components/normandy/Normandy.jsm
+++ b/toolkit/components/normandy/Normandy.jsm
@@ -22,7 +22,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   PreferenceExperiments: "resource://normandy/lib/PreferenceExperiments.jsm",
   PreferenceRollouts: "resource://normandy/lib/PreferenceRollouts.jsm",
   RecipeRunner: "resource://normandy/lib/RecipeRunner.jsm",
-  ShieldPreferences: "resource://normandy/lib/ShieldPreferences.jsm",
   TelemetryUtils: "resource://gre/modules/TelemetryUtils.jsm",
   TelemetryEvents: "resource://normandy/lib/TelemetryEvents.jsm",
   ExperimentManager: "resource://nimbus/lib/ExperimentManager.jsm",
@@ -57,12 +56,6 @@ var Normandy = {
     // await, to avoid missing it.
     Services.obs.addObserver(this, UI_AVAILABLE_NOTIFICATION);
 
-    // Listen for when Telemetry is disabled or re-enabled.
-    Services.obs.addObserver(
-      this,
-      TelemetryUtils.TELEMETRY_UPLOAD_DISABLED_TOPIC
-    );
-
     // It is important this happens before the first `await`. Note that this
     // also happens before migrations are applied.
     this.rolloutPrefsChanged = this.applyStartupPrefs(
@@ -96,15 +89,6 @@ var Normandy = {
     if (topic === UI_AVAILABLE_NOTIFICATION) {
       Services.obs.removeObserver(this, UI_AVAILABLE_NOTIFICATION);
       this.uiAvailableNotificationObserved.resolve();
-    } else if (topic === TelemetryUtils.TELEMETRY_UPLOAD_DISABLED_TOPIC) {
-      await Promise.all(
-        [
-          PreferenceExperiments,
-          PreferenceRollouts,
-          AddonStudies,
-          AddonRollouts,
-        ].map(service => service.onTelemetryDisabled())
-      );
     }
   },
 
@@ -163,12 +147,6 @@ var Normandy = {
       log.error("Failed to initialize preference experiments:", err);
     }
 
-    try {
-      ShieldPreferences.init();
-    } catch (err) {
-      log.error("Failed to initialize preferences UI:", err);
-    }
-
     await RecipeRunner.init();
     Services.obs.notifyObservers(null, SHIELD_INIT_NOTIFICATION);
   },
@@ -179,7 +157,6 @@ var Normandy = {
     // oppositely ordered parameters.
     Services.prefs.removeObserver(PREF_LOGGING_LEVEL, LogManager.configure);
     for (const topic of [
-      TelemetryUtils.TELEMETRY_UPLOAD_DISABLED_TOPIC,
       UI_AVAILABLE_NOTIFICATION,
     ]) {
       try {
diff --git a/toolkit/components/normandy/NormandyMigrations.jsm b/toolkit/components/normandy/NormandyMigrations.jsm
--- a/toolkit/components/normandy/NormandyMigrations.jsm
+++ b/toolkit/components/normandy/NormandyMigrations.jsm
@@ -133,18 +133,10 @@ function migrateShieldPrefs() {
  * to true then the pref should stay true. Otherwise set it to false.
  */
 function migrateStudiesEnabledWithoutHealthReporting() {
-  const optOutStudiesEnabled = Services.prefs.getBoolPref(
+  Services.prefs.setBoolPref(
     PREF_OPTOUTSTUDIES_ENABLED,
     false
   );
-  const healthReportUploadEnabled = Services.prefs.getBoolPref(
-    "datareporting.healthreport.uploadEnabled",
-    false
-  );
-  Services.prefs.setBoolPref(
-    PREF_OPTOUTSTUDIES_ENABLED,
-    optOutStudiesEnabled && healthReportUploadEnabled
-  );
 }
 
 /**
diff --git a/toolkit/components/normandy/actions/BaseStudyAction.jsm b/toolkit/components/normandy/actions/BaseStudyAction.jsm
--- a/toolkit/components/normandy/actions/BaseStudyAction.jsm
+++ b/toolkit/components/normandy/actions/BaseStudyAction.jsm
@@ -11,8 +11,6 @@ const { BaseAction } = ChromeUtils.impor
 
 var EXPORTED_SYMBOLS = ["BaseStudyAction"];
 
-const OPT_OUT_STUDIES_ENABLED_PREF = "app.shield.optoutstudies.enabled";
-
 /**
  * Base class for local study actions.
  *
@@ -29,16 +27,6 @@ const OPT_OUT_STUDIES_ENABLED_PREF = "ap
  */
 class BaseStudyAction extends BaseAction {
   _preExecution() {
-    if (!Services.policies.isAllowed("Shield")) {
-      this.log.debug("Disabling Shield because it's blocked by policy.");
       this.disable();
-    }
-
-    if (!Services.prefs.getBoolPref(OPT_OUT_STUDIES_ENABLED_PREF, true)) {
-      this.log.debug(
-        "User has opted-out of opt-out experiments, disabling action."
-      );
-      this.disable();
-    }
   }
 }
diff --git a/toolkit/components/normandy/content/AboutPages.jsm b/toolkit/components/normandy/content/AboutPages.jsm
--- a/toolkit/components/normandy/content/AboutPages.jsm
+++ b/toolkit/components/normandy/content/AboutPages.jsm
@@ -42,11 +42,6 @@ ChromeUtils.defineModuleGetter(
 var EXPORTED_SYMBOLS = ["AboutPages"];
 
 const SHIELD_LEARN_MORE_URL_PREF = "app.normandy.shieldLearnMoreUrl";
-XPCOMUtils.defineLazyPreferenceGetter(
-  this,
-  "gOptOutStudiesEnabled",
-  "app.shield.optoutstudies.enabled"
-);
 
 /**
  * Class for managing an about: page that Normandy provides. Adapted from
@@ -179,7 +174,7 @@ XPCOMUtils.defineLazyGetter(AboutPages, 
      */
     async getStudiesEnabled() {
       await RecipeRunner.initializedPromise.promise;
-      return RecipeRunner.enabled && gOptOutStudiesEnabled;
+      return false;
     },
 
     /**
diff --git a/toolkit/components/normandy/lib/ClientEnvironment.jsm b/toolkit/components/normandy/lib/ClientEnvironment.jsm
--- a/toolkit/components/normandy/lib/ClientEnvironment.jsm
+++ b/toolkit/components/normandy/lib/ClientEnvironment.jsm
@@ -140,6 +140,6 @@ class ClientEnvironment extends ClientEn
   }
 
   static get isFirstRun() {
-    return Services.prefs.getBoolPref("app.normandy.first_run", true);
+    return false;
   }
 }
diff --git a/toolkit/components/normandy/lib/RecipeRunner.jsm b/toolkit/components/normandy/lib/RecipeRunner.jsm
--- a/toolkit/components/normandy/lib/RecipeRunner.jsm
+++ b/toolkit/components/normandy/lib/RecipeRunner.jsm
@@ -46,9 +46,6 @@ const REMOTE_SETTINGS_COLLECTION = "norm
 const PREF_CHANGED_TOPIC = "nsPref:changed";
 
 const RUN_INTERVAL_PREF = "app.normandy.run_interval_seconds";
-const FIRST_RUN_PREF = "app.normandy.first_run";
-const SHIELD_ENABLED_PREF = "app.normandy.enabled";
-const DEV_MODE_PREF = "app.normandy.dev_mode";
 const API_URL_PREF = "app.normandy.api_url";
 const LAZY_CLASSIFY_PREF = "app.normandy.experiments.lazy_classify";
 const ONSYNC_SKEW_SEC_PREF = "app.normandy.onsync_skew_sec";
@@ -57,7 +54,7 @@ const ONSYNC_SKEW_SEC_PREF = "app.norman
 // see https://searchfox.org/mozilla-central/rev/11cfa0462/toolkit/components/timermanager/UpdateTimerManager.jsm#8
 const TIMER_LAST_UPDATE_PREF = `app.update.lastUpdateTime.${TIMER_NAME}`;
 
-const PREFS_TO_WATCH = [RUN_INTERVAL_PREF, SHIELD_ENABLED_PREF, API_URL_PREF];
+const PREFS_TO_WATCH = [RUN_INTERVAL_PREF];
 
 XPCOMUtils.defineLazyGetter(this, "gRemoteSettingsClient", () => {
   return RemoteSettings(REMOTE_SETTINGS_COLLECTION);
@@ -94,63 +91,13 @@ var RecipeRunner = {
     this.loadFromRemoteSettings = false;
     this._syncSkewTimeout = null;
 
-    this.checkPrefs(); // sets this.enabled
+    this.disable();
     this.watchPrefs();
     this.setUpRemoteSettings();
 
-    // Here "first run" means the first run this profile has ever done. This
-    // preference is set to true at the end of this function, and never reset to
-    // false.
-    const firstRun = Services.prefs.getBoolPref(FIRST_RUN_PREF, true);
-
-    // If we've seen a build ID from a previous run that doesn't match the
-    // current build ID, run immediately. This is probably an upgrade or
-    // downgrade, which may cause recipe eligibility to change.
-    let hasNewBuildID =
-      Services.appinfo.lastAppBuildID != null &&
-      Services.appinfo.lastAppBuildID != Services.appinfo.appBuildID;
-
-    // Dev mode is a mode used for development and QA that bypasses the normal
-    // timer function of Normandy, to make testing more convenient.
-    const devMode = Services.prefs.getBoolPref(DEV_MODE_PREF, false);
-
-    if (this.enabled && (devMode || firstRun || hasNewBuildID)) {
-      // In dev mode, if remote settings is enabled, force an immediate sync
-      // before running. This ensures that the latest data is used for testing.
-      // This is not needed for the first run case, because remote settings
-      // already handles empty collections well.
-      if (devMode) {
-        await gRemoteSettingsClient.sync();
-      }
-      let trigger;
-      if (devMode) {
-        trigger = "devMode";
-      } else if (firstRun) {
-        trigger = "firstRun";
-      } else if (hasNewBuildID) {
-        trigger = "newBuildID";
-      }
-
-      await this.run({ trigger });
-    }
-
-    // Update the firstRun pref, to indicate that Normandy has run at least once
-    // on this profile.
-    if (firstRun) {
-      Services.prefs.setBoolPref(FIRST_RUN_PREF, false);
-    }
-
     this.initializedPromise.resolve();
   },
 
-  enable() {
-    if (this.enabled) {
-      return;
-    }
-    this.registerTimer();
-    this.enabled = true;
-  },
-
   disable() {
     if (this.enabled) {
       this.unregisterTimer();
@@ -185,12 +132,6 @@ var RecipeRunner = {
             this.updateRunInterval();
             break;
 
-          // explicit fall-through
-          case SHIELD_ENABLED_PREF:
-          case API_URL_PREF:
-            this.checkPrefs();
-            break;
-
           default:
             log.debug(
               `Observer fired with unexpected pref change: ${prefName}`
@@ -202,33 +143,6 @@ var RecipeRunner = {
     }
   },
 
-  checkPrefs() {
-    if (!Services.prefs.getBoolPref(SHIELD_ENABLED_PREF)) {
-      log.debug(
-        `Disabling Shield because ${SHIELD_ENABLED_PREF} is set to false`
-      );
-      this.disable();
-      return;
-    }
-
-    const apiUrl = Services.prefs.getCharPref(API_URL_PREF);
-    if (!apiUrl) {
-      log.warn(`Disabling Shield because ${API_URL_PREF} is not set.`);
-      this.disable();
-      return;
-    }
-    if (!apiUrl.startsWith("https://")) {
-      log.warn(
-        `Disabling Shield because ${API_URL_PREF} is not an HTTPS url: ${apiUrl}.`
-      );
-      this.disable();
-      return;
-    }
-
-    log.debug(`Enabling Shield`);
-    this.enable();
-  },
-
   registerTimer() {
     this.updateRunInterval();
     CleanupManager.addCleanupHandler(() =>
diff --git a/toolkit/components/normandy/moz.build b/toolkit/components/normandy/moz.build
--- a/toolkit/components/normandy/moz.build
+++ b/toolkit/components/normandy/moz.build
@@ -9,18 +9,10 @@ with Files("**"):
 
 JAR_MANIFESTS += ["jar.mn"]
 
-EXTRA_JS_MODULES += [
-    "ShieldContentProcess.jsm",
-]
-
 TESTING_JS_MODULES += [
     "test/NormandyTestUtils.jsm",
 ]
 
-XPCOM_MANIFESTS += [
-    "components.conf",
-]
-
 SPHINX_TREES["normandy"] = "docs"
 
 TEST_DIRS += ["test/browser"]
diff --git a/toolkit/components/places/PlacesDBUtils.jsm b/toolkit/components/places/PlacesDBUtils.jsm
--- a/toolkit/components/places/PlacesDBUtils.jsm
+++ b/toolkit/components/places/PlacesDBUtils.jsm
@@ -55,16 +55,12 @@ var PlacesDBUtils = {
       this.removeOldCorruptDBs,
       this.deleteOrphanPreviews,
     ];
-    let telemetryStartTime = Date.now();
     let taskStatusMap = await PlacesDBUtils.runTasks(tasks);
 
     Services.prefs.setIntPref(
       "places.database.lastMaintenance",
       parseInt(Date.now() / 1000)
     );
-    Services.telemetry
-      .getHistogramById("PLACES_IDLE_MAINTENANCE_TIME_MS")
-      .add(Date.now() - telemetryStartTime);
     return taskStatusMap;
   },
 
@@ -1104,189 +1100,6 @@ var PlacesDBUtils = {
   },
 
   /**
-   * Collects telemetry data and reports it to Telemetry.
-   *
-   * Note: although this function isn't actually async, we keep it async to
-   * allow us to maintain a simple, consistent API for the tasks within this object.
-   *
-   */
-  async telemetry() {
-    // This will be populated with one integer property for each probe result,
-    // using the histogram name as key.
-    let probeValues = {};
-
-    // The following array contains an ordered list of entries that are
-    // processed to collect telemetry data.  Each entry has these properties:
-    //
-    //  histogram: Name of the telemetry histogram to update.
-    //  query:     This is optional.  If present, contains a database command
-    //             that will be executed asynchronously, and whose result will
-    //             be added to the telemetry histogram.
-    //  callback:  This is optional.  If present, contains a function that must
-    //             return the value that will be added to the telemetry
-    //             histogram. If a query is also present, its result is passed
-    //             as the first argument of the function.  If the function
-    //             raises an exception, no data is added to the histogram.
-    //
-    // Since all queries are executed in order by the database backend, the
-    // callbacks can also use the result of previous queries stored in the
-    // probeValues object.
-    let probes = [
-      {
-        histogram: "PLACES_PAGES_COUNT",
-        query: "SELECT count(*) FROM moz_places",
-      },
-
-      {
-        histogram: "PLACES_BOOKMARKS_COUNT",
-        query: `SELECT count(*) FROM moz_bookmarks b
-                    JOIN moz_bookmarks t ON t.id = b.parent
-                    AND t.parent <> :tags_folder
-                    WHERE b.type = :type_bookmark`,
-        params: {
-          tags_folder: PlacesUtils.tagsFolderId,
-          type_bookmark: PlacesUtils.bookmarks.TYPE_BOOKMARK,
-        },
-      },
-
-      {
-        histogram: "PLACES_TAGS_COUNT",
-        query: `SELECT count(*) FROM moz_bookmarks
-                    WHERE parent = :tags_folder`,
-        params: {
-          tags_folder: PlacesUtils.tagsFolderId,
-        },
-      },
-
-      {
-        histogram: "PLACES_KEYWORDS_COUNT",
-        query: "SELECT count(*) FROM moz_keywords",
-      },
-
-      {
-        histogram: "PLACES_SORTED_BOOKMARKS_PERC",
-        query: `SELECT IFNULL(ROUND((
-                      SELECT count(*) FROM moz_bookmarks b
-                      JOIN moz_bookmarks t ON t.id = b.parent
-                      AND t.parent <> :tags_folder AND t.parent > :places_root
-                      WHERE b.type  = :type_bookmark
-                      ) * 100 / (
-                      SELECT count(*) FROM moz_bookmarks b
-                      JOIN moz_bookmarks t ON t.id = b.parent
-                      AND t.parent <> :tags_folder
-                      WHERE b.type = :type_bookmark
-                    )), 0)`,
-        params: {
-          places_root: PlacesUtils.placesRootId,
-          tags_folder: PlacesUtils.tagsFolderId,
-          type_bookmark: PlacesUtils.bookmarks.TYPE_BOOKMARK,
-        },
-      },
-
-      {
-        histogram: "PLACES_TAGGED_BOOKMARKS_PERC",
-        query: `SELECT IFNULL(ROUND((
-                      SELECT count(*) FROM moz_bookmarks b
-                      JOIN moz_bookmarks t ON t.id = b.parent
-                      AND t.parent = :tags_folder
-                      ) * 100 / (
-                      SELECT count(*) FROM moz_bookmarks b
-                      JOIN moz_bookmarks t ON t.id = b.parent
-                      AND t.parent <> :tags_folder
-                      WHERE b.type = :type_bookmark
-                    )), 0)`,
-        params: {
-          tags_folder: PlacesUtils.tagsFolderId,
-          type_bookmark: PlacesUtils.bookmarks.TYPE_BOOKMARK,
-        },
-      },
-
-      {
-        histogram: "PLACES_DATABASE_FILESIZE_MB",
-        async callback() {
-          let placesDbPath = PathUtils.join(
-            PathUtils.profileDir,
-            "places.sqlite"
-          );
-          let info = await IOUtils.stat(placesDbPath);
-          return parseInt(info.size / BYTES_PER_MEBIBYTE);
-        },
-      },
-
-      {
-        histogram: "PLACES_DATABASE_PAGESIZE_B",
-        query: "PRAGMA page_size /* PlacesDBUtils.jsm PAGESIZE_B */",
-      },
-
-      {
-        histogram: "PLACES_DATABASE_SIZE_PER_PAGE_B",
-        query: "PRAGMA page_count",
-        callback(aDbPageCount) {
-          // Note that the database file size would not be meaningful for this
-          // calculation, because the file grows in fixed-size chunks.
-          let dbPageSize = probeValues.PLACES_DATABASE_PAGESIZE_B;
-          let placesPageCount = probeValues.PLACES_PAGES_COUNT;
-          return Math.round((dbPageSize * aDbPageCount) / placesPageCount);
-        },
-      },
-
-      {
-        histogram: "PLACES_DATABASE_FAVICONS_FILESIZE_MB",
-        async callback() {
-          let faviconsDbPath = PathUtils.join(
-            PathUtils.profileDir,
-            "favicons.sqlite"
-          );
-          let info = await IOUtils.stat(faviconsDbPath);
-          return parseInt(info.size / BYTES_PER_MEBIBYTE);
-        },
-      },
-
-      {
-        histogram: "PLACES_ANNOS_BOOKMARKS_COUNT",
-        query: "SELECT count(*) FROM moz_items_annos",
-      },
-
-      {
-        histogram: "PLACES_ANNOS_PAGES_COUNT",
-        query: "SELECT count(*) FROM moz_annos",
-      },
-
-      {
-        histogram: "PLACES_MAINTENANCE_DAYSFROMLAST",
-        callback() {
-          try {
-            let lastMaintenance = Services.prefs.getIntPref(
-              "places.database.lastMaintenance"
-            );
-            let nowSeconds = parseInt(Date.now() / 1000);
-            return parseInt((nowSeconds - lastMaintenance) / 86400);
-          } catch (ex) {
-            return 60;
-          }
-        },
-      },
-    ];
-
-    for (let probe of probes) {
-      let val;
-      if ("query" in probe) {
-        let db = await PlacesUtils.promiseDBConnection();
-        val = (
-          await db.execute(probe.query, probe.params || {})
-        )[0].getResultByIndex(0);
-      }
-      // Report the result of the probe through Telemetry.
-      // The resulting promise cannot reject.
-      if ("callback" in probe) {
-        val = await probe.callback(val);
-      }
-      probeValues[probe.histogram] = val;
-      Services.telemetry.getHistogramById(probe.histogram).add(val);
-    }
-  },
-
-  /**
    * Remove old and useless places.sqlite.corrupt files.
    *
    * @resolves to an array of logs for this task.
diff --git a/toolkit/components/telemetry/app/TelemetryArchive.jsm b/toolkit/components/telemetry/app/TelemetryArchive.jsm
--- a/toolkit/components/telemetry/app/TelemetryArchive.jsm
+++ b/toolkit/components/telemetry/app/TelemetryArchive.jsm
@@ -65,10 +65,6 @@ var TelemetryArchive = {
  * to do that.
  * @return {Boolean} True if pings should be archived, false otherwise.
  */
-function shouldArchivePings() {
-  return Preferences.get(TelemetryUtils.Preferences.ArchiveEnabled, false);
-}
-
 var TelemetryArchiveImpl = {
   _logger: null,
 
@@ -84,19 +80,7 @@ var TelemetryArchiveImpl = {
   },
 
   promiseArchivePing(ping) {
-    if (!shouldArchivePings()) {
-      this._log.trace("promiseArchivePing - archiving is disabled");
       return Promise.resolve();
-    }
-
-    for (let field of ["creationDate", "id", "type"]) {
-      if (!(field in ping)) {
-        this._log.warn("promiseArchivePing - missing field " + field);
-        return Promise.reject(new Error("missing field " + field));
-      }
-    }
-
-    return TelemetryStorage.saveArchivedPing(ping);
   },
 
   _buildArchivedPingList(archivedPingsMap) {
diff --git a/toolkit/components/telemetry/app/TelemetryControllerBase.jsm b/toolkit/components/telemetry/app/TelemetryControllerBase.jsm
--- a/toolkit/components/telemetry/app/TelemetryControllerBase.jsm
+++ b/toolkit/components/telemetry/app/TelemetryControllerBase.jsm
@@ -22,8 +22,6 @@ const PREF_BRANCH_LOG = "toolkit.telemet
 const PREF_LOG_LEVEL = "toolkit.telemetry.log.level";
 const PREF_LOG_DUMP = "toolkit.telemetry.log.dump";
 
-const PREF_TELEMETRY_ENABLED = "toolkit.telemetry.enabled";
-
 const Preferences = Object.freeze({
   OverridePreRelease: "toolkit.telemetry.testing.overridePreRelease",
   Unified: "toolkit.telemetry.unified",
@@ -40,7 +38,7 @@ var gLogAppenderDump = null;
 var TelemetryControllerBase = Object.freeze({
   // Whether the FHR/Telemetry unification features are enabled.
   // Changing this pref requires a restart.
-  IS_UNIFIED_TELEMETRY: Services.prefs.getBoolPref(Preferences.Unified, false),
+  IS_UNIFIED_TELEMETRY: false,
 
   Preferences,
 
@@ -49,7 +47,7 @@ var TelemetryControllerBase = Object.fre
    * it correctly evaluates to a boolean type.
    */
   get isTelemetryEnabled() {
-    return Services.prefs.getBoolPref(PREF_TELEMETRY_ENABLED, false) === true;
+    return false;
   },
 
   get log() {
@@ -94,24 +92,8 @@ var TelemetryControllerBase = Object.fre
    * Set the Telemetry core recording flag for Unified Telemetry.
    */
   setTelemetryRecordingFlags() {
-    // Enable extended Telemetry on pre-release channels and disable it
-    // on Release/ESR.
-    let prereleaseChannels = ["nightly", "aurora", "beta"];
-    if (!AppConstants.MOZILLA_OFFICIAL) {
-      // Turn extended telemetry for local developer builds.
-      prereleaseChannels.push("default");
-    }
-    const isPrereleaseChannel = prereleaseChannels.includes(
-      AppConstants.MOZ_UPDATE_CHANNEL
-    );
-    const isReleaseCandidateOnBeta =
-      AppConstants.MOZ_UPDATE_CHANNEL === "release" &&
-      Services.prefs.getCharPref("app.update.channel", null) === "beta";
-    Services.telemetry.canRecordBase = true;
-    Services.telemetry.canRecordExtended =
-      isPrereleaseChannel ||
-      isReleaseCandidateOnBeta ||
-      Services.prefs.getBoolPref(this.Preferences.OverridePreRelease, false);
+    Services.telemetry.canRecordBase = false;
+    Services.telemetry.canRecordExtended = false;
   },
 
   /**
@@ -128,7 +110,7 @@ var TelemetryControllerBase = Object.fre
     } else {
       // We're not on unified Telemetry, stick to the old behaviour for
       // supporting Fennec.
-      Services.telemetry.canRecordBase = Services.telemetry.canRecordExtended = this.isTelemetryEnabled;
+      Services.telemetry.canRecordBase = Services.telemetry.canRecordExtended = false;
     }
 
     this.log.config(
diff --git a/toolkit/components/telemetry/app/TelemetryControllerParent.jsm b/toolkit/components/telemetry/app/TelemetryControllerParent.jsm
--- a/toolkit/components/telemetry/app/TelemetryControllerParent.jsm
+++ b/toolkit/components/telemetry/app/TelemetryControllerParent.jsm
@@ -56,7 +56,6 @@ ChromeUtils.defineModuleGetter(
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   ClientID: "resource://gre/modules/ClientID.jsm",
-  CoveragePing: "resource://gre/modules/CoveragePing.jsm",
   AsyncShutdown: "resource://gre/modules/AsyncShutdown.jsm",
   TelemetryStorage: "resource://gre/modules/TelemetryStorage.jsm",
   TelemetryEnvironment: "resource://gre/modules/TelemetryEnvironment.jsm",
@@ -65,14 +64,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   TelemetrySend: "resource://gre/modules/TelemetrySend.jsm",
   TelemetryReportingPolicy:
     "resource://gre/modules/TelemetryReportingPolicy.jsm",
-  TelemetryModules: "resource://gre/modules/ModulesPing.jsm",
-  TelemetryUntrustedModulesPing:
-    "resource://gre/modules/UntrustedModulesPing.jsm",
-  UpdatePing: "resource://gre/modules/UpdatePing.jsm",
-  TelemetryHealthPing: "resource://gre/modules/HealthPing.jsm",
-  TelemetryEventPing: "resource://gre/modules/EventPing.jsm",
-  TelemetryPrioPing: "resource://gre/modules/PrioPing.jsm",
-  UninstallPing: "resource://gre/modules/UninstallPing.jsm",
 });
 
 /**
@@ -247,19 +238,6 @@ var TelemetryController = Object.freeze(
   },
 
   /**
-   * Create an uninstall ping and write it to disk, replacing any already present.
-   * This is stored independently from other pings, and only read by
-   * the Windows uninstaller.
-   *
-   * WINDOWS ONLY, does nothing and resolves immediately on other platforms.
-   *
-   * @return {Promise} Resolved when the ping has been saved.
-   */
-  saveUninstallPing() {
-    return Impl.saveUninstallPing();
-  },
-
-  /**
    * Allows the sync ping to tell the controller that it is initializing, so
    * should be included in the orderly shutdown process.
    *
@@ -717,29 +695,6 @@ var Impl = {
     return TelemetryStorage.removeAbortedSessionPing();
   },
 
-  async saveUninstallPing() {
-    if (AppConstants.platform != "win") {
-      return undefined;
-    }
-
-    this._log.trace("saveUninstallPing");
-
-    let payload = {};
-    try {
-      payload.otherInstalls = UninstallPing.getOtherInstallsCount();
-      this._log.info(
-        "saveUninstallPing - otherInstalls",
-        payload.otherInstalls
-      );
-    } catch (e) {
-      this._log.warn("saveUninstallPing - getOtherInstallCount failed", e);
-    }
-    const options = { addClientId: true, addEnvironment: true };
-    const pingData = this.assemblePing(PING_TYPE_UNINSTALL, payload, options);
-
-    return TelemetryStorage.saveUninstallPing(pingData);
-  },
-
   /**
    * This triggers basic telemetry initialization and schedules a full initialized for later
    * for performance reasons.
@@ -787,8 +742,6 @@ var Impl = {
       return Promise.resolve();
     }
 
-    this._attachObservers();
-
     // Perform a lightweight, early initialization for the component, just registering
     // a few observers and initializing the session.
     TelemetrySession.earlyInit(this._testMode);
@@ -803,10 +756,6 @@ var Impl = {
     // lead to some stale client ids.
     this._clientID = ClientID.getCachedClientID();
 
-    // Init the update ping telemetry as early as possible. This won't have
-    // an impact on startup.
-    UpdatePing.earlyInit();
-
     // Delay full telemetry initialization to give the browser time to
     // run various late initializers. Otherwise our gathered memory
     // footprint and other numbers would be too optimistic.
@@ -822,10 +771,7 @@ var Impl = {
           this._clientID = await ClientID.getClientID();
 
           // Fix-up a canary client ID if detected.
-          const uploadEnabled = Services.prefs.getBoolPref(
-            TelemetryUtils.Preferences.FhrUploadEnabled,
-            false
-          );
+          const uploadEnabled = false;
           if (uploadEnabled && this._clientID == Utils.knownClientID) {
             this._log.trace(
               "Upload enabled, but got canary client ID. Resetting."
@@ -846,17 +792,6 @@ var Impl = {
           await TelemetrySession.delayedInit();
           await Services.telemetry.delayedInit();
 
-          if (
-            Services.prefs.getBoolPref(
-              TelemetryUtils.Preferences.NewProfilePingEnabled,
-              false
-            ) &&
-            !TelemetrySession.newProfilePingSent
-          ) {
-            // Kick off the scheduling of the new-profile ping.
-            this.scheduleNewProfilePing();
-          }
-
           // Purge the pings archive by removing outdated pings. We don't wait for
           // this task to complete, but TelemetryStorage blocks on it during
           // shutdown.
@@ -867,35 +802,6 @@ var Impl = {
           // in the future.
           TelemetryStorage.removeFHRDatabase();
 
-          // The init sequence is forced to run on shutdown for short sessions and
-          // we don't want to start TelemetryModules as the timer registration will fail.
-          if (!this._shuttingDown) {
-            // Report the modules loaded in the Firefox process.
-            TelemetryModules.start();
-
-            // Send coverage ping.
-            await CoveragePing.startup();
-
-            // Start the untrusted modules ping, which reports events where
-            // untrusted modules were loaded into the Firefox process.
-            if (AppConstants.platform == "win") {
-              TelemetryUntrustedModulesPing.start();
-            }
-          }
-
-          TelemetryEventPing.startup();
-          TelemetryPrioPing.startup();
-
-          if (uploadEnabled) {
-            await this.saveUninstallPing().catch(e =>
-              this._log.warn("_delayedInitTask - saveUninstallPing failed", e)
-            );
-          } else {
-            await TelemetryStorage.removeUninstallPings().catch(e =>
-              this._log.warn("_delayedInitTask - saveUninstallPing", e)
-            );
-          }
-
           this._delayedInitTaskDeferred.resolve();
         } catch (e) {
           this._delayedInitTaskDeferred.reject(e);
@@ -927,8 +833,6 @@ var Impl = {
     let now = () => " " + (TelemetryUtils.monotonicNow() - start);
     this._shutdownStep = "_cleanupOnShutdown begin " + now();
 
-    this._detachObservers();
-
     // Now do an orderly shutdown.
     try {
       if (this._delayedNewPingTask) {
@@ -936,14 +840,6 @@ var Impl = {
         await this._delayedNewPingTask.finalize();
       }
 
-      this._shutdownStep = "Update" + now();
-      UpdatePing.shutdown();
-
-      this._shutdownStep = "Event" + now();
-      TelemetryEventPing.shutdown();
-      this._shutdownStep = "Prio" + now();
-      await TelemetryPrioPing.shutdown();
-
       // Shutdown the sync ping if it is initialized - this is likely, but not
       // guaranteed, to submit a "shutdown" sync ping.
       if (this._fnSyncPingShutdown) {
@@ -961,10 +857,6 @@ var Impl = {
       this._shutdownStep = "TelemetrySend" + now();
       await TelemetrySend.shutdown();
 
-      // Send latest data.
-      this._shutdownStep = "Health ping" + now();
-      await TelemetryHealthPing.shutdown();
-
       this._shutdownStep = "TelemetrySession" + now();
       await TelemetrySession.shutdown();
       this._shutdownStep = "Services.telemetry" + now();
@@ -1042,10 +934,6 @@ var Impl = {
       case "profile-after-change":
         // profile-after-change is only registered for chrome processes.
         return this.setupTelemetry();
-      case "nsPref:changed":
-        if (aData == TelemetryUtils.Preferences.FhrUploadEnabled) {
-          return this._onUploadPrefChange();
-        }
     }
     return undefined;
   },
@@ -1076,122 +964,8 @@ var Impl = {
     };
   },
 
-  /**
-   * Called whenever the FHR Upload preference changes (e.g. when user disables FHR from
-   * the preferences panel), this triggers sending the "deletion-request" ping.
-   */
-  _onUploadPrefChange() {
-    const uploadEnabled = Services.prefs.getBoolPref(
-      TelemetryUtils.Preferences.FhrUploadEnabled,
-      false
-    );
-    if (uploadEnabled) {
-      this._log.trace(
-        "_onUploadPrefChange - upload was enabled again. Resetting client ID"
-      );
-
-      // Delete cached client ID immediately, so other usage is forced to refetch it.
-      this._clientID = null;
-
-      // Generate a new client ID and make sure this module uses the new version
-      let p = (async () => {
-        await ClientID.removeClientID();
-        let id = await ClientID.getClientID();
-        this._clientID = id;
-        Services.telemetry.scalarSet("telemetry.data_upload_optin", true);
-
-        await this.saveUninstallPing().catch(e =>
-          this._log.warn("_onUploadPrefChange - saveUninstallPing failed", e)
-        );
-      })();
-
-      this._shutdownBarrier.client.addBlocker(
-        "TelemetryController: resetting client ID after data upload was enabled",
-        p
-      );
-
-      return;
-    }
-
-    let p = (async () => {
-      try {
-        // 1. Cancel the current pings.
-        // 2. Clear unpersisted pings
-        await TelemetrySend.clearCurrentPings();
-
-        // 3. Remove all pending pings
-        await TelemetryStorage.removeAppDataPings();
-        await TelemetryStorage.runRemovePendingPingsTask();
-        await TelemetryStorage.removeUninstallPings();
-      } catch (e) {
-        this._log.error(
-          "_onUploadPrefChange - error clearing pending pings",
-          e
-        );
-      } finally {
-        // 4. Reset session and subsession counter
-        TelemetrySession.resetSubsessionCounter();
-
-        // 5. Collect any additional identifiers we want to send in the
-        // deletion request.
-        const scalars = Services.telemetry.getSnapshotForScalars(
-          "deletion-request",
-          /* clear */ true
-        );
-
-        // 6. Set ClientID to a known value
-        let oldClientId = await ClientID.getClientID();
-        await ClientID.setCanaryClientID();
-        this._clientID = await ClientID.getClientID();
-
-        // 7. Send the deletion-request ping.
-        this._log.trace("_onUploadPrefChange - Sending deletion-request ping.");
-        this.submitExternalPing(
-          PING_TYPE_DELETION_REQUEST,
-          { scalars },
-          { overrideClientId: oldClientId }
-        );
-        this._deletionRequestPingSubmittedPromise = null;
-      }
-    })();
-
-    this._deletionRequestPingSubmittedPromise = p;
-    this._shutdownBarrier.client.addBlocker(
-      "TelemetryController: removing pending pings after data upload was disabled",
-      p
-    );
-
-    Services.obs.notifyObservers(
-      null,
-      TelemetryUtils.TELEMETRY_UPLOAD_DISABLED_TOPIC
-    );
-  },
-
   QueryInterface: ChromeUtils.generateQI(["nsISupportsWeakReference"]),
 
-  _attachObservers() {
-    if (TelemetryControllerBase.IS_UNIFIED_TELEMETRY) {
-      // Watch the FHR upload setting to trigger "deletion-request" pings.
-      Services.prefs.addObserver(
-        TelemetryUtils.Preferences.FhrUploadEnabled,
-        this,
-        true
-      );
-    }
-  },
-
-  /**
-   * Remove the preference observer to avoid leaks.
-   */
-  _detachObservers() {
-    if (TelemetryControllerBase.IS_UNIFIED_TELEMETRY) {
-      Services.prefs.removeObserver(
-        TelemetryUtils.Preferences.FhrUploadEnabled,
-        this
-      );
-    }
-  },
-
   /**
    * Allows waiting for TelemetryControllers delayed initialization to complete.
    * This will complete before TelemetryController is shutting down.
@@ -1223,7 +997,6 @@ var Impl = {
   async reset() {
     this._clientID = null;
     this._fnSyncPingShutdown = null;
-    this._detachObservers();
 
     let sessionReset = TelemetrySession.testReset();
 
@@ -1247,75 +1020,6 @@ var Impl = {
   },
 
   /**
-   * Schedule sending the "new-profile" ping.
-   */
-  scheduleNewProfilePing() {
-    this._log.trace("scheduleNewProfilePing");
-
-    const sendDelay = Services.prefs.getIntPref(
-      TelemetryUtils.Preferences.NewProfilePingDelay,
-      NEWPROFILE_PING_DEFAULT_DELAY
-    );
-
-    this._delayedNewPingTask = new DeferredTask(async () => {
-      try {
-        await this.sendNewProfilePing();
-      } finally {
-        this._delayedNewPingTask = null;
-      }
-    }, sendDelay);
-
-    this._delayedNewPingTask.arm();
-  },
-
-  /**
-   * Generate and send the new-profile ping
-   */
-  async sendNewProfilePing() {
-    this._log.trace(
-      "sendNewProfilePing - shutting down: " + this._shuttingDown
-    );
-
-    const scalars = Services.telemetry.getSnapshotForScalars(
-      "new-profile",
-      /* clear */ true
-    );
-
-    // Generate the payload.
-    const payload = {
-      reason: this._shuttingDown ? "shutdown" : "startup",
-      processes: {
-        parent: {
-          scalars: scalars.parent,
-        },
-      },
-    };
-
-    // Generate and send the "new-profile" ping. This uses the
-    // pingsender if we're shutting down.
-    let options = {
-      addClientId: true,
-      addEnvironment: true,
-      usePingSender: this._shuttingDown,
-    };
-    // TODO: we need to be smarter about when to send the ping (and save the
-    // state to file). |requestIdleCallback| is currently only accessible
-    // through DOM. See bug 1361996.
-    await TelemetryController.submitExternalPing(
-      "new-profile",
-      payload,
-      options
-    ).then(
-      () => TelemetrySession.markNewProfilePingSent(),
-      e =>
-        this._log.error(
-          "sendNewProfilePing - failed to submit new-profile ping",
-          e
-        )
-    );
-  },
-
-  /**
    * Register 'dynamic builtin' probes from the JSON definition files.
    * This is needed to support adding new probes in developer builds
    * without rebuilding the whole codebase.
diff --git a/toolkit/components/telemetry/app/TelemetryReportingPolicy.jsm b/toolkit/components/telemetry/app/TelemetryReportingPolicy.jsm
--- a/toolkit/components/telemetry/app/TelemetryReportingPolicy.jsm
+++ b/toolkit/components/telemetry/app/TelemetryReportingPolicy.jsm
@@ -258,11 +258,7 @@ var TelemetryReportingPolicyImpl = {
    * false, we never request upload or deletion.
    */
   get dataSubmissionEnabled() {
-    // Default is true because we are opt-out.
-    return Services.prefs.getBoolPref(
-      TelemetryUtils.Preferences.DataSubmissionEnabled,
-      true
-    );
+    return false;
   },
 
   get currentPolicyVersion() {
@@ -352,9 +348,6 @@ var TelemetryReportingPolicyImpl = {
 
     // Migrate the data choices infobar, if needed.
     this._migratePreferences();
-
-    // Add the event observers.
-    Services.obs.addObserver(this, "sessionstore-windows-restored");
   },
 
   /**
@@ -363,19 +356,10 @@ var TelemetryReportingPolicyImpl = {
   shutdown() {
     this._log.trace("shutdown");
 
-    this._detachObservers();
-
     Policy.clearShowInfobarTimeout(this._startupNotificationTimerId);
   },
 
   /**
-   * Detach the observers that were attached during setup.
-   */
-  _detachObservers() {
-    Services.obs.removeObserver(this, "sessionstore-windows-restored");
-  },
-
-  /**
    * Check if we are allowed to upload data. In order to submit data both these conditions
    * should be true:
    * - The data submission preference should be true.
@@ -384,29 +368,11 @@ var TelemetryReportingPolicyImpl = {
    * @return {Boolean} True if we are allowed to upload data, false otherwise.
    */
   canUpload() {
-    // If data submission is disabled, there's no point in showing the infobar. Just
-    // forbid to upload.
-    if (!this.dataSubmissionEnabled) {
       return false;
-    }
-
-    // Submission is enabled. We enable upload if user is notified or we need to bypass
-    // the policy.
-    const bypassNotification = Services.prefs.getBoolPref(
-      TelemetryUtils.Preferences.BypassNotification,
-      false
-    );
-    return this.isUserNotifiedOfCurrentPolicy || bypassNotification;
   },
 
   isFirstRun() {
-    if (this._isFirstRun === undefined) {
-      this._isFirstRun = Services.prefs.getBoolPref(
-        TelemetryUtils.Preferences.FirstRun,
-        true
-      );
-    }
-    return this._isFirstRun;
+    return false;
   },
 
   /**
@@ -420,52 +386,6 @@ var TelemetryReportingPolicyImpl = {
   },
 
   /**
-   * Determine whether the user should be notified.
-   */
-  _shouldNotify() {
-    if (!this.dataSubmissionEnabled) {
-      this._log.trace(
-        "_shouldNotify - Data submission disabled by the policy."
-      );
-      return false;
-    }
-
-    const bypassNotification = Services.prefs.getBoolPref(
-      TelemetryUtils.Preferences.BypassNotification,
-      false
-    );
-    if (this.isUserNotifiedOfCurrentPolicy || bypassNotification) {
-      this._log.trace(
-        "_shouldNotify - User already notified or bypassing the policy."
-      );
-      return false;
-    }
-
-    if (this._notificationInProgress) {
-      this._log.trace(
-        "_shouldNotify - User not notified, notification already in progress."
-      );
-      return false;
-    }
-
-    return true;
-  },
-
-  /**
-   * Show the data choices infobar if needed.
-   */
-  _showInfobar() {
-    if (!this._shouldNotify()) {
-      return;
-    }
-
-    this._log.trace("_showInfobar - User not notified, notifying now.");
-    this._notificationInProgress = true;
-    let request = new NotifyPolicyRequest(this._log);
-    Observers.notify("datareporting:notify-data-policy:request", request);
-  },
-
-  /**
    * Called when the user is notified with the infobar or otherwise.
    */
   _userNotified() {
@@ -485,112 +405,4 @@ var TelemetryReportingPolicyImpl = {
     // is no longer in progress.
     this._notificationInProgress = false;
   },
-
-  /**
-   * Try to open the privacy policy in a background tab instead of showing the infobar.
-   */
-  _openFirstRunPage() {
-    if (!this._shouldNotify()) {
-      return false;
-    }
-
-    let firstRunPolicyURL = Services.prefs.getStringPref(
-      TelemetryUtils.Preferences.FirstRunURL,
-      ""
-    );
-    if (!firstRunPolicyURL) {
-      return false;
-    }
-    firstRunPolicyURL = Services.urlFormatter.formatURL(firstRunPolicyURL);
-
-    const { BrowserWindowTracker } = ChromeUtils.import(
-      "resource:///modules/BrowserWindowTracker.jsm"
-    );
-    let win = BrowserWindowTracker.getTopWindow();
-
-    if (!win) {
-      this._log.info(
-        "Couldn't find browser window to open first-run page. Falling back to infobar."
-      );
-      return false;
-    }
-
-    // We'll consider the user notified once the privacy policy has been loaded
-    // in a background tab even if that tab hasn't been selected.
-    let tab;
-    let progressListener = {};
-    progressListener.onStateChange = (
-      aBrowser,
-      aWebProgress,
-      aRequest,
-      aStateFlags,
-      aStatus
-    ) => {
-      if (
-        aWebProgress.isTopLevel &&
-        tab &&
-        tab.linkedBrowser == aBrowser &&
-        aStateFlags & Ci.nsIWebProgressListener.STATE_STOP &&
-        aStateFlags & Ci.nsIWebProgressListener.STATE_IS_NETWORK
-      ) {
-        let uri = aBrowser.documentURI;
-        if (
-          uri &&
-          !/^about:(blank|neterror|certerror|blocked)/.test(uri.spec)
-        ) {
-          this._userNotified();
-        } else {
-          this._log.info(
-            "Failed to load first-run page. Falling back to infobar."
-          );
-          this._showInfobar();
-        }
-        removeListeners();
-      }
-    };
-
-    let removeListeners = () => {
-      win.removeEventListener("unload", removeListeners);
-      win.gBrowser.removeTabsProgressListener(progressListener);
-    };
-
-    win.addEventListener("unload", removeListeners);
-    win.gBrowser.addTabsProgressListener(progressListener);
-
-    tab = win.gBrowser.loadOneTab(firstRunPolicyURL, {
-      inBackground: true,
-      triggeringPrincipal: Services.scriptSecurityManager.getSystemPrincipal(),
-    });
-    return true;
-  },
-
-  observe(aSubject, aTopic, aData) {
-    if (aTopic != "sessionstore-windows-restored") {
-      return;
-    }
-
-    if (this.isFirstRun()) {
-      // We're performing the first run, flip firstRun preference for subsequent runs.
-      Services.prefs.setBoolPref(TelemetryUtils.Preferences.FirstRun, false);
-
-      try {
-        if (this._openFirstRunPage()) {
-          return;
-        }
-      } catch (e) {
-        this._log.error("Failed to open privacy policy tab: " + e);
-      }
-    }
-
-    // Show the info bar.
-    const delay = this.isFirstRun()
-      ? NOTIFICATION_DELAY_FIRST_RUN_MSEC
-      : NOTIFICATION_DELAY_NEXT_RUNS_MSEC;
-
-    this._startupNotificationTimerId = Policy.setShowInfobarTimeout(
-      // Calling |canUpload| eventually shows the infobar, if needed.
-      () => this._showInfobar(),
-      delay
-    );
-  },
 };
diff --git a/toolkit/components/telemetry/app/TelemetryScheduler.jsm b/toolkit/components/telemetry/app/TelemetryScheduler.jsm
--- a/toolkit/components/telemetry/app/TelemetryScheduler.jsm
+++ b/toolkit/components/telemetry/app/TelemetryScheduler.jsm
@@ -20,10 +20,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 const { clearTimeout, setTimeout } = ChromeUtils.import(
   "resource://gre/modules/Timer.jsm"
 );
-// Other pings
-const { TelemetryPrioPing } = ChromeUtils.import(
-  "resource://gre/modules/PrioPing.jsm"
-);
 
 XPCOMUtils.defineLazyServiceGetters(this, {
   idleService: ["@mozilla.org/widget/useridleservice;1", "nsIUserIdleService"],
@@ -222,22 +218,6 @@ var TelemetryScheduler = {
   },
 
   /**
-   * Checks if we can send a regular ping or not.
-   * @param {Object} nowDate A date object.
-   * @return {Boolean} True if we can send the regular pings, false otherwise.
-   */
-  _isPeriodicPingDue(nowDate) {
-    // The periodic ping is not due if we already sent one today.
-    if (this._sentPingToday(this._lastPeriodicPingTime, nowDate)) {
-      this._log.trace("_isPeriodicPingDue - already sent one today");
-      return false;
-    }
-
-    this._log.trace("_isPeriodicPingDue - is due");
-    return true;
-  },
-
-  /**
    * An helper function to save an aborted-session ping.
    * @param {Number} now The current time, in milliseconds.
    * @param {Object} [competingPayload=null] If we are coalescing the daily and the
@@ -364,15 +344,6 @@ var TelemetryScheduler = {
 
     // Check if the daily ping is due.
     const shouldSendDaily = this._isDailyPingDue(nowDate);
-    // Check if other regular pings are due.
-    const shouldSendPeriodic = this._isPeriodicPingDue(nowDate);
-
-    if (shouldSendPeriodic) {
-      this._log.trace("_schedulerTickLogic - Periodic ping due.");
-      this._lastPeriodicPingTime = now;
-      // Send other pings.
-      TelemetryPrioPing.periodicPing();
-    }
 
     if (shouldSendDaily) {
       this._log.trace("_schedulerTickLogic - Daily ping due.");
diff --git a/toolkit/components/telemetry/app/TelemetrySend.jsm b/toolkit/components/telemetry/app/TelemetrySend.jsm
--- a/toolkit/components/telemetry/app/TelemetrySend.jsm
+++ b/toolkit/components/telemetry/app/TelemetrySend.jsm
@@ -51,11 +51,6 @@ ChromeUtils.defineModuleGetter(
   "resource://gre/modules/TelemetryReportingPolicy.jsm"
 );
 ChromeUtils.defineModuleGetter(this, "OS", "resource://gre/modules/osfile.jsm");
-ChromeUtils.defineModuleGetter(
-  this,
-  "TelemetryHealthPing",
-  "resource://gre/modules/HealthPing.jsm"
-);
 
 const Utils = TelemetryUtils;
 
@@ -272,7 +267,6 @@ var TelemetrySend = {
    *   2. wanting to be sent using pingsender.
    */
   flushPingSenderBatch() {
-    TelemetrySendImpl.flushPingSenderBatch();
   },
 
   /**
@@ -299,7 +293,7 @@ var TelemetrySend = {
    * @return {Boolean} True if pings can be send to the servers, false otherwise.
    */
   sendingEnabled(ping = null) {
-    return TelemetrySendImpl.sendingEnabled(ping);
+    return false;
   },
 
   /**
@@ -357,32 +351,6 @@ var TelemetrySend = {
   getShutdownState() {
     return TelemetrySendImpl.getShutdownState();
   },
-
-  /**
-   * Send a ping using the ping sender.
-   * This method will not wait for the ping to be sent, instead it will return
-   * as soon as the pingsender program has been launched.
-   *
-   * This method is currently exposed here only for testing purposes as it's
-   * only used internally.
-   *
-   * @param {Array}<Object> pings An array of objects holding url / path pairs
-   *        for each ping to be sent. The URL represent the telemetry server the
-   *        ping will be sent to and the path points to the ping data. The ping
-   *        data files will be deleted if the pings have been submitted
-   *        successfully.
-   * @param {callback} observer A function called with parameters
-   *        (subject, topic, data) and a topic of "process-finished" or
-   *        "process-failed" after pingsender completion.
-   *
-   * @throws NS_ERROR_FAILURE if we couldn't find or run the pingsender
-   *         executable.
-   * @throws NS_ERROR_NOT_IMPLEMENTED on Android as the pingsender is not
-   *         available.
-   */
-  testRunPingSender(pings, observer) {
-    return TelemetrySendImpl.runPingSender(pings, observer);
-  },
 };
 
 var CancellableTimeout = {
@@ -742,19 +710,6 @@ var TelemetrySendImpl = {
     TOPIC_PROFILE_CHANGE_NET_TEARDOWN,
   ],
 
-  OBSERVED_PREFERENCES: [
-    TelemetryUtils.Preferences.TelemetryEnabled,
-    TelemetryUtils.Preferences.FhrUploadEnabled,
-  ],
-
-  // Whether sending pings has been overridden.
-  get _overrideOfficialCheck() {
-    return Services.prefs.getBoolPref(
-      TelemetryUtils.Preferences.OverrideOfficialCheck,
-      false
-    );
-  },
-
   get _log() {
     if (!this._logger) {
       this._logger = Log.repository.getLoggerWithMessagePrefix(
@@ -803,14 +758,7 @@ var TelemetrySendImpl = {
       TelemetryUtils.Preferences.Server,
       undefined
     );
-    this._sendingEnabled = true;
-
-    // Annotate crash reports so that crash pings are sent correctly and listen
-    // to pref changes to adjust the annotations accordingly.
-    for (let pref of this.OBSERVED_PREFERENCES) {
-      Services.prefs.addObserver(pref, this, true);
-    }
-    this._annotateCrashReport();
+    this._sendingEnabled = false;
 
     // Check the pending pings on disk now.
     try {
@@ -890,13 +838,6 @@ var TelemetrySendImpl = {
   async shutdown() {
     this._shutdown = true;
 
-    for (let pref of this.OBSERVED_PREFERENCES) {
-      // FIXME: When running tests this causes errors to be printed out if
-      // TelemetrySend.shutdown() is called twice in a row without calling
-      // TelemetrySend.setup() in-between.
-      Services.prefs.removeObserver(pref, this);
-    }
-
     for (let topic of this.OBSERVER_TOPICS) {
       try {
         Services.obs.removeObserver(this, topic);
@@ -924,16 +865,6 @@ var TelemetrySendImpl = {
     await this._persistCurrentPings();
   },
 
-  flushPingSenderBatch() {
-    if (this._pingSenderBatch.length === 0) {
-      return;
-    }
-    this._log.trace(
-      `flushPingSenderBatch - Sending ${this._pingSenderBatch.length} pings.`
-    );
-    this.runPingSender(this._pingSenderBatch);
-  },
-
   reset() {
     this._log.trace("reset");
 
@@ -941,7 +872,7 @@ var TelemetrySendImpl = {
     this._currentPings = new Map();
     this._tooLateToSend = false;
     this._isOSShutdown = false;
-    this._sendingEnabled = true;
+    this._sendingEnabled = false;
 
     const histograms = [
       "TELEMETRY_SUCCESS",
@@ -997,96 +928,14 @@ var TelemetrySendImpl = {
           setOSShutdown();
         }
         break;
-      case PREF_CHANGED_TOPIC:
-        if (this.OBSERVED_PREFERENCES.includes(data)) {
-          this._annotateCrashReport();
-        }
-        break;
       case TOPIC_PROFILE_CHANGE_NET_TEARDOWN:
         this._tooLateToSend = true;
         break;
     }
   },
 
-  /**
-   * Spawn the PingSender process that sends a ping. This function does
-   * not return an error or throw, it only logs an error.
-   *
-   * Even if the function doesn't fail, it doesn't mean that the ping was
-   * successfully sent, as we have no control over the spawned process. If it,
-   * succeeds, the ping is eventually removed from the disk to prevent duplicated
-   * submissions.
-   *
-   * @param {String} pingId The id of the ping to send.
-   * @param {String} submissionURL The complete Telemetry-compliant URL for the ping.
-   */
-  _sendWithPingSender(pingId, submissionURL) {
-    this._log.trace(
-      "_sendWithPingSender - sending " + pingId + " to " + submissionURL
-    );
-    try {
-      const pingPath = OS.Path.join(TelemetryStorage.pingDirectoryPath, pingId);
-      if (this._tooLateToSend) {
-        // We're in shutdown. Batch pings destined for pingsender.
-        this._log.trace("_sendWithPingSender - too late to send. Batching.");
-        this._pingSenderBatch.push({ url: submissionURL, path: pingPath });
-        return;
-      }
-      this.runPingSender([{ url: submissionURL, path: pingPath }]);
-    } catch (e) {
-      this._log.error("_sendWithPingSender - failed to submit ping", e);
-    }
-  },
-
   submitPing(ping, options) {
-    this._log.trace(
-      "submitPing - ping id: " +
-        ping.id +
-        ", options: " +
-        JSON.stringify(options)
-    );
-
-    if (!this.sendingEnabled(ping)) {
-      this._log.trace("submitPing - Telemetry is not allowed to send pings.");
       return Promise.resolve();
-    }
-
-    // Send the ping using the PingSender, if requested and the user was
-    // notified of our policy. We don't support the pingsender on Android,
-    // so ignore this option on that platform (see bug 1335917).
-    // Moreover, if the OS is shutting down, we don't want to spawn the
-    // pingsender as it could unnecessarily slow down OS shutdown.
-    // Additionally, it could be be killed before it can complete its tasks,
-    // for example after successfully sending the ping but before removing
-    // the copy from the disk, resulting in receiving duplicate pings when
-    // Firefox restarts.
-    if (
-      options.usePingSender &&
-      !this._isOSShutdown &&
-      TelemetryReportingPolicy.canUpload() &&
-      AppConstants.platform != "android"
-    ) {
-      const url = this._buildSubmissionURL(ping);
-      // Serialize the ping to the disk and then spawn the PingSender.
-      return savePing(ping).then(() => this._sendWithPingSender(ping.id, url));
-    }
-
-    if (!this.canSendNow) {
-      // Sending is disabled or throttled, add this to the persisted pending pings.
-      this._log.trace(
-        "submitPing - can't send ping now, persisting to disk - " +
-          "canSendNow: " +
-          this.canSendNow
-      );
-      return savePing(ping);
-    }
-
-    // Let the scheduler trigger sending pings if possible.
-    // As a safety mechanism, this resets any currently active throttling.
-    this._log.trace("submitPing - can send pings, trying to send now");
-    this._currentPings.set(ping.id, ping);
-    SendScheduler.triggerSendingPings(true);
-    return Promise.resolve();
   },
 
   /**
@@ -1363,7 +1212,6 @@ var TelemetrySendImpl = {
       // We don't need to call |request.abort()| as it was not sent yet.
       this._pendingPingRequests.delete(id);
 
-      TelemetryHealthPing.recordDiscardedPing(ping.type);
       return { promise: TelemetryStorage.removePendingPing(id) };
     }
 
@@ -1472,8 +1320,6 @@ var TelemetrySendImpl = {
         failure = XHR_ERROR_TYPE[request.errorCode];
       }
 
-      TelemetryHealthPing.recordSendFailure(failure);
-
       Services.telemetry
         .getHistogramById("TELEMETRY_SEND_FAILURE_TYPE")
         .add(failure);
@@ -1579,30 +1425,7 @@ var TelemetrySendImpl = {
    * @return {Boolean} True if pings can be send to the servers, false otherwise.
    */
   sendingEnabled(ping = null) {
-    // We only send pings from official builds, but allow overriding this for tests.
-    if (
-      !Services.telemetry.isOfficialTelemetry &&
-      !this._testMode &&
-      !this._overrideOfficialCheck
-    ) {
       return false;
-    }
-
-    // With unified Telemetry, the FHR upload setting controls whether we can send pings.
-    // The Telemetry pref enables sending extended data sets instead.
-    if (IS_UNIFIED_TELEMETRY) {
-      // "deletion-request" pings are sent once even if the upload is disabled.
-      if (ping && isDeletionRequestPing(ping)) {
-        return true;
-      }
-      return Services.prefs.getBoolPref(
-        TelemetryUtils.Preferences.FhrUploadEnabled,
-        false
-      );
-    }
-
-    // Without unified Telemetry, the Telemetry enabled pref controls ping sending.
-    return Utils.isTelemetryEnabled;
   },
 
   /**
@@ -1666,34 +1489,4 @@ var TelemetrySendImpl = {
       schedulerState: SendScheduler.getShutdownState(),
     };
   },
-
-  runPingSender(pings, observer) {
-    if (AppConstants.platform === "android") {
-      throw Components.Exception("", Cr.NS_ERROR_NOT_IMPLEMENTED);
-    }
-
-    let suppressPingsender = Services.prefs.getBoolPref(
-      "toolkit.telemetry.testing.suppressPingsender",
-      false
-    );
-    if (suppressPingsender) {
-      this._log.trace("Silently skipping pingsender call in automation");
-      return;
-    }
-
-    const exeName =
-      AppConstants.platform === "win" ? "pingsender.exe" : "pingsender";
-
-    let exe = Services.dirsvc.get("GreBinD", Ci.nsIFile);
-    exe.append(exeName);
-
-    let params = pings.flatMap(ping => [ping.url, ping.path]);
-    let process = Cc["@mozilla.org/process/util;1"].createInstance(
-      Ci.nsIProcess
-    );
-    process.init(exe);
-    process.startHidden = true;
-    process.noShell = true;
-    process.runAsync(params, params.length, observer);
-  },
 };
diff --git a/toolkit/components/telemetry/app/TelemetryStorage.jsm b/toolkit/components/telemetry/app/TelemetryStorage.jsm
--- a/toolkit/components/telemetry/app/TelemetryStorage.jsm
+++ b/toolkit/components/telemetry/app/TelemetryStorage.jsm
@@ -49,11 +49,6 @@ ChromeUtils.defineModuleGetter(
   "CommonUtils",
   "resource://services-common/utils.js"
 );
-ChromeUtils.defineModuleGetter(
-  this,
-  "TelemetryHealthPing",
-  "resource://gre/modules/HealthPing.jsm"
-);
 // Maxmimum time, in milliseconds, archive pings should be retained.
 const MAX_ARCHIVED_PINGS_RETENTION_MS = 60 * 24 * 60 * 60 * 1000; // 60 days
 
@@ -1536,9 +1531,6 @@ var TelemetryStorageImpl = {
       ).add(Math.floor(fileSize / 1024 / 1024));
       Telemetry.getHistogramById("TELEMETRY_PING_SIZE_EXCEEDED_PENDING").add();
 
-      // Currently we don't have the ping type available without loading the ping from disk.
-      // Bug 1384903 will fix that.
-      TelemetryHealthPing.recordDiscardedPing("<unknown>");
       throw new Error(
         "loadPendingPing - exceeded the maximum ping size: " + fileSize
       );
@@ -1848,10 +1840,6 @@ var TelemetryStorageImpl = {
             Telemetry.getHistogramById(
               "TELEMETRY_PING_SIZE_EXCEEDED_PENDING"
             ).add();
-
-            // Currently we don't have the ping type available without loading the ping from disk.
-            // Bug 1384903 will fix that.
-            TelemetryHealthPing.recordDiscardedPing("<unknown>");
           }
           continue;
         }
diff --git a/toolkit/components/telemetry/app/TelemetryUtils.jsm b/toolkit/components/telemetry/app/TelemetryUtils.jsm
--- a/toolkit/components/telemetry/app/TelemetryUtils.jsm
+++ b/toolkit/components/telemetry/app/TelemetryUtils.jsm
@@ -118,7 +118,7 @@ var TelemetryUtils = {
    * it correctly evaluates to a boolean type.
    */
   get isTelemetryEnabled() {
-    return TelemetryControllerBase.isTelemetryEnabled;
+    return false;
   },
 
   /**
diff --git a/toolkit/components/telemetry/components.conf b/toolkit/components/telemetry/components.conf
--- a/toolkit/components/telemetry/components.conf
+++ b/toolkit/components/telemetry/components.conf
@@ -6,13 +6,6 @@
 
 Classes = [
     {
-        'cid': '{117b219f-92fe-4bd2-a21b-95a342a9d474}',
-        'contract_ids': ['@mozilla.org/base/telemetry-startup;1'],
-        'jsm': 'resource://gre/modules/TelemetryStartup.jsm',
-        'constructor': 'TelemetryStartup',
-        'processes': ProcessSelector.MAIN_PROCESS_ONLY,
-    },
-    {
         'cid': '{efc1415c-5708-41cc-8226-82bf1d3bee16}',
         'contract_ids': ['@mozilla.org/base/telemetry-controller-content;1'],
         'jsm': 'resource://gre/modules/TelemetryControllerContent.jsm',
diff --git a/toolkit/components/telemetry/core/Stopwatch.cpp b/toolkit/components/telemetry/core/Stopwatch.cpp
--- a/toolkit/components/telemetry/core/Stopwatch.cpp
+++ b/toolkit/components/telemetry/core/Stopwatch.cpp
@@ -238,67 +238,16 @@ Timers::~Timers() {
 
 JSObject* Timers::Get(JSContext* aCx, const nsAString& aHistogram,
                       bool aCreate) {
-  JSAutoRealm ar(aCx, mTimers);
-
-  JS::RootedValue histogram(aCx);
-  JS::RootedValue objs(aCx);
-
-  if (!xpc::NonVoidStringToJsval(aCx, aHistogram, &histogram) ||
-      !JS::MapGet(aCx, mTimers, histogram, &objs)) {
     return nullptr;
-  }
-  if (!objs.isObject()) {
-    if (aCreate) {
-      objs = JS::ObjectOrNullValue(JS::NewWeakMapObject(aCx));
-    }
-    if (!objs.isObject() || !JS::MapSet(aCx, mTimers, histogram, objs)) {
-      return nullptr;
-    }
-  }
-
-  return &objs.toObject();
 }
 
 TimerKeys* Timers::Get(JSContext* aCx, const nsAString& aHistogram,
                        JS::HandleObject aObj, bool aCreate) {
-  JSAutoRealm ar(aCx, mTimers);
-
-  JS::RootedObject objs(aCx, Get(aCx, aHistogram, aCreate));
-  if (!objs) {
     return nullptr;
-  }
-
-  // If no object is passed, use mTimers as a stand-in for a null object
-  // (which cannot be used as a weak map key).
-  JS::RootedObject obj(aCx, aObj ? aObj : mTimers);
-  if (!JS_WrapObject(aCx, &obj)) {
-    return nullptr;
-  }
-
-  RefPtr<TimerKeys> keys;
-  JS::RootedValue keysObj(aCx);
-  if (!JS::GetWeakMapEntry(aCx, objs, obj, &keysObj)) {
-    return nullptr;
-  }
-  if (!keysObj.isObject()) {
-    if (aCreate) {
-      keys = new TimerKeys();
-      Unused << nsContentUtils::WrapNative(aCx, keys, &keysObj);
-    }
-    if (!keysObj.isObject() || !JS::SetWeakMapEntry(aCx, objs, obj, keysObj)) {
-      return nullptr;
-    }
-  }
-
-  keys = do_QueryReflector(keysObj);
-  return keys;
 }
 
 Timer* Timers::Get(JSContext* aCx, const nsAString& aHistogram,
                    JS::HandleObject aObj, const nsAString& aKey, bool aCreate) {
-  if (RefPtr<TimerKeys> keys = Get(aCx, aHistogram, aObj, aCreate)) {
-    return keys->Get(aKey, aCreate);
-  }
   return nullptr;
 }
 
@@ -306,167 +255,42 @@ already_AddRefed<Timer> Timers::GetAndDe
                                              const nsAString& aHistogram,
                                              JS::HandleObject aObj,
                                              const nsAString& aKey) {
-  if (RefPtr<TimerKeys> keys = Get(aCx, aHistogram, aObj, false)) {
-    return keys->GetAndDelete(aKey);
-  }
   return nullptr;
 }
 
 bool Timers::Delete(JSContext* aCx, const nsAString& aHistogram,
                     JS::HandleObject aObj, const nsAString& aKey) {
-  if (RefPtr<TimerKeys> keys = Get(aCx, aHistogram, aObj, false)) {
-    return keys->Delete(aKey);
-  }
   return false;
 }
 
 int32_t Timers::TimeElapsed(JSContext* aCx, const nsAString& aHistogram,
                             JS::HandleObject aObj, const nsAString& aKey,
                             bool aCanceledOkay) {
-  RefPtr<Timer> timer = Get(aCx, aHistogram, aObj, aKey, false);
-  if (!timer) {
-    if (!aCanceledOkay && !mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "TelemetryStopwatch: requesting elapsed time for "
-                        "nonexisting stopwatch. Histogram: \"%s\", key: \"%s\"",
-                        NS_ConvertUTF16toUTF8(aHistogram).get(),
-                        NS_ConvertUTF16toUTF8(aKey).get()));
-    }
     return -1;
-  }
-
-  return timer->Elapsed();
 }
 
 bool Timers::Start(JSContext* aCx, const nsAString& aHistogram,
                    JS::HandleObject aObj, const nsAString& aKey,
                    bool aInSeconds) {
-  if (RefPtr<Timer> timer = Get(aCx, aHistogram, aObj, aKey)) {
-    if (timer->Started()) {
-      if (!mSuppressErrors) {
-        LogError(aCx,
-                 nsPrintfCString(
-                     "TelemetryStopwatch: key \"%s\" was already initialized",
-                     NS_ConvertUTF16toUTF8(aHistogram).get()));
-      }
-      Delete(aCx, aHistogram, aObj, aKey);
-    } else {
-      timer->Start(aInSeconds);
-      return true;
-    }
-  }
   return false;
 }
 
 int32_t Timers::Finish(JSContext* aCx, const nsAString& aHistogram,
                        JS::HandleObject aObj, const nsAString& aKey,
                        bool aCanceledOkay) {
-  RefPtr<Timer> timer = GetAndDelete(aCx, aHistogram, aObj, aKey);
-  if (!timer) {
-    if (!aCanceledOkay && !mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "TelemetryStopwatch: finishing nonexisting stopwatch. "
-                        "Histogram: \"%s\", key: \"%s\"",
-                        NS_ConvertUTF16toUTF8(aHistogram).get(),
-                        NS_ConvertUTF16toUTF8(aKey).get()));
-    }
     return -1;
-  }
-
-  int32_t delta = timer->Elapsed();
-  NS_ConvertUTF16toUTF8 histogram(aHistogram);
-  nsresult rv;
-  if (!aKey.IsVoid()) {
-    NS_ConvertUTF16toUTF8 key(aKey);
-    rv = TelemetryHistogram::Accumulate(histogram.get(), key, delta);
-  } else {
-    rv = TelemetryHistogram::Accumulate(histogram.get(), delta);
-  }
-  if (profiler_thread_is_being_profiled_for_markers()) {
-    nsCString markerText = histogram;
-    if (!aKey.IsVoid()) {
-      markerText.AppendLiteral(":");
-      markerText.Append(NS_ConvertUTF16toUTF8(aKey));
-    }
-    PROFILER_MARKER_TEXT("TelemetryStopwatch", OTHER,
-                         MarkerTiming::IntervalUntilNowFrom(timer->StartTime()),
-                         markerText);
-  }
-  if (NS_FAILED(rv) && rv != NS_ERROR_NOT_AVAILABLE && !mSuppressErrors) {
-    LogError(aCx, nsPrintfCString(
-                      "TelemetryStopwatch: failed to update the Histogram "
-                      "\"%s\", using key: \"%s\"",
-                      NS_ConvertUTF16toUTF8(aHistogram).get(),
-                      NS_ConvertUTF16toUTF8(aKey).get()));
-  }
-  return NS_SUCCEEDED(rv) ? delta : -1;
 }
 
 bool Timers::StartUserInteraction(JSContext* aCx,
                                   const nsAString& aUserInteraction,
                                   const nsACString& aValue,
                                   JS::HandleObject aObj) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  // Ensure that this ID maps to a UserInteraction that can be recorded
-  // for this product.
-  if (!TelemetryUserInteraction::CanRecord(aUserInteraction)) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction with name \"%s\" cannot be recorded.",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
-    return false;
-  }
-
-  if (aValue.Length() > USER_INTERACTION_VALUE_MAX_LENGTH) {
-    if (!mSuppressErrors) {
-      LogError(aCx,
-               nsPrintfCString(
-                   "UserInteraction with name \"%s\" cannot be recorded with"
-                   "a value of length greater than %d (%s)",
-                   NS_ConvertUTF16toUTF8(aUserInteraction).get(),
-                   USER_INTERACTION_VALUE_MAX_LENGTH,
-                   PromiseFlatCString(aValue).get()));
-    }
-    return false;
-  }
-
-  if (RefPtr<Timer> timer = Get(aCx, aUserInteraction, aObj, VoidString())) {
-    auto annotationTimers = mBHRAnnotationTimers.Lock();
-
-    if (timer->Started()) {
-      if (!mSuppressErrors) {
-        LogError(aCx,
-                 nsPrintfCString(
-                     "UserInteraction with name \"%s\" was already initialized",
-                     NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-      }
-      timer->removeFrom(*annotationTimers);
-      Delete(aCx, aUserInteraction, aObj, VoidString());
-      timer = Get(aCx, aUserInteraction, aObj, VoidString());
-
-      nsAutoString clobberText(aUserInteraction);
-      clobberText.AppendLiteral(u" (clobbered)");
-      timer->SetBHRAnnotation(clobberText, aValue);
-    } else {
-      timer->SetBHRAnnotation(aUserInteraction, aValue);
-    }
-
-    annotationTimers->insertBack(timer);
-    timer->Start(false);
-    return true;
-  }
   return false;
 }
 
 bool Timers::RunningUserInteraction(JSContext* aCx,
                                     const nsAString& aUserInteraction,
                                     JS::HandleObject aObj) {
-  if (RefPtr<Timer> timer =
-          Get(aCx, aUserInteraction, aObj, VoidString(), false /* aCreate */)) {
-    return timer->Started();
-  }
   return false;
 }
 
@@ -474,123 +298,19 @@ bool Timers::UpdateUserInteraction(JSCon
                                    const nsAString& aUserInteraction,
                                    const nsACString& aValue,
                                    JS::HandleObject aObj) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  // Ensure that this ID maps to a UserInteraction that can be recorded
-  // for this product.
-  if (!TelemetryUserInteraction::CanRecord(aUserInteraction)) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction with name \"%s\" cannot be recorded.",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
-    return false;
-  }
-
-  auto lock = mBHRAnnotationTimers.Lock();
-  if (RefPtr<Timer> timer = Get(aCx, aUserInteraction, aObj, VoidString())) {
-    if (!timer->Started()) {
-      if (!mSuppressErrors) {
-        LogError(aCx, nsPrintfCString(
-                          "UserInteraction with id \"%s\" was not initialized",
-                          NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-      }
-      return false;
-    }
-    timer->SetBHRAnnotation(aUserInteraction, aValue);
-    return true;
-  }
   return false;
 }
 
 bool Timers::FinishUserInteraction(
     JSContext* aCx, const nsAString& aUserInteraction, JS::HandleObject aObj,
     const dom::Optional<nsACString>& aAdditionalText) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  // Ensure that this ID maps to a UserInteraction that can be recorded
-  // for this product.
-  if (!TelemetryUserInteraction::CanRecord(aUserInteraction)) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction with id \"%s\" cannot be recorded.",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
     return false;
-  }
-
-  RefPtr<Timer> timer = GetAndDelete(aCx, aUserInteraction, aObj, VoidString());
-  if (!timer) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction: finishing nonexisting stopwatch. "
-                        "name: \"%s\"",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
-    return false;
-  }
-
-  if (profiler_thread_is_being_profiled_for_markers()) {
-    nsAutoCString markerText(timer->GetBHRAnnotationValue());
-    if (aAdditionalText.WasPassed()) {
-      markerText.Append(",");
-      markerText.Append(aAdditionalText.Value());
-    }
-
-    PROFILER_MARKER_TEXT(NS_ConvertUTF16toUTF8(aUserInteraction), OTHER,
-                         MarkerTiming::IntervalUntilNowFrom(timer->StartTime()),
-                         markerText);
-  }
-
-  // The Timer will be held alive by the RefPtr that's still in the LinkedList,
-  // so the automatic removal from the LinkedList from the LinkedListElement
-  // destructor will not occur. We must remove it manually from the LinkedList
-  // instead.
-  {
-    auto annotationTimers = mBHRAnnotationTimers.Lock();
-    timer->removeFrom(*annotationTimers);
-  }
-
-  return true;
 }
 
 bool Timers::CancelUserInteraction(JSContext* aCx,
                                    const nsAString& aUserInteraction,
                                    JS::HandleObject aObj) {
-  MOZ_ASSERT(NS_IsMainThread());
-
-  // Ensure that this ID maps to a UserInteraction that can be recorded
-  // for this product.
-  if (!TelemetryUserInteraction::CanRecord(aUserInteraction)) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction with id \"%s\" cannot be recorded.",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
     return false;
-  }
-
-  RefPtr<Timer> timer = GetAndDelete(aCx, aUserInteraction, aObj, VoidString());
-  if (!timer) {
-    if (!mSuppressErrors) {
-      LogError(aCx, nsPrintfCString(
-                        "UserInteraction: cancelling nonexisting stopwatch. "
-                        "name: \"%s\"",
-                        NS_ConvertUTF16toUTF8(aUserInteraction).get()));
-    }
-    return false;
-  }
-
-  // The Timer will be held alive by the RefPtr that's still in the LinkedList,
-  // so the automatic removal from the LinkedList from the LinkedListElement
-  // destructor will not occur. We must remove it manually from the LinkedList
-  // instead.
-  {
-    auto annotationTimers = mBHRAnnotationTimers.Lock();
-    timer->removeFrom(*annotationTimers);
-  }
-
-  return true;
 }
 
 void Timers::AnnotateHang(mozilla::BackgroundHangAnnotations& aAnnotations) {
diff --git a/toolkit/components/telemetry/core/Telemetry.cpp b/toolkit/components/telemetry/core/Telemetry.cpp
--- a/toolkit/components/telemetry/core/Telemetry.cpp
+++ b/toolkit/components/telemetry/core/Telemetry.cpp
@@ -41,7 +41,6 @@
 #include "mozilla/Likely.h"
 #include "mozilla/MathAlgorithms.h"
 #include "mozilla/MemoryReporting.h"
-#include "mozilla/MemoryTelemetry.h"
 #include "mozilla/ModuleUtils.h"
 #include "mozilla/Mutex.h"
 #include "mozilla/PoisonIOInterposer.h"
@@ -1690,20 +1689,16 @@ TelemetryImpl::FlushBatchedChildTelemetr
 
 NS_IMETHODIMP
 TelemetryImpl::EarlyInit() {
-  Unused << MemoryTelemetry::Get();
-
   return NS_OK;
 }
 
 NS_IMETHODIMP
 TelemetryImpl::DelayedInit() {
-  MemoryTelemetry::Get().DelayedInit();
   return NS_OK;
 }
 
 NS_IMETHODIMP
 TelemetryImpl::Shutdown() {
-  MemoryTelemetry::Get().Shutdown();
   return NS_OK;
 }
 
@@ -1715,9 +1710,6 @@ TelemetryImpl::GatherMemory(JSContext* a
     return rv.StealNSResult();
   }
 
-  MemoryTelemetry::Get().GatherReports(
-      [promise]() { promise->MaybeResolve(JS::UndefinedHandleValue); });
-
   promise.forget(aResult);
   return NS_OK;
 }
diff --git a/toolkit/components/telemetry/moz.build b/toolkit/components/telemetry/moz.build
--- a/toolkit/components/telemetry/moz.build
+++ b/toolkit/components/telemetry/moz.build
@@ -8,10 +8,6 @@ include("/ipc/chromium/chromium-config.m
 
 FINAL_LIBRARY = "xul"
 
-DIRS = [
-    "pingsender",
-]
-
 DEFINES["MOZ_APP_VERSION"] = '"%s"' % CONFIG["MOZ_APP_VERSION"]
 
 for var in ("MOZ_BACKGROUNDTASKS",):
@@ -90,8 +86,6 @@ XPCOM_MANIFESTS += [
     "core/components.conf",
 ]
 
-EXTRA_COMPONENTS += ["TelemetryStartup.manifest"]
-
 EXTRA_JS_MODULES += [
     "app/ClientID.jsm",
     "app/TelemetryArchive.jsm",
@@ -104,28 +98,10 @@ EXTRA_JS_MODULES += [
     "app/TelemetryScheduler.jsm",
     "app/TelemetrySend.jsm",
     "app/TelemetryStorage.jsm",
-    "app/TelemetryTimestamps.jsm",
     "app/TelemetryUtils.jsm",
-    "pings/CoveragePing.jsm",
-    "pings/EventPing.jsm",
-    "pings/HealthPing.jsm",
-    "pings/ModulesPing.jsm",
-    "pings/PrioPing.jsm",
     "pings/TelemetrySession.jsm",
-    "pings/UntrustedModulesPing.jsm",
-    "pings/UpdatePing.jsm",
-    "TelemetryStartup.jsm",
 ]
 
-EXTRA_JS_MODULES.backgroundtasks += [
-    "pings/BackgroundTask_pingsender.jsm",
-]
-
-if CONFIG["OS_ARCH"] == "WINNT":
-    EXTRA_JS_MODULES += [
-        "pings/UninstallPing.jsm",
-    ]
-
 TESTING_JS_MODULES += [
     "tests/unit/TelemetryArchiveTesting.jsm",
     "tests/unit/TelemetryEnvironmentTesting.jsm",
diff --git a/toolkit/components/telemetry/pings/TelemetrySession.jsm b/toolkit/components/telemetry/pings/TelemetrySession.jsm
--- a/toolkit/components/telemetry/pings/TelemetrySession.jsm
+++ b/toolkit/components/telemetry/pings/TelemetrySession.jsm
@@ -951,98 +951,6 @@ var Impl = {
     // on all pings to be saved after kicking off their collection.
     let p = [];
 
-    if (IS_UNIFIED_TELEMETRY) {
-      let shutdownPayload = this.getSessionPayload(REASON_SHUTDOWN, false);
-
-      // Only send the shutdown ping using the pingsender from the second
-      // browsing session on, to mitigate issues with "bot" profiles (see bug 1354482).
-      const sendOnThisSession =
-        Services.prefs.getBoolPref(
-          Utils.Preferences.ShutdownPingSenderFirstSession,
-          false
-        ) || !TelemetryReportingPolicy.isFirstRun();
-      let sendWithPingsender =
-        Services.prefs.getBoolPref(
-          TelemetryUtils.Preferences.ShutdownPingSender,
-          false
-        ) && sendOnThisSession;
-
-      let options = {
-        addClientId: true,
-        addEnvironment: true,
-        usePingSender: sendWithPingsender,
-      };
-      p.push(
-        TelemetryController.submitExternalPing(
-          getPingType(shutdownPayload),
-          shutdownPayload,
-          options
-        ).catch(e =>
-          this._log.error(
-            "saveShutdownPings - failed to submit shutdown ping",
-            e
-          )
-        )
-      );
-
-      // Send a duplicate of first-shutdown pings as a new ping type, in order to properly
-      // evaluate first session profiles (see bug 1390095).
-      const sendFirstShutdownPing =
-        Services.prefs.getBoolPref(
-          Utils.Preferences.ShutdownPingSender,
-          false
-        ) &&
-        Services.prefs.getBoolPref(
-          Utils.Preferences.FirstShutdownPingEnabled,
-          false
-        ) &&
-        TelemetryReportingPolicy.isFirstRun();
-
-      if (sendFirstShutdownPing) {
-        let options = {
-          addClientId: true,
-          addEnvironment: true,
-          usePingSender: true,
-        };
-        p.push(
-          TelemetryController.submitExternalPing(
-            "first-shutdown",
-            shutdownPayload,
-            options
-          ).catch(e =>
-            this._log.error(
-              "saveShutdownPings - failed to submit first shutdown ping",
-              e
-            )
-          )
-        );
-      }
-    }
-
-    if (
-      AppConstants.platform == "android" &&
-      Services.telemetry.canRecordExtended
-    ) {
-      let payload = this.getSessionPayload(REASON_SAVED_SESSION, false);
-
-      let options = {
-        addClientId: true,
-        addEnvironment: true,
-      };
-      p.push(
-        TelemetryController.submitExternalPing(
-          getPingType(payload),
-          payload,
-          options
-        ).catch(e =>
-          this._log.error(
-            "saveShutdownPings - failed to submit saved-session ping",
-            e
-          )
-        )
-      );
-    }
-
     // Wait on pings to be saved.
     return Promise.all(p);
   },
diff --git a/toolkit/components/telemetry/pings/UpdatePing.jsm b/toolkit/components/telemetry/pings/UpdatePing.jsm
--- a/toolkit/components/telemetry/pings/UpdatePing.jsm
+++ b/toolkit/components/telemetry/pings/UpdatePing.jsm
@@ -70,51 +70,6 @@ var UpdatePing = {
   },
 
   /**
-   * Generate an "update" ping with reason "success" and dispatch it
-   * to the Telemetry system.
-   *
-   * @param {String} aPreviousVersion The browser version we updated from.
-   * @param {String} aPreviousBuildId The browser build id we updated from.
-   */
-  handleUpdateSuccess(aPreviousVersion, aPreviousBuildId) {
-    if (!this._enabled) {
-      return;
-    }
-
-    this._log.trace("handleUpdateSuccess");
-
-    // An update could potentially change the update channel. Moreover,
-    // updates can only be applied if the update's channel matches with the build channel.
-    // There's no way to pass this information from the caller nor the environment as,
-    // in that case, the environment would report the "new" channel. However, the
-    // update manager should still have information about the active update: given the
-    // previous assumptions, we can simply get the channel from the update and assume
-    // it matches with the state previous to the update.
-    let update = this._getActiveUpdate();
-
-    const payload = {
-      reason: "success",
-      previousChannel: update ? update.channel : null,
-      previousVersion: aPreviousVersion,
-      previousBuildId: aPreviousBuildId,
-    };
-
-    const options = {
-      addClientId: true,
-      addEnvironment: true,
-      usePingSender: false,
-    };
-
-    TelemetryController.submitExternalPing(
-      PING_TYPE,
-      payload,
-      options
-    ).catch(e =>
-      this._log.error("handleUpdateSuccess - failed to submit update ping", e)
-    );
-  },
-
-  /**
    * Generate an "update" ping with reason "ready" and dispatch it
    * to the Telemetry system.
    *
diff --git a/toolkit/components/utils/ClientEnvironment.jsm b/toolkit/components/utils/ClientEnvironment.jsm
--- a/toolkit/components/utils/ClientEnvironment.jsm
+++ b/toolkit/components/utils/ClientEnvironment.jsm
@@ -15,7 +15,6 @@ ChromeUtils.defineModuleGetter(this, "Up
 ChromeUtils.defineModuleGetter(this, "AppConstants", "resource://gre/modules/AppConstants.jsm");
 ChromeUtils.defineModuleGetter(this, "AttributionCode", "resource:///modules/AttributionCode.jsm");
 ChromeUtils.defineModuleGetter(this, "WindowsVersionInfo", "resource://gre/modules/components-utils/WindowsVersionInfo.jsm");
-ChromeUtils.defineModuleGetter(this, "NormandyUtils", "resource://normandy/lib/NormandyUtils.jsm");
 /* eslint-enable prettier/prettier */
 
 var EXPORTED_SYMBOLS = ["ClientEnvironmentBase"];
@@ -97,16 +96,6 @@ class ClientEnvironmentBase {
     });
   }
 
-  // Note that we intend to replace usages of this with client_id in https://bugzilla.mozilla.org/show_bug.cgi?id=1542955
-  static get randomizationId() {
-    let id = Services.prefs.getCharPref("app.normandy.user_id", "");
-    if (!id) {
-      id = NormandyUtils.generateUuid();
-      Services.prefs.setCharPref("app.normandy.user_id", id);
-    }
-    return id;
-  }
-
   static get version() {
     return AppConstants.MOZ_APP_VERSION_DISPLAY;
   }
diff --git a/toolkit/content/jar.mn b/toolkit/content/jar.mn
--- a/toolkit/content/jar.mn
+++ b/toolkit/content/jar.mn
@@ -30,9 +30,6 @@ toolkit.jar:
    content/global/aboutGlean.html
    content/global/aboutGlean.css
 #endif
-   content/global/aboutTelemetry.js
-   content/global/aboutTelemetry.xhtml
-   content/global/aboutTelemetry.css
    content/global/aboutUrlClassifier.js
    content/global/aboutUrlClassifier.xhtml
    content/global/aboutUrlClassifier.css
diff --git a/toolkit/content/moz.build b/toolkit/content/moz.build
--- a/toolkit/content/moz.build
+++ b/toolkit/content/moz.build
@@ -229,9 +229,6 @@ with Files("aboutService*"):
 with Files("aboutSupport*"):
     BUG_COMPONENT = ("Toolkit", "General")
 
-with Files("aboutTelemetry*"):
-    BUG_COMPONENT = ("Toolkit", "Telemetry")
-
 with Files("autocomplete.css"):
     BUG_COMPONENT = ("Firefox", "Search")
 
diff --git a/toolkit/modules/FirstStartup.jsm b/toolkit/modules/FirstStartup.jsm
--- a/toolkit/modules/FirstStartup.jsm
+++ b/toolkit/modules/FirstStartup.jsm
@@ -13,7 +13,6 @@ const { XPCOMUtils } = ChromeUtils.impor
 );
 
 XPCOMUtils.defineLazyModuleGetters(this, {
-  Normandy: "resource://normandy/Normandy.jsm",
   TaskScheduler: "resource://gre/modules/TaskScheduler.jsm",
 });
 
@@ -50,10 +49,6 @@ var FirstStartup = {
     let initialized = false;
 
     let promises = [];
-    if (AppConstants.MOZ_NORMANDY) {
-      promises.push(Normandy.init({ runAsync: false }));
-    }
-
     if (AppConstants.MOZ_UPDATE_AGENT) {
       // It's technically possible for a previous installation to leave an old
       // OS-level scheduled task around.  Start fresh.
diff --git a/toolkit/modules/Troubleshoot.jsm b/toolkit/modules/Troubleshoot.jsm
--- a/toolkit/modules/Troubleshoot.jsm
+++ b/toolkit/modules/Troubleshoot.jsm
@@ -854,59 +854,7 @@ var dataProviders = {
   },
 
   async normandy(done) {
-    if (!AppConstants.MOZ_NORMANDY) {
       done();
-      return;
-    }
-
-    const {
-      PreferenceExperiments: NormandyPreferenceStudies,
-    } = ChromeUtils.import("resource://normandy/lib/PreferenceExperiments.jsm");
-    const { AddonStudies: NormandyAddonStudies } = ChromeUtils.import(
-      "resource://normandy/lib/AddonStudies.jsm"
-    );
-    const {
-      PreferenceRollouts: NormandyPreferenceRollouts,
-    } = ChromeUtils.import("resource://normandy/lib/PreferenceRollouts.jsm");
-    const { ExperimentManager } = ChromeUtils.import(
-      "resource://nimbus/lib/ExperimentManager.jsm"
-    );
-
-    // Get Normandy data in parallel, and sort each group by slug.
-    const [
-      addonStudies,
-      prefRollouts,
-      prefStudies,
-      nimbusExperiments,
-      nimbusRollouts,
-    ] = await Promise.all(
-      [
-        NormandyAddonStudies.getAllActive(),
-        NormandyPreferenceRollouts.getAllActive(),
-        NormandyPreferenceStudies.getAllActive(),
-        ExperimentManager.store
-          .ready()
-          .then(() => ExperimentManager.store.getAllActive()),
-        ExperimentManager.store
-          .ready()
-          .then(() => ExperimentManager.store.getAllRollouts()),
-      ].map(promise =>
-        promise
-          .catch(error => {
-            Cu.reportError(error);
-            return [];
-          })
-          .then(items => items.sort((a, b) => a.slug.localeCompare(b.slug)))
-      )
-    );
-
-    done({
-      addonStudies,
-      prefRollouts,
-      prefStudies,
-      nimbusExperiments,
-      nimbusRollouts,
-    });
   },
 };
 
diff --git a/toolkit/modules/moz.build b/toolkit/modules/moz.build
--- a/toolkit/modules/moz.build
+++ b/toolkit/modules/moz.build
@@ -156,7 +156,6 @@ EXTRA_JS_MODULES += [
     "AppMenuNotifications.jsm",
     "AsyncPrefs.jsm",
     "BinarySearch.jsm",
-    "BrowserTelemetryUtils.jsm",
     "BrowserUtils.jsm",
     "CanonicalJSON.jsm",
     "CertUtils.jsm",
diff --git a/toolkit/mozapps/extensions/AbuseReporter.jsm b/toolkit/mozapps/extensions/AbuseReporter.jsm
--- a/toolkit/mozapps/extensions/AbuseReporter.jsm
+++ b/toolkit/mozapps/extensions/AbuseReporter.jsm
@@ -27,7 +27,6 @@ const SUPPORTED_ADDON_TYPES = ["extensio
 
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManager: "resource://gre/modules/AddonManager.jsm",
-  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
   AppConstants: "resource://gre/modules/AppConstants.jsm",
   ClientID: "resource://gre/modules/ClientID.jsm",
   Services: "resource://gre/modules/Services.jsm",
@@ -142,11 +141,6 @@ const AbuseReporter = {
     }
 
     if (!addon) {
-      AMTelemetry.recordReportEvent({
-        addonId,
-        errorType: "ERROR_ADDON_NOTFOUND",
-        reportEntryPoint,
-      });
       throw new AbuseReportError("ERROR_ADDON_NOTFOUND");
     }
 
@@ -229,12 +223,6 @@ const AbuseReporter = {
       // Log the original error in the browser console.
       Cu.reportError(err);
 
-      AMTelemetry.recordReportEvent({
-        addonId,
-        errorType: err.errorType || "ERROR_AMODETAILS_FAILURE",
-        reportEntryPoint,
-      });
-
       return null;
     }
 
@@ -537,16 +525,6 @@ class AbuseReport {
     };
   }
 
-  recordTelemetry(errorType) {
-    const { addon, reportEntryPoint } = this;
-    AMTelemetry.recordReportEvent({
-      addonId: addon.id,
-      addonType: addon.type,
-      errorType,
-      reportEntryPoint,
-    });
-  }
-
   /**
    * Submit the current report, given a reason and a message.
    *
@@ -567,8 +545,6 @@ class AbuseReport {
 
     // Record telemetry event and throw an AbuseReportError.
     const rejectReportError = async (errorType, { response } = {}) => {
-      this.recordTelemetry(errorType);
-
       // Leave errorInfo empty if there is no response or fails to
       // be converted into an error info object.
       const errorInfo = response
@@ -617,11 +593,9 @@ class AbuseReport {
       try {
         await response.json();
       } catch (err) {
-        this.recordTelemetry("ERROR_UNKNOWN");
         throw err;
       }
       AbuseReporter.updateLastReportTimestamp();
-      this.recordTelemetry();
       return undefined;
     }
 
diff --git a/toolkit/mozapps/extensions/AddonManager.jsm b/toolkit/mozapps/extensions/AddonManager.jsm
--- a/toolkit/mozapps/extensions/AddonManager.jsm
+++ b/toolkit/mozapps/extensions/AddonManager.jsm
@@ -91,7 +91,6 @@ XPCOMUtils.defineLazyModuleGetters(this,
   AbuseReporter: "resource://gre/modules/AbuseReporter.jsm",
   Extension: "resource://gre/modules/Extension.jsm",
   RemoteSettings: "resource://services-settings/remote-settings.js",
-  TelemetryTimestamps: "resource://gre/modules/TelemetryTimestamps.jsm",
 });
 
 XPCOMUtils.defineLazyPreferenceGetter(
@@ -114,7 +113,6 @@ const INTEGER = /^[1-9]\d*$/;
 var EXPORTED_SYMBOLS = [
   "AddonManager",
   "AddonManagerPrivate",
-  "AMTelemetry",
   "AMRemoteSettings",
 ];
 
@@ -493,7 +491,6 @@ var gRepoShutdownState = "";
 var gShutdownInProgress = false;
 var gBrowserUpdated = null;
 
-var AMTelemetry;
 var AMRemoteSettings;
 
 /**
@@ -516,10 +513,6 @@ var AddonManagerInternal = {
   upgradeListeners: new Map(),
   externalExtensionLoaders: new Map(),
 
-  recordTimestamp(name, value) {
-    TelemetryTimestamps.add(name, value);
-  },
-
   /**
    * Start up a provider, and register its shutdown hook if it has one
    *
@@ -600,11 +593,6 @@ var AddonManagerInternal = {
         return;
       }
 
-      this.recordTimestamp("AMI_startup_begin");
-
-      // Enable the addonsManager telemetry event category.
-      AMTelemetry.init();
-
       // Enable the AMRemoteSettings client.
       AMRemoteSettings.init();
 
@@ -762,7 +750,6 @@ var AddonManagerInternal = {
 
       gStartupComplete = true;
       gStartedPromise.resolve();
-      this.recordTimestamp("AMI_startup_end");
     } catch (e) {
       logger.error("startup failed", e);
       AddonManagerPrivate.recordException("AMI", "startup failed", e);
@@ -3603,10 +3590,6 @@ var AddonManagerPrivate = {
     gXPIProvider.unregisterDictionaries(aDicts);
   },
 
-  recordTimestamp(name, value) {
-    AddonManagerInternal.recordTimestamp(name, value);
-  },
-
   _simpleMeasures: {},
   recordSimpleMeasure(name, value) {
     this._simpleMeasures[name] = value;
@@ -4429,646 +4412,8 @@ AMRemoteSettings = {
   },
 };
 
-/**
- * Listens to the AddonManager install and addon events and send telemetry events.
- */
-AMTelemetry = {
-  telemetrySetupDone: false,
-
-  init() {
-    // Enable the addonsManager telemetry event category before the AddonManager
-    // has completed its startup, otherwise telemetry events recorded during the
-    // AddonManager/XPIProvider startup will not be recorded.
-    Services.telemetry.setEventRecordingEnabled("addonsManager", true);
-  },
-
-  // This method is called by the AddonManager, once it has been started, so that we can
-  // init the telemetry event category and start listening for the events related to the
-  // addons installation and management.
-  onStartup() {
-    if (this.telemetrySetupDone) {
-      return;
-    }
-
-    this.telemetrySetupDone = true;
-
-    Services.obs.addObserver(this, "addon-install-origin-blocked");
-    Services.obs.addObserver(this, "addon-install-disabled");
-    Services.obs.addObserver(this, "addon-install-blocked");
-
-    AddonManager.addInstallListener(this);
-    AddonManager.addAddonListener(this);
-  },
-
-  // Observer Service notification callback.
-
-  observe(subject, topic, data) {
-    switch (topic) {
-      case "addon-install-blocked": {
-        const { installs } = subject.wrappedJSObject;
-        this.recordInstallEvent(installs[0], { step: "site_warning" });
-        break;
-      }
-      case "addon-install-origin-blocked": {
-        const { installs } = subject.wrappedJSObject;
-        this.recordInstallEvent(installs[0], { step: "site_blocked" });
-        break;
-      }
-      case "addon-install-disabled": {
-        const { installs } = subject.wrappedJSObject;
-        this.recordInstallEvent(installs[0], {
-          step: "install_disabled_warning",
-        });
-        break;
-      }
-    }
-  },
-
-  // AddonManager install listener callbacks.
-
-  onNewInstall(install) {
-    this.recordInstallEvent(install, { step: "started" });
-  },
-
-  onInstallCancelled(install) {
-    this.recordInstallEvent(install, { step: "cancelled" });
-  },
-
-  onInstallPostponed(install) {
-    this.recordInstallEvent(install, { step: "postponed" });
-  },
-
-  onInstallFailed(install) {
-    this.recordInstallEvent(install, { step: "failed" });
-  },
-
-  onInstallEnded(install) {
-    this.recordInstallEvent(install, { step: "completed" });
-    // Skip install_stats events for install objects related to.
-    // add-on updates.
-    if (!install.existingAddon) {
-      this.recordInstallStatsEvent(install);
-    }
-  },
-
-  onDownloadStarted(install) {
-    this.recordInstallEvent(install, { step: "download_started" });
-  },
-
-  onDownloadCancelled(install) {
-    this.recordInstallEvent(install, { step: "cancelled" });
-  },
-
-  onDownloadEnded(install) {
-    let download_time = Math.round(Cu.now() - install.downloadStartedAt);
-    this.recordInstallEvent(install, {
-      step: "download_completed",
-      download_time,
-    });
-  },
-
-  onDownloadFailed(install) {
-    let download_time = Math.round(Cu.now() - install.downloadStartedAt);
-    this.recordInstallEvent(install, {
-      step: "download_failed",
-      download_time,
-    });
-  },
-
-  // Addon listeners callbacks.
-
-  onUninstalled(addon) {
-    this.recordManageEvent(addon, "uninstall");
-  },
-
-  onEnabled(addon) {
-    this.recordManageEvent(addon, "enable");
-  },
-
-  onDisabled(addon) {
-    this.recordManageEvent(addon, "disable");
-  },
-
-  // Internal helpers methods.
-
-  /**
-   * Get a trimmed version of the given string if it is longer than 80 chars.
-   *
-   * @param {string} str
-   *        The original string content.
-   *
-   * @returns {string}
-   *          The trimmed version of the string when longer than 80 chars, or the given string
-   *          unmodified otherwise.
-   */
-  getTrimmedString(str) {
-    if (str.length <= 80) {
-      return str;
-    }
-
-    const length = str.length;
-
-    // Trim the string to prevent a flood of warnings messages logged internally by recordEvent,
-    // the trimmed version is going to be composed by the first 40 chars and the last 37 and 3 dots
-    // that joins the two parts, to visually indicate that the string has been trimmed.
-    return `${str.slice(0, 40)}...${str.slice(length - 37, length)}`;
-  },
-
-  /**
-   * Retrieve the addonId for the given AddonInstall instance.
-   *
-   * @param {AddonInstall} install
-   *        The AddonInstall instance to retrieve the addonId from.
-   *
-   * @returns {string | null}
-   *          The addonId for the given AddonInstall instance (if any).
-   */
-  getAddonIdFromInstall(install) {
-    // Returns the id of the extension that is being installed, as soon as the
-    // addon is available in the AddonInstall instance (after being downloaded
-    // and validated successfully).
-    if (install.addon) {
-      return install.addon.id;
-    }
-
-    // While updating an addon, the existing addon can be
-    // used to retrieve the addon id since the first update event.
-    if (install.existingAddon) {
-      return install.existingAddon.id;
-    }
-
-    return null;
-  },
-
-  /**
-   * Retrieve the telemetry event's object property value for the given
-   * AddonInstall instance.
-   *
-   * @param {AddonInstall} install
-   *        The AddonInstall instance to retrieve the event object from.
-   *
-   * @returns {string}
-   *          The object for the given AddonInstall instance.
-   */
-  getEventObjectFromInstall(install) {
-    let addonType;
-
-    if (install.type) {
-      // The AddonInstall wrapper already provides a type (if it was known when the
-      // install object has been created).
-      addonType = install.type;
-    } else if (install.addon) {
-      // The install flow has reached a step that has an addon instance which we can
-      // check to know the extension type (e.g. after download for the DownloadAddonInstall).
-      addonType = install.addon.type;
-    } else if (install.existingAddon) {
-      // The install flow is an update and we can look the existingAddon to check which was
-      // the add-on type that is being installed.
-      addonType = install.existingAddon.type;
-    }
-
-    return this.getEventObjectFromAddonType(addonType);
-  },
-
-  /**
-   * Retrieve the telemetry event source for the given AddonInstall instance.
-   *
-   * @param {AddonInstall} install
-   *        The AddonInstall instance to retrieve the source from.
-   *
-   * @returns {Object | null}
-   *          The telemetry infor ({source, method}) from the given AddonInstall instance.
-   */
-  getInstallTelemetryInfo(install) {
-    if (install.installTelemetryInfo) {
-      return install.installTelemetryInfo;
-    } else if (
-      install.existingAddon &&
-      install.existingAddon.installTelemetryInfo
-    ) {
-      // Get the install source from the existing addon (e.g. for an extension update).
-      return install.existingAddon.installTelemetryInfo;
-    }
-
-    return null;
-  },
-
-  /**
-   * Get the telemetry event's object property for the given addon type
-   *
-   * @param {string} addonType
-   *        The addon type to convert into the related telemetry event object.
-   *
-   * @returns {string}
-   *          The object for the given addon type.
-   */
-  getEventObjectFromAddonType(addonType) {
-    switch (addonType) {
-      case undefined:
-        return "unknown";
-      case "extension":
-      case "theme":
-      case "locale":
-      case "dictionary":
-      case "sitepermission":
-        return addonType;
-      default:
-        // Currently this should only include gmp-plugins ("plugin").
-        return "other";
-    }
-  },
-
-  convertToString(value) {
-    if (value == null) {
-      // Convert null and undefined to empty strings.
-      return "";
-    }
-    switch (typeof value) {
-      case "string":
-        return value;
-      case "boolean":
-        return value ? "1" : "0";
-    }
-    return String(value);
-  },
-
-  /**
-   * Return the UTM parameters found in `sourceURL` for AMO attribution data.
-   *
-   * @param {string} sourceURL
-   *        The source URL from where the add-on has been installed.
-   *
-   * @returns {object}
-   *          An object containing the attribution data for AMO if any. Keys
-   *          are defined in `AMO_ATTRIBUTION_DATA_KEYS`. Values are strings.
-   */
-  parseAttributionDataForAMO(sourceURL) {
-    let searchParams;
-
-    try {
-      searchParams = new URL(sourceURL).searchParams;
-    } catch {
-      return {};
-    }
-
-    const utmKeys = [...searchParams.keys()].filter(key =>
-      AMO_ATTRIBUTION_DATA_KEYS.includes(key)
-    );
-
-    return utmKeys.reduce((params, key) => {
-      let value = searchParams.get(key);
-      if (typeof value === "string") {
-        value = value.slice(0, AMO_ATTRIBUTION_DATA_MAX_LENGTH);
-      }
-
-      return { ...params, [key]: value };
-    }, {});
-  },
-
-  /**
-   * Record an "install stats" event when the source is included in
-   * `AMO_ATTRIBUTION_ALLOWED_SOURCES`.
-   *
-   * @param {AddonInstall} install
-   *        The AddonInstall instance to record an install_stats event for.
-   */
-  recordInstallStatsEvent(install) {
-    const telemetryInfo = this.getInstallTelemetryInfo(install);
-
-    if (!AMO_ATTRIBUTION_ALLOWED_SOURCES.includes(telemetryInfo?.source)) {
-      return;
-    }
-
-    const method = "install_stats";
-    const object = this.getEventObjectFromInstall(install);
-    const addonId = this.getAddonIdFromInstall(install);
-
-    if (!addonId) {
-      Cu.reportError(
-        "Missing addonId when trying to record an install_stats event"
-      );
-      return;
-    }
-
-    let extra = {
-      addon_id: this.getTrimmedString(addonId),
-    };
-
-    if (
-      telemetryInfo?.source === "amo" &&
-      typeof telemetryInfo?.sourceURL === "string"
-    ) {
-      extra = {
-        ...extra,
-        ...this.parseAttributionDataForAMO(telemetryInfo.sourceURL),
-      };
-    }
-
-    if (
-      telemetryInfo?.source === "disco" &&
-      typeof telemetryInfo?.taarRecommended === "boolean"
-    ) {
-      extra = {
-        ...extra,
-        taar_based: this.convertToString(telemetryInfo.taarRecommended),
-      };
-    }
-
-    this.recordEvent({ method, object, value: install.hashedAddonId, extra });
-  },
-
-  /**
-   * Convert all the telemetry event's extra_vars into strings, if needed.
-   *
-   * @param {object} extraVars
-   * @returns {object} The formatted extra vars.
-   */
-  formatExtraVars({ addon, ...extraVars }) {
-    if (addon) {
-      extraVars.addonId = addon.id;
-      extraVars.type = addon.type;
-    }
-
-    // All the extra_vars in a telemetry event have to be strings.
-    for (var [key, value] of Object.entries(extraVars)) {
-      if (value == undefined) {
-        delete extraVars[key];
-      } else {
-        extraVars[key] = this.convertToString(value);
-      }
-    }
-
-    if (extraVars.addonId) {
-      extraVars.addonId = this.getTrimmedString(extraVars.addonId);
-    }
-
-    return extraVars;
-  },
-
-  /**
-   * Record an install or update event for the given AddonInstall instance.
-   *
-   * @param {AddonInstall} install
-   *        The AddonInstall instance to record an install or update event for.
-   * @param {object} extraVars
-   *        The additional extra_vars to include in the recorded event.
-   * @param {string} extraVars.step
-   *        The current step in the install or update flow.
-   * @param {string} extraVars.download_time
-   *        The number of ms needed to download the extension.
-   * @param {string} extraVars.num_strings
-   *        The number of permission description string for the extension
-   *        permission doorhanger.
-   */
-  recordInstallEvent(install, extraVars) {
-    // Early exit if AMTelemetry's telemetry setup has not been done yet.
-    if (!this.telemetrySetupDone) {
-      return;
-    }
-
-    let extra = {};
-
-    let telemetryInfo = this.getInstallTelemetryInfo(install);
-    if (telemetryInfo && typeof telemetryInfo.source === "string") {
-      extra.source = telemetryInfo.source;
-    }
-
-    if (extra.source === "internal") {
-      // Do not record the telemetry event for installation sources
-      // that are marked as "internal".
-      return;
-    }
-
-    // Also include the install source's method when applicable (e.g. install events with
-    // source "about:addons" may have "install-from-file" or "url" as their source method).
-    if (telemetryInfo && typeof telemetryInfo.method === "string") {
-      extra.method = telemetryInfo.method;
-    }
-
-    let addonId = this.getAddonIdFromInstall(install);
-    let object = this.getEventObjectFromInstall(install);
-
-    let installId = String(install.installId);
-    let eventMethod = install.existingAddon ? "update" : "install";
-
-    if (addonId) {
-      extra.addon_id = this.getTrimmedString(addonId);
-    }
-
-    if (install.error) {
-      extra.error = AddonManager.errorToString(install.error);
-    }
-
-    if (
-      eventMethod === "install" &&
-      Services.prefs.getBoolPref("extensions.install_origins.enabled", true)
-    ) {
-      // This is converted to "1" / "0".
-      extra.install_origins = Array.isArray(install.addon?.installOrigins);
-    }
-
-    if (eventMethod === "update") {
-      // For "update" telemetry events, also include an extra var which determine
-      // if the update has been requested by the user.
-      extra.updated_from = install.isUserRequestedUpdate ? "user" : "app";
-    }
-
-    // All the extra vars in a telemetry event have to be strings.
-    extra = this.formatExtraVars({ ...extraVars, ...extra });
-
-    this.recordEvent({ method: eventMethod, object, value: installId, extra });
-  },
-
-  /**
-   * Record a manage event for the given addon.
-   *
-   * @param {AddonWrapper} addon
-   *        The AddonWrapper instance.
-   * @param {object} extraVars
-   *        The additional extra_vars to include in the recorded event.
-   * @param {string} extraVars.num_strings
-   *        The number of permission description string for the extension
-   *        permission doorhanger.
-   */
-  recordManageEvent(addon, method, extraVars) {
-    // Early exit if AMTelemetry's telemetry setup has not been done yet.
-    if (!this.telemetrySetupDone) {
-      return;
-    }
-
-    let extra = {};
-
-    if (addon.installTelemetryInfo) {
-      if ("source" in addon.installTelemetryInfo) {
-        extra.source = addon.installTelemetryInfo.source;
-      }
-
-      // Also include the install source's method when applicable (e.g. install events with
-      // source "about:addons" may have "install-from-file" or "url" as their source method).
-      if ("method" in addon.installTelemetryInfo) {
-        extra.method = addon.installTelemetryInfo.method;
-      }
-    }
-
-    if (extra.source === "internal") {
-      // Do not record the telemetry event for installation sources
-      // that are marked as "internal".
-      return;
-    }
-
-    let object = this.getEventObjectFromAddonType(addon.type);
-    let value = this.getTrimmedString(addon.id);
-
-    extra = { ...extraVars, ...extra };
-
-    let hasExtraVars = !!Object.keys(extra).length;
-    extra = this.formatExtraVars(extra);
-
-    this.recordEvent({
-      method,
-      object,
-      value,
-      extra: hasExtraVars ? extra : null,
-    });
-  },
-
-  /**
-   * Record an event for when a link is clicked.
-   *
-   * @param {object} opts
-   * @param {string} opts.object
-   *        The object of the event, should be an identifier for where the link
-   *        is located. The accepted values are listed in the
-   *        addonsManager.link object of the Events.yaml file.
-   * @param {string} opts.value The identifier for the link destination.
-   * @param {object} opts.extra
-   *        The extra data to be sent, all keys must be registered in the
-   *        extra_keys section of addonsManager.link in Events.yaml.
-   */
-  recordLinkEvent({ object, value, extra = null }) {
-    this.recordEvent({ method: "link", object, value, extra });
-  },
-
-  /**
-   * Record an event for an action that took place.
-   *
-   * @param {object} opts
-   * @param {string} opts.object
-   *        The object of the event, should an identifier for where the action
-   *        took place. The accepted values are listed in the
-   *        addonsManager.action object of the Events.yaml file.
-   * @param {string} opts.action The identifier for the action.
-   * @param {string} opts.value An optional value for the action.
-   * @param {object} opts.addon
-   *        An optional object with the "id" and "type" properties, for example
-   *        an AddonWrapper object. Passing this will set some extra properties.
-   * @param {string} opts.addon.id
-   *        The add-on ID to assign to extra.addonId.
-   * @param {string} opts.addon.type
-   *        The add-on type to assign to extra.type.
-   * @param {string} opts.view The current view, when object is aboutAddons.
-   * @param {object} opts.extra
-   *        The extra data to be sent, all keys must be registered in the
-   *        extra_keys section of addonsManager.action in Events.yaml. If
-   *        opts.addon is passed then it will overwrite the addonId and type
-   *        properties in this object, if they are set.
-   */
-  recordActionEvent({ object, action, value, addon, view, extra }) {
-    extra = { ...extra, action, addon, view };
-    if (action === "installFromRecommendation") {
-      extra.taar_based = !!addon.taarRecommended;
-    }
-    this.recordEvent({
-      method: "action",
-      object,
-      // Treat null and undefined as null.
-      value: value == null ? null : this.convertToString(value),
-      extra: this.formatExtraVars(extra),
-    });
-  },
-
-  /**
-   * Record an event for a view load in about:addons.
-   *
-   * @param {object} opts
-   * @param {string} opts.view
-   *        The identifier for the view. The accepted values are listed in the
-   *        object property of addonsManager.view object of the Events.yaml
-   *        file.
-   * @param {AddonWrapper} opts.addon
-   *        An optional add-on object related to the event.
-   * @param {string} opts.type
-   *        An optional type for the view. If opts.addon is set it will
-   *        overwrite this value with the type of the add-on.
-   * @param {boolean} opts.taarEnabled
-   *        Set to true if taar-based discovery was enabled when the user
-   *        did switch between about:addons views.
-   */
-  recordViewEvent({ view, addon, type, taarEnabled }) {
-    this.recordEvent({
-      method: "view",
-      object: "aboutAddons",
-      value: view,
-      extra: this.formatExtraVars({
-        type,
-        addon,
-        taar_enabled: taarEnabled,
-      }),
-    });
-  },
-
-  /**
-   * Record an event on abuse report submissions.
-   *
-   * @params {object} opts
-   * @params {string} opts.addonId
-   *         The id of the addon being reported.
-   * @params {string} [opts.addonType]
-   *         The type of the addon being reported  (only present for an existing
-   *         addonId).
-   * @params {string} [opts.errorType]
-   *         The AbuseReport errorType for a submission failure.
-   * @params {string} opts.reportEntryPoint
-   *         The entry point of the abuse report.
-   */
-  recordReportEvent({ addonId, addonType, errorType, reportEntryPoint }) {
-    this.recordEvent({
-      method: "report",
-      object: reportEntryPoint,
-      value: addonId,
-      extra: this.formatExtraVars({
-        addon_type: addonType,
-        error_type: errorType,
-      }),
-    });
-  },
-
-  recordEvent({ method, object, value, extra }) {
-    if (typeof value != "string") {
-      // The value must be a string or null, make sure it's valid so sending
-      // the event doesn't fail.
-      value = null;
-    }
-    try {
-      Services.telemetry.recordEvent(
-        "addonsManager",
-        method,
-        object,
-        value,
-        extra
-      );
-    } catch (err) {
-      // If the telemetry throws just log the error so it doesn't break any
-      // functionality.
-      Cu.reportError(err);
-    }
-  },
-};
-
 AddonManager.init();
 
-// Setup the AMTelemetry once the AddonManager has been started.
-AddonManager.addManagerListener(AMTelemetry);
 Object.freeze(AddonManagerInternal);
 Object.freeze(AddonManagerPrivate);
 Object.freeze(AddonManager);
diff --git a/toolkit/mozapps/extensions/content/aboutaddons.js b/toolkit/mozapps/extensions/content/aboutaddons.js
--- a/toolkit/mozapps/extensions/content/aboutaddons.js
+++ b/toolkit/mozapps/extensions/content/aboutaddons.js
@@ -12,7 +12,6 @@
 XPCOMUtils.defineLazyModuleGetters(this, {
   AddonManager: "resource://gre/modules/AddonManager.jsm",
   AddonRepository: "resource://gre/modules/addons/AddonRepository.jsm",
-  AMTelemetry: "resource://gre/modules/AddonManager.jsm",
   BuiltInThemes: "resource:///modules/BuiltInThemes.jsm",
   ClientID: "resource://gre/modules/ClientID.jsm",
   DeferredTask: "resource://gre/modules/DeferredTask.jsm",
@@ -1167,15 +1166,6 @@ class SearchAddons extends HTMLElement {
         {}
       ),
     });
-
-    AMTelemetry.recordLinkEvent({
-      object: "aboutAddons",
-      value: "search",
-      extra: {
-        type: this.closest("addon-page-header").getAttribute("type"),
-        view: getTelemetryViewName(this),
-      },
-    });
   }
 }
 customElements.define("search-addons", SearchAddons);
@@ -1549,12 +1539,6 @@ class AddonPageOptions extends HTMLEleme
       case "install-from-file":
         if (XPINSTALL_ENABLED) {
           installAddonsFromFilePicker().then(installs => {
-            for (let install of installs) {
-              this.recordActionEvent({
-                action: "installFromFile",
-                value: install.installId,
-              });
-            }
           });
         }
         break;
@@ -1574,7 +1558,6 @@ class AddonPageOptions extends HTMLEleme
   }
 
   async checkForUpdates(e) {
-    this.recordActionEvent({ action: "checkForUpdates" });
     let message = document.getElementById("updates-message");
     message.state = "updating";
     message.hidden = false;
@@ -1590,7 +1573,6 @@ class AddonPageOptions extends HTMLEleme
 
   openAboutDebugging() {
     let mainWindow = window.windowRoot.ownerGlobal;
-    this.recordLinkEvent({ value: "about:debugging" });
     if ("switchToTabHavingURI" in mainWindow) {
       let principal = Services.scriptSecurityManager.getSystemPrincipal();
       mainWindow.switchToTabHavingURI(
@@ -1620,18 +1602,6 @@ class AddonPageOptions extends HTMLEleme
       // Toggle the auto pref to false, but don't touch the enabled check.
       AddonManager.autoUpdateDefault = false;
     }
-    // Record telemetry for changing the update policy.
-    let updatePolicy = [];
-    if (AddonManager.autoUpdateDefault) {
-      updatePolicy.push("default");
-    }
-    if (AddonManager.updateEnabled) {
-      updatePolicy.push("enabled");
-    }
-    this.recordActionEvent({
-      action: "setUpdatePolicy",
-      value: updatePolicy.join(","),
-    });
   }
 
   async resetAutomaticUpdates() {
@@ -1641,31 +1611,6 @@ class AddonPageOptions extends HTMLEleme
         addon.applyBackgroundUpdates = AddonManager.AUTOUPDATE_DEFAULT;
       }
     }
-    this.recordActionEvent({ action: "resetUpdatePolicy" });
-  }
-
-  getTelemetryViewName() {
-    return getTelemetryViewName(document.getElementById("page-header"));
-  }
-
-  recordActionEvent({ action, value }) {
-    AMTelemetry.recordActionEvent({
-      object: "aboutAddons",
-      view: this.getTelemetryViewName(),
-      action,
-      addon: this.addon,
-      value,
-    });
-  }
-
-  recordLinkEvent({ value }) {
-    AMTelemetry.recordLinkEvent({
-      object: "aboutAddons",
-      value,
-      extra: {
-        view: this.getTelemetryViewName(),
-      },
-    });
   }
 
   /**
@@ -1968,13 +1913,6 @@ class SidebarFooter extends HTMLElement 
       labelL10nId: "addons-settings-button",
       onClick: e => {
         e.preventDefault();
-        AMTelemetry.recordLinkEvent({
-          object: "aboutAddons",
-          value: "about:preferences",
-          extra: {
-            view: getTelemetryViewName(this),
-          },
-        });
         windowRoot.ownerGlobal.switchToTabHavingURI("about:preferences", true, {
           ignoreFragment: "whenComparing",
           triggeringPrincipal: systemPrincipal,
@@ -1992,15 +1930,6 @@ class SidebarFooter extends HTMLElement 
       },
       titleL10nId: "sidebar-help-button-title",
       labelL10nId: "help-button",
-      onClick: e => {
-        AMTelemetry.recordLinkEvent({
-          object: "aboutAddons",
-          value: "support",
-          extra: {
-            view: getTelemetryViewName(this),
-          },
-        });
-      },
     });
 
     list.append(prefsItem, supportItem);
@@ -2702,12 +2631,6 @@ class AddonDetails extends HTMLElement {
     if (e.type == "view-changed" && e.target == this.deck) {
       switch (this.deck.selectedViewName) {
         case "release-notes":
-          AMTelemetry.recordActionEvent({
-            object: "aboutAddons",
-            view: getTelemetryViewName(this),
-            action: "releaseNotes",
-            addon: this.addon,
-          });
           let releaseNotes = this.querySelector("update-release-notes");
           let uri = this.releaseNotesUri;
           if (uri) {
@@ -3078,7 +3001,6 @@ class AddonCard extends HTMLElement {
           this.setAddonPermission(permission, type, fname);
           break;
         case "toggle-disabled":
-          this.recordActionEvent(addon.userDisabled ? "enable" : "disable");
           // Keep the checked state the same until the add-on's state changes.
           e.target.checked = !addon.userDisabled;
           if (addon.userDisabled) {
@@ -3092,15 +3014,12 @@ class AddonCard extends HTMLElement {
           }
           break;
         case "always-activate":
-          this.recordActionEvent("enable");
           addon.userDisabled = false;
           break;
         case "never-activate":
-          this.recordActionEvent("disable");
           addon.userDisabled = true;
           break;
         case "update-check": {
-          this.recordActionEvent("checkForUpdate");
           let { found } = await checkForUpdate(addon);
           if (!found) {
             this.sendEvent("no-update");
@@ -3141,7 +3060,6 @@ class AddonCard extends HTMLElement {
           this.updateInstall = null;
           break;
         case "contribute":
-          this.recordActionEvent("contribute");
           // prettier-ignore
           windowRoot.ownerGlobal.openUILinkIn(addon.contributionURL, "tab", {
             triggeringPrincipal:
@@ -3152,10 +3070,8 @@ class AddonCard extends HTMLElement {
           break;
         case "preferences":
           if (getOptionsType(addon) == "tab") {
-            this.recordActionEvent("preferences", "external");
             openOptionsInTab(addon.optionsURL);
           } else if (getOptionsType(addon) == "inline") {
-            this.recordActionEvent("preferences", "inline");
             gViewController.loadView(`detail/${this.addon.id}/preferences`);
           }
           break;
@@ -3170,8 +3086,6 @@ class AddonCard extends HTMLElement {
             let { remove, report } = await BrowserAddonUI.promptRemoveExtension(
               addon
             );
-            let value = remove ? "accepted" : "cancelled";
-            this.recordActionEvent("uninstall", value);
             if (remove) {
               await addon.uninstall(true);
               this.sendEvent("remove");
@@ -3215,19 +3129,6 @@ class AddonCard extends HTMLElement {
           ) {
             e.preventDefault();
             gViewController.loadView(`detail/${this.addon.id}`);
-          } else if (
-            e.target.localName == "a" &&
-            e.target.getAttribute("data-telemetry-name")
-          ) {
-            let value = e.target.getAttribute("data-telemetry-name");
-            AMTelemetry.recordLinkEvent({
-              object: "aboutAddons",
-              addon,
-              value,
-              extra: {
-                view: getTelemetryViewName(this),
-              },
-            });
           }
           break;
       }
@@ -3235,10 +3136,8 @@ class AddonCard extends HTMLElement {
       let { name } = e.target;
       let telemetryValue = e.target.getAttribute("data-telemetry-value");
       if (name == "autoupdate") {
-        this.recordActionEvent("setAddonUpdate", telemetryValue);
         addon.applyBackgroundUpdates = e.target.value;
       } else if (name == "private-browsing") {
-        this.recordActionEvent("privateBrowsingAllowed", telemetryValue);
         let policy = WebExtensionPolicy.getByID(addon.id);
         let extension = policy && policy.extension;
 
@@ -3547,13 +3446,6 @@ class AddonCard extends HTMLElement {
   }
 
   recordActionEvent(action, value) {
-    AMTelemetry.recordActionEvent({
-      object: "aboutAddons",
-      view: getTelemetryViewName(this),
-      action,
-      addon: this.addon,
-      value,
-    });
   }
 
   /**
@@ -3760,35 +3652,11 @@ class RecommendedAddonCard extends HTMLE
     let action = event.target.getAttribute("action");
     switch (action) {
       case "install-addon":
-        AMTelemetry.recordActionEvent({
-          object: "aboutAddons",
-          view: getTelemetryViewName(this),
-          action: "installFromRecommendation",
-          addon: this.discoAddon,
-        });
         this.installDiscoAddon();
         break;
       case "manage-addon":
-        AMTelemetry.recordActionEvent({
-          object: "aboutAddons",
-          view: getTelemetryViewName(this),
-          action: "manage",
-          addon: this.discoAddon,
-        });
         gViewController.loadView(`detail/${this.addonId}`);
         break;
-      default:
-        if (event.target.matches(".disco-addon-author a[href]")) {
-          AMTelemetry.recordLinkEvent({
-            object: "aboutAddons",
-            // Note: This is not "author" nor "homepage", because the link text
-            // is the author name, but the link URL the add-on's listing URL.
-            value: "discohome",
-            extra: {
-              view: getTelemetryViewName(this),
-            },
-          });
-        }
     }
   }
 
@@ -3979,12 +3847,6 @@ class AddonList extends HTMLElement {
     const undo = document.createElement("button");
     undo.setAttribute("action", "undo");
     undo.addEventListener("click", () => {
-      AMTelemetry.recordActionEvent({
-        object: "aboutAddons",
-        view: getTelemetryViewName(this),
-        action: "undo",
-        addon,
-      });
       addon.cancelUninstall();
     });
 
@@ -4524,13 +4386,6 @@ class TaarMessageBar extends HTMLElement
       e.type == "click" &&
       e.target.getAttribute("action") == "notice-learn-more"
     ) {
-      AMTelemetry.recordLinkEvent({
-        object: "aboutAddons",
-        value: "disconotice",
-        extra: {
-          view: getTelemetryViewName(this),
-        },
-      });
     } else if (e.type == "message-bar:user-dismissed") {
       Services.prefs.setBoolPref(PREF_RECOMMENDATION_HIDE_NOTICE, true);
     }
@@ -4830,30 +4685,10 @@ gViewController.defineView("shortcuts", 
 });
 
 /**
- * The name of the view for an element, used for telemetry.
- *
- * @param {Element} el The element to find the view from. A parent of the
- *                     element must define a current-view property.
- * @returns {string} The current view name.
- */
-function getTelemetryViewName(el) {
-  let root =
-    el.closest("[current-view]") || document.querySelector("[current-view]");
-  return root.getAttribute("current-view");
-}
-
-/**
  * @param {Element} el The button element.
  */
 function openAmoInTab(el, path) {
   // The element is a button but opens a URL, so record as link.
-  AMTelemetry.recordLinkEvent({
-    object: "aboutAddons",
-    value: "discomore",
-    extra: {
-      view: getTelemetryViewName(el),
-    },
-  });
   let amoUrl = Services.urlFormatter.formatURLPref(
     "extensions.getAddons.link.url"
   );
diff --git a/toolkit/mozapps/extensions/content/view-controller.js b/toolkit/mozapps/extensions/content/view-controller.js
--- a/toolkit/mozapps/extensions/content/view-controller.js
+++ b/toolkit/mozapps/extensions/content/view-controller.js
@@ -8,55 +8,7 @@
 /* import-globals-from aboutaddonsCommon.js */
 /* exported loadView */
 
-const { AddonManager } = ChromeUtils.import(
-  "resource://gre/modules/AddonManager.jsm"
-);
-
-ChromeUtils.defineModuleGetter(
-  this,
-  "AMTelemetry",
-  "resource://gre/modules/AddonManager.jsm"
-);
-
 async function recordViewTelemetry(param) {
-  let type;
-  let addon;
-
-  if (
-    AddonManager.hasAddonType(param) ||
-    ["recent", "available"].includes(param)
-  ) {
-    type = param;
-  } else if (param) {
-    let id = param.replace("/preferences", "");
-    addon = await AddonManager.getAddonByID(id);
-  }
-
-  let { currentViewId } = gViewController;
-  let viewType = gViewController.parseViewId(currentViewId)?.type;
-  let details = {
-    view: viewType || "other",
-    addon,
-    type,
-  };
-
-  // The extensions list view does also include recommendations that may be
-  // recommended by TAAR, themes list view does not at the moment.
-  if (
-    viewType === "discover" ||
-    (viewType === "list" && type === "extension")
-  ) {
-    // DiscoveryAPI is defined in aboutaddons.js (which is technically loaded after
-    // this script, nevertheless we would never reach this if aboutaddons.js wasn't
-    // already executed and the about:addons views defined, which guarantees that
-    // DiscoveryAPI will always be defined here.
-    // (This telemetry collection is also covered by tests and so there will also be
-    // test failures if that isn't the case anymore).
-    const { DiscoveryAPI } = window;
-    details.taarEnabled = !!DiscoveryAPI.clientIdDiscoveryEnabled;
-  }
-
-  AMTelemetry.recordViewEvent(details);
 }
 
 // Used by external callers to load a specific view into the manager
diff --git a/toolkit/mozapps/extensions/internal/XPIProvider.jsm b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
--- a/toolkit/mozapps/extensions/internal/XPIProvider.jsm
+++ b/toolkit/mozapps/extensions/internal/XPIProvider.jsm
@@ -2459,8 +2459,6 @@ var XPIProvider = {
    */
   startup(aAppChanged, aOldAppVersion, aOldPlatformVersion) {
     try {
-      AddonManagerPrivate.recordTimestamp("XPI_startup_begin");
-
       logger.debug("startup");
 
       this.builtInAddons = {};
@@ -2531,8 +2529,6 @@ var XPIProvider = {
       }
 
       try {
-        AddonManagerPrivate.recordTimestamp("XPI_bootstrap_addons_begin");
-
         for (let addon of this.sortBootstrappedAddons()) {
           // The startup update check above may have already started some
           // extensions, make sure not to try to start them twice.
@@ -2568,7 +2564,6 @@ var XPIProvider = {
             );
           }
         }
-        AddonManagerPrivate.recordTimestamp("XPI_bootstrap_addons_end");
       } catch (e) {
         logger.error("bootstrap startup failed", e);
         AddonManagerPrivate.recordException(
@@ -2629,7 +2624,6 @@ var XPIProvider = {
 
       // Detect final-ui-startup for telemetry reporting
       Services.obs.addObserver(function observer() {
-        AddonManagerPrivate.recordTimestamp("XPI_finalUIStartup");
         Services.obs.removeObserver(observer, "final-ui-startup");
       }, "final-ui-startup");
 
@@ -2679,8 +2673,6 @@ var XPIProvider = {
         }
       }
 
-      AddonManagerPrivate.recordTimestamp("XPI_startup_end");
-
       timerManager.registerTimer(
         "xpi-signature-verification",
         () => {
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -257,12 +257,6 @@ extern void InstallSignalHandlers(const 
 #define FILE_INVALIDATE_CACHES ".purgecaches"_ns
 #define FILE_STARTUP_INCOMPLETE u".startup-incomplete"_ns
 
-#if defined(MOZ_BLOCK_PROFILE_DOWNGRADE) || defined(MOZ_LAUNCHER_PROCESS) || \
-    defined(MOZ_DEFAULT_BROWSER_AGENT)
-static const char kPrefHealthReportUploadEnabled[] =
-    "datareporting.healthreport.uploadEnabled";
-#endif  // defined(MOZ_BLOCK_PROFILE_DOWNGRADE) || defined(MOZ_LAUNCHER_PROCESS)
-        // || defined(MOZ_DEFAULT_BROWSER_AGENT)
 #if defined(MOZ_DEFAULT_BROWSER_AGENT)
 static const char kPrefDefaultAgentEnabled[] = "default-browser-agent.enabled";
 
@@ -2407,15 +2401,6 @@ static void OnLauncherPrefChanged(const 
   MOZ_ASSERT(reflectResult.inspect().isOk());
 }
 
-static void OnLauncherTelemetryPrefChanged(const char* aPref, void* aData) {
-  bool prefVal = Preferences::GetBool(kPrefHealthReportUploadEnabled, true);
-
-  mozilla::LauncherRegistryInfo launcherRegInfo;
-  mozilla::DebugOnly<mozilla::LauncherVoidResult> reflectResult =
-      launcherRegInfo.ReflectTelemetryPrefToRegistry(prefVal);
-  MOZ_ASSERT(reflectResult.inspect().isOk());
-}
-
 static void SetupLauncherProcessPref() {
   if (gLauncherProcessState) {
     // We've already successfully run
@@ -2441,15 +2426,8 @@ static void SetupLauncherProcessPref() {
             mozilla::LauncherRegistryInfo::EnabledState::ForceDisabled);
   }
 
-  mozilla::DebugOnly<mozilla::LauncherVoidResult> reflectResult =
-      launcherRegInfo.ReflectTelemetryPrefToRegistry(
-          Preferences::GetBool(kPrefHealthReportUploadEnabled, true));
-  MOZ_ASSERT(reflectResult.inspect().isOk());
-
   Preferences::RegisterCallback(&OnLauncherPrefChanged,
                                 PREF_WIN_LAUNCHER_PROCESS_ENABLED);
-  Preferences::RegisterCallback(&OnLauncherTelemetryPrefChanged,
-                                kPrefHealthReportUploadEnabled);
 }
 
 #  endif  // defined(MOZ_LAUNCHER_PROCESS)
@@ -2483,9 +2461,7 @@ static nsresult PrependRegistryValueName
 static void OnDefaultAgentTelemetryPrefChanged(const char* aPref, void* aData) {
   nsresult rv;
   nsAutoString valueName;
-  if (strcmp(aPref, kPrefHealthReportUploadEnabled) == 0) {
-    valueName.AssignLiteral("DisableTelemetry");
-  } else if (strcmp(aPref, kPrefDefaultAgentEnabled) == 0) {
+  if (strcmp(aPref, kPrefDefaultAgentEnabled) == 0) {
     valueName.AssignLiteral("DisableDefaultBrowserAgent");
   } else {
     return;
@@ -3128,177 +3104,6 @@ struct FileWriteFunc : public JSONWriteF
   }
 };
 
-static void SubmitDowngradeTelemetry(const nsCString& aLastVersion,
-                                     bool aHasSync, int32_t aButton) {
-  nsCOMPtr<nsIPrefService> prefSvc =
-      do_GetService("@mozilla.org/preferences-service;1");
-  NS_ENSURE_TRUE_VOID(prefSvc);
-
-  nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(prefSvc);
-  NS_ENSURE_TRUE_VOID(prefBranch);
-
-  bool enabled;
-  nsresult rv =
-      prefBranch->GetBoolPref(kPrefHealthReportUploadEnabled, &enabled);
-  NS_ENSURE_SUCCESS_VOID(rv);
-  if (!enabled) {
-    return;
-  }
-
-  nsCString server;
-  rv = prefBranch->GetCharPref("toolkit.telemetry.server", server);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  nsCString clientId;
-  rv = prefBranch->GetCharPref("toolkit.telemetry.cachedClientID", clientId);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  rv = prefSvc->GetDefaultBranch(nullptr, getter_AddRefs(prefBranch));
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  nsCString channel("default");
-  rv = prefBranch->GetCharPref("app.update.channel", channel);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  nsID uuid;
-  rv = nsID::GenerateUUIDInPlace(uuid);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  nsCString arch("null");
-  nsCOMPtr<nsIPropertyBag2> sysInfo =
-      do_GetService("@mozilla.org/system-info;1");
-  NS_ENSURE_TRUE_VOID(sysInfo);
-  sysInfo->GetPropertyAsACString(u"arch"_ns, arch);
-
-  time_t now;
-  time(&now);
-  char date[sizeof "YYYY-MM-DDThh:mm:ss.000Z"];
-  strftime(date, sizeof date, "%FT%T.000Z", gmtime(&now));
-
-  NSID_TrimBracketsASCII pingId(uuid);
-  constexpr auto pingType = "downgrade"_ns;
-
-  int32_t pos = aLastVersion.Find("_");
-  if (pos == kNotFound) {
-    return;
-  }
-
-  const nsDependentCSubstring lastVersion = Substring(aLastVersion, 0, pos);
-  const nsDependentCSubstring lastBuildId =
-      Substring(aLastVersion, pos + 1, 14);
-
-  nsPrintfCString url("%s/submit/telemetry/%s/%s/%s/%s/%s/%s?v=%d",
-                      server.get(), PromiseFlatCString(pingId).get(),
-                      pingType.get(), (const char*)gAppData->name,
-                      (const char*)gAppData->version, channel.get(),
-                      (const char*)gAppData->buildID,
-                      TELEMETRY_PING_FORMAT_VERSION);
-
-  nsCOMPtr<nsIFile> pingFile;
-  rv = NS_GetSpecialDirectory(XRE_USER_APP_DATA_DIR, getter_AddRefs(pingFile));
-  NS_ENSURE_SUCCESS_VOID(rv);
-  rv = pingFile->Append(u"Pending Pings"_ns);
-  NS_ENSURE_SUCCESS_VOID(rv);
-  rv = pingFile->Create(nsIFile::DIRECTORY_TYPE, 0755);
-  if (NS_FAILED(rv) && rv != NS_ERROR_FILE_ALREADY_EXISTS) {
-    return;
-  }
-  rv = pingFile->Append(NS_ConvertUTF8toUTF16(pingId));
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  nsCOMPtr<nsIFile> pingSender;
-  rv = NS_GetSpecialDirectory(NS_GRE_BIN_DIR, getter_AddRefs(pingSender));
-  NS_ENSURE_SUCCESS_VOID(rv);
-#  ifdef XP_WIN
-  pingSender->Append(u"pingsender.exe"_ns);
-#  else
-  pingSender->Append(u"pingsender"_ns);
-#  endif
-
-  bool exists;
-  rv = pingSender->Exists(&exists);
-  NS_ENSURE_SUCCESS_VOID(rv);
-  if (!exists) {
-    return;
-  }
-
-  FILE* file;
-  rv = pingFile->OpenANSIFileDesc("w", &file);
-  NS_ENSURE_SUCCESS_VOID(rv);
-
-  JSONWriter w(MakeUnique<FileWriteFunc>(file));
-  w.Start();
-  {
-    w.StringProperty("type",
-                     Span<const char>(pingType.Data(), pingType.Length()));
-    w.StringProperty("id", PromiseFlatCString(pingId));
-    w.StringProperty("creationDate", MakeStringSpan(date));
-    w.IntProperty("version", TELEMETRY_PING_FORMAT_VERSION);
-    w.StringProperty("clientId", clientId);
-    w.StartObjectProperty("application");
-    {
-      w.StringProperty("architecture", arch);
-      w.StringProperty(
-          "buildId",
-          MakeStringSpan(static_cast<const char*>(gAppData->buildID)));
-      w.StringProperty(
-          "name", MakeStringSpan(static_cast<const char*>(gAppData->name)));
-      w.StringProperty(
-          "version",
-          MakeStringSpan(static_cast<const char*>(gAppData->version)));
-      w.StringProperty("displayVersion",
-                       MOZ_STRINGIFY(MOZ_APP_VERSION_DISPLAY));
-      w.StringProperty(
-          "vendor", MakeStringSpan(static_cast<const char*>(gAppData->vendor)));
-      w.StringProperty("platformVersion", gToolkitVersion);
-#  ifdef TARGET_XPCOM_ABI
-      w.StringProperty("xpcomAbi", TARGET_XPCOM_ABI);
-#  else
-      w.StringProperty("xpcomAbi", "unknown");
-#  endif
-      w.StringProperty("channel", channel);
-    }
-    w.EndObject();
-    w.StartObjectProperty("payload");
-    {
-      w.StringProperty("lastVersion", PromiseFlatCString(lastVersion));
-      w.StringProperty("lastBuildId", PromiseFlatCString(lastBuildId));
-      w.BoolProperty("hasSync", aHasSync);
-      w.IntProperty("button", aButton);
-    }
-    w.EndObject();
-  }
-  w.End();
-
-  fclose(file);
-
-  PathString filePath = pingFile->NativePath();
-  const filesystem::Path::value_type* args[2];
-#  ifdef XP_WIN
-  nsString urlw = NS_ConvertUTF8toUTF16(url);
-  args[0] = urlw.get();
-#  else
-  args[0] = url.get();
-#  endif
-  args[1] = filePath.get();
-
-  nsCOMPtr<nsIProcess> process =
-      do_CreateInstance("@mozilla.org/process/util;1");
-  NS_ENSURE_TRUE_VOID(process);
-  process->Init(pingSender);
-  process->SetStartHidden(true);
-  process->SetNoShell(true);
-
-#  ifdef XP_WIN
-  process->Runw(false, args, 2);
-#  else
-  process->Run(false, args, 2);
-#  endif
-}
-
-static const char kProfileDowngradeURL[] =
-    "chrome://mozapps/content/profile/profileDowngrade.xhtml";
-
 static ReturnAbortOnError CheckDowngrade(nsIFile* aProfileDir,
                                          nsINativeAppSupport* aNative,
                                          nsIToolkitProfileService* aProfileSvc,
@@ -3321,58 +3126,6 @@ static ReturnAbortOnError CheckDowngrade
 
     rv = xpcom.SetWindowCreator(aNative);
     NS_ENSURE_SUCCESS(rv, rv);
-
-    {  // extra scoping is needed so we release these components before xpcom
-       // shutdown
-      bool hasSync = false;
-      nsCOMPtr<nsIPrefService> prefSvc =
-          do_GetService("@mozilla.org/preferences-service;1");
-      NS_ENSURE_TRUE(prefSvc, rv);
-
-      nsCOMPtr<nsIFile> prefsFile;
-      rv = aProfileDir->Clone(getter_AddRefs(prefsFile));
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = prefsFile->Append(u"prefs.js"_ns);
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      rv = prefSvc->ReadUserPrefsFromFile(prefsFile);
-      if (NS_SUCCEEDED(rv)) {
-        nsCOMPtr<nsIPrefBranch> prefBranch = do_QueryInterface(prefSvc);
-
-        rv = prefBranch->PrefHasUserValue("services.sync.username", &hasSync);
-        NS_ENSURE_SUCCESS(rv, rv);
-      }
-
-      nsCOMPtr<nsIWindowWatcher> windowWatcher =
-          do_GetService(NS_WINDOWWATCHER_CONTRACTID);
-      NS_ENSURE_TRUE(windowWatcher, NS_ERROR_ABORT);
-
-      nsCOMPtr<nsIAppStartup> appStartup(components::AppStartup::Service());
-      NS_ENSURE_TRUE(appStartup, NS_ERROR_FAILURE);
-
-      nsCOMPtr<nsIDialogParamBlock> paramBlock =
-          do_CreateInstance(NS_DIALOGPARAMBLOCK_CONTRACTID);
-      NS_ENSURE_TRUE(paramBlock, NS_ERROR_ABORT);
-
-      uint8_t flags = 0;
-      if (hasSync) {
-        flags |= nsIToolkitProfileService::hasSync;
-      }
-
-      paramBlock->SetInt(0, flags);
-
-      nsCOMPtr<mozIDOMWindowProxy> newWindow;
-      rv = windowWatcher->OpenWindow(
-          nullptr, nsDependentCString(kProfileDowngradeURL), "_blank"_ns,
-          "centerscreen,chrome,modal,titlebar"_ns, paramBlock,
-          getter_AddRefs(newWindow));
-      NS_ENSURE_SUCCESS(rv, rv);
-
-      paramBlock->GetInt(1, &result);
-
-      SubmitDowngradeTelemetry(aLastVersion, hasSync, result);
-    }
   }
 
   if (result == nsIToolkitProfileService::createNewProfile) {
@@ -5579,9 +5332,6 @@ nsresult XREMain::XRE_mainRun() {
 #    endif  // defined(MOZ_BACKGROUNDTASKS)
       {
         Preferences::RegisterCallbackAndCall(
-            &OnDefaultAgentTelemetryPrefChanged,
-            kPrefHealthReportUploadEnabled);
-        Preferences::RegisterCallbackAndCall(
             &OnDefaultAgentTelemetryPrefChanged, kPrefDefaultAgentEnabled);
 
         Preferences::RegisterCallbackAndCall(
diff --git a/xpcom/base/AppShutdown.cpp b/xpcom/base/AppShutdown.cpp
--- a/xpcom/base/AppShutdown.cpp
+++ b/xpcom/base/AppShutdown.cpp
@@ -31,10 +31,6 @@
 
 #include "AppShutdown.h"
 
-// TODO: understand why on Android we cannot include this and if we should
-#ifndef ANDROID
-#  include "nsTerminator.h"
-#endif
 #include "prenv.h"
 
 #ifdef MOZ_NEW_XULSTORE
@@ -81,10 +77,6 @@ const char* sPhaseReadableNames[] = {"No
 static_assert(sizeof(sPhaseReadableNames) / sizeof(sPhaseReadableNames[0]) ==
               (size_t)ShutdownPhase::ShutdownPhase_Length);
 
-#ifndef ANDROID
-static nsTerminator* sTerminator = nullptr;
-#endif
-
 static ShutdownPhase sFastShutdownPhase = ShutdownPhase::NotInShutdown;
 static ShutdownPhase sLateWriteChecksPhase = ShutdownPhase::NotInShutdown;
 static AppShutdownMode sShutdownMode = AppShutdownMode::Normal;
@@ -204,10 +196,6 @@ void AppShutdown::Init(AppShutdownMode a
 
   sExitCode = aExitCode;
 
-#ifndef ANDROID
-  sTerminator = new nsTerminator();
-#endif
-
   // Late-write checks needs to find the profile directory, so it has to
   // be initialized before services::Shutdown or (because of
   // xpcshell tests replacing the service) modules being unloaded.
@@ -349,12 +337,6 @@ void AppShutdown::AdvanceShutdownPhaseIn
   //    obsService->NotifyObservers(...);
   //    mozilla::KillClearOnShutdown(aPhase);
 
-#ifndef ANDROID
-  if (sTerminator) {
-    sTerminator->AdvancePhase(aPhase);
-  }
-#endif
-
   mozilla::KillClearOnShutdown(aPhase);
 
   AppShutdown::MaybeFastShutdown(aPhase);
diff --git a/xpcom/base/moz.build b/xpcom/base/moz.build
--- a/xpcom/base/moz.build
+++ b/xpcom/base/moz.build
@@ -126,7 +126,6 @@ EXPORTS.mozilla += [
     "MemoryInfo.h",
     "MemoryMapping.h",
     "MemoryReportingProcess.h",
-    "MemoryTelemetry.h",
     "nsMemoryInfoDumper.h",
     "NSPRLogModulesParser.h",
     "OwningNonNull.h",
@@ -169,7 +168,6 @@ UNIFIED_SOURCES += [
     "LogCommandLineHandler.cpp",
     "Logging.cpp",
     "LogModulePrefWatcher.cpp",
-    "MemoryTelemetry.cpp",
     "nsClassInfoImpl.cpp",
     "nsCOMPtr.cpp",
     "nsConsoleMessage.cpp",
diff --git a/xpcom/build/XPCOMInit.cpp b/xpcom/build/XPCOMInit.cpp
--- a/xpcom/build/XPCOMInit.cpp
+++ b/xpcom/build/XPCOMInit.cpp
@@ -18,10 +18,6 @@
 #include "mozJSComponentLoader.h"
 #include "nsXULAppAPI.h"
 
-#ifndef ANDROID
-#  include "nsTerminator.h"
-#endif
-
 #include "nsXPCOMPrivate.h"
 #include "nsXPCOMCIDInternal.h"
 
