diff --git a/browser/actors/WebRTCParent.jsm b/browser/actors/WebRTCParent.jsm
--- a/browser/actors/WebRTCParent.jsm
+++ b/browser/actors/WebRTCParent.jsm
@@ -318,9 +318,9 @@ class WebRTCParent extends JSWindowActor
     }
 
     // Screen sharing shouldn't follow the camera permissions.
-    if (videoDevices.length && sharingScreen) {
-      camAllowed = false;
-    }
+    // if (videoDevices.length && sharingScreen) {
+    //   camAllowed = false;
+    // }
     // Don't use persistent permissions from the top-level principal
     // if we're in a cross-origin iframe and permission delegation is not
     // allowed, or when we're handling a potentially insecure third party
@@ -337,7 +337,7 @@ class WebRTCParent extends JSWindowActor
     let activeMic;
 
     // Always prompt for screen sharing
-    if (!sharingScreen) {
+    // if (!sharingScreen) {
       for (let device of videoDevices) {
         let set = webrtcUI.activePerms.get(this.manager.outerWindowId);
         if (
@@ -359,7 +359,7 @@ class WebRTCParent extends JSWindowActor
           break;
         }
       }
-    }
+    // }
     if (
       (!audioDevices.length || micAllowed || activeMic) &&
       (!videoDevices.length || camAllowed || activeCamera)
@@ -410,7 +410,7 @@ class WebRTCParent extends JSWindowActor
   }
 }
 
-function prompt(aActor, aBrowser, aRequest) {
+function prompt_orig(aActor, aBrowser, aRequest) {
   let {
     audioDevices,
     videoDevices,
@@ -1230,13 +1230,53 @@ function prompt(aActor, aBrowser, aReque
   }
 }
 
+function prompt(aActor, aBrowser, aRequest) {
+  let {
+    audioDevices,
+    videoDevices,
+    sharingScreen,
+    sharingAudio,
+    requestTypes,
+  } = aRequest;
+
+  let principal = Services.scriptSecurityManager.createContentPrincipalFromOrigin(
+    aRequest.origin
+  );
+
+  // If the user has already denied access once in this tab,
+  // deny again without even showing the notification icon.
+  if (
+    (audioDevices.length &&
+      SitePermissions.getForPrincipal(principal, "microphone", aBrowser)
+        .state == SitePermissions.BLOCK) ||
+    (videoDevices.length &&
+      SitePermissions.getForPrincipal(
+        principal,
+        sharingScreen ? "screen" : "camera",
+        aBrowser
+      ).state == SitePermissions.BLOCK)
+  ) {
+    aActor.denyRequest(aRequest);
+    return;
+  }
+
+  // Tell the browser to refresh the identity block display in case there
+  // are expired permission states.
+  aBrowser.dispatchEvent(
+    new aBrowser.ownerGlobal.CustomEvent("PermissionStateChange")
+  );
+  // copy and modify from options.eventCallback():651
+
+      // BLOCK is handled immediately by MediaManager if it has been set
+      // persistently in the permission manager. If it has been set on the tab,
+      // it is handled synchronously before we add the notification.
+      // Handling of ALLOW is delayed until the popupshowing event,
+      // to avoid granting permissions automatically to background tabs.
+      if (aActor.checkRequestAllowed(aRequest, principal, aBrowser)) {
+        return;
+      }
+      aActor.denyRequest(aRequest);
+}
+
 function removePrompt(aBrowser, aCallId) {
-  let chromeWin = aBrowser.ownerGlobal;
-  let notification = chromeWin.PopupNotifications.getNotification(
-    "webRTC-shareDevices",
-    aBrowser
-  );
-  if (notification && notification.callID == aCallId) {
-    notification.remove();
-  }
 }
diff --git a/browser/modules/webrtcUI.jsm b/browser/modules/webrtcUI.jsm
--- a/browser/modules/webrtcUI.jsm
+++ b/browser/modules/webrtcUI.jsm
@@ -97,46 +97,19 @@ var webrtcUI = {
   activePerms: new Map(),
 
   get showGlobalIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showGlobalIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showCameraIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showCameraIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showMicrophoneIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showMicrophoneIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showScreenSharingIndicator() {
     let list = [""];
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showScreenSharingIndicator) {
-        list.push(indicators.showScreenSharingIndicator);
-      }
-    }
-
-    let precedence = ["Screen", "Window", "Application", "Browser", ""];
-
-    list.sort((a, b) => {
-      return precedence.indexOf(a) - precedence.indexOf(b);
-    });
-
     return list[0];
   },
 
