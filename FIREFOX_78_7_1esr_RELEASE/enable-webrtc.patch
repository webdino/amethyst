diff --git a/browser/actors/WebRTCParent.jsm b/browser/actors/WebRTCParent.jsm
--- a/browser/actors/WebRTCParent.jsm
+++ b/browser/actors/WebRTCParent.jsm
@@ -318,9 +318,9 @@ class WebRTCParent extends JSWindowActor
     }
 
     // Screen sharing shouldn't follow the camera permissions.
-    if (videoDevices.length && sharingScreen) {
-      camAllowed = false;
-    }
+    // if (videoDevices.length && sharingScreen) {
+    //   camAllowed = false;
+    // }
     // Don't use persistent permissions from the top-level principal
     // if we're in a cross-origin iframe and permission delegation is not
     // allowed, or when we're handling a potentially insecure third party
@@ -337,7 +337,7 @@ class WebRTCParent extends JSWindowActor
     let activeMic;
 
     // Always prompt for screen sharing
-    if (!sharingScreen) {
+    // if (!sharingScreen) {
       for (let device of videoDevices) {
         let set = webrtcUI.activePerms.get(this.manager.outerWindowId);
         if (
@@ -359,7 +359,7 @@ class WebRTCParent extends JSWindowActor
           break;
         }
       }
-    }
+    // }
     if (
       (!audioDevices.length || micAllowed || activeMic) &&
       (!videoDevices.length || camAllowed || activeCamera)
@@ -423,39 +423,6 @@ function prompt(aActor, aBrowser, aReque
     aRequest.origin
   );
 
-  // For add-on principals, we immediately check for permission instead
-  // of waiting for the notification to focus. This allows for supporting
-  // cases such as browserAction popups where no prompt is shown.
-  if (principal.addonPolicy) {
-    let isPopup = false;
-    let isBackground = false;
-
-    for (let view of principal.addonPolicy.extension.views) {
-      if (view.viewType == "popup" && view.xulBrowser == aBrowser) {
-        isPopup = true;
-      }
-      if (view.viewType == "background" && view.xulBrowser == aBrowser) {
-        isBackground = true;
-      }
-    }
-
-    // Recording from background pages is considered too sensitive and will
-    // always be denied.
-    if (isBackground) {
-      aActor.denyRequest(aRequest);
-      return;
-    }
-
-    // If the request comes from a popup, we don't want to show the prompt,
-    // but we do want to allow the request if the user previously gave permission.
-    if (isPopup) {
-      if (!aActor.checkRequestAllowed(aRequest, principal, aBrowser)) {
-        aActor.denyRequest(aRequest);
-      }
-      return;
-    }
-  }
-
   // If the user has already denied access once in this tab,
   // deny again without even showing the notification icon.
   if (
@@ -479,764 +446,16 @@ function prompt(aActor, aBrowser, aReque
     new aBrowser.ownerGlobal.CustomEvent("PermissionStateChange")
   );
 
-  let chromeDoc = aBrowser.ownerDocument;
-  let stringBundle = chromeDoc.defaultView.gNavigatorBundle;
-  let localization = new Localization(
-    ["branding/brand.ftl", "browser/browser.ftl"],
-    true
-  );
-
-  // Mind the order, because for simplicity we're iterating over the list using
-  // "includes()". This allows the rotation of string identifiers. We list the
-  // full identifiers here so they can be cross-referenced more easily.
-  let joinedRequestTypes = requestTypes.join("And");
-  let requestMessages;
-  if (aRequest.secondOrigin) {
-    requestMessages = [
-      // Individual request types first.
-      "getUserMedia.shareCameraUnsafeDelegation.message",
-      "getUserMedia.shareMicrophoneUnsafeDelegations.message",
-      "getUserMedia.shareScreenUnsafeDelegation.message",
-      "getUserMedia.shareAudioCaptureUnsafeDelegation.message",
-      // Combinations of the above request types last.
-      "getUserMedia.shareCameraAndMicrophoneUnsafeDelegation.message",
-      "getUserMedia.shareCameraAndAudioCaptureUnsafeDelegation.message",
-      "getUserMedia.shareScreenAndMicrophoneUnsafeDelegation.message",
-      "getUserMedia.shareScreenAndAudioCaptureUnsafeDelegation.message",
-    ];
-  } else {
-    requestMessages = [
-      // Individual request types first.
-      "getUserMedia.shareCamera2.message",
-      "getUserMedia.shareMicrophone2.message",
-      "getUserMedia.shareScreen3.message",
-      "getUserMedia.shareAudioCapture2.message",
-      // Combinations of the above request types last.
-      "getUserMedia.shareCameraAndMicrophone2.message",
-      "getUserMedia.shareCameraAndAudioCapture2.me ssage",
-      "getUserMedia.shareScreenAndMicrophone3.message",
-      "getUserMedia.shareScreenAndAudioCapture3.message",
-    ];
-  }
-
-  let stringId = requestMessages.find(id => id.includes(joinedRequestTypes));
-  let message = aRequest.secondOrigin
-    ? stringBundle.getFormattedString(stringId, ["<>", "{}"])
-    : stringBundle.getFormattedString(stringId, ["<>"]);
-
-  let notification; // Used by action callbacks.
-  let mainAction = {
-    label: stringBundle.getString("getUserMedia.allow.label"),
-    accessKey: stringBundle.getString("getUserMedia.allow.accesskey"),
-    // The real callback will be set during the "showing" event. The
-    // empty function here is so that PopupNotifications.show doesn't
-    // reject the action.
-    callback() {},
-  };
-
-  let notificationSilencingEnabled = Services.prefs.getBoolPref(
-    "privacy.webrtc.allowSilencingNotifications"
-  );
-
-  let secondaryActions = [];
-  if (notificationSilencingEnabled && sharingScreen) {
-    // We want to free up the checkbox at the bottom of the permission
-    // panel for the notification silencing option, so we use a
-    // different configuration for the permissions panel when
-    // notification silencing is enabled.
-
-    // The formatMessagesSync method returns an array of results
-    // for each message that was requested, and for the ones with
-    // attributes, returns an attributes array with objects like:
-    //
-    // { name: "someName", value: "somevalue" }
-    //
-    // For these strings, which use .label and .accesskey attributes,
-    // this convertAttributesToObjects function looks at the attributes
-    // property of each message, and returns back an array of objects,
-    // where each object property is one of the attribute names, and
-    // the property value is the attribute value.
-    //
-    // So, the above example would be converted into:
-    //
-    // { someName: "someValue" }
-    //
-    // which is much easier to access and pass along to other things.
-    let convertAttributesToObjects = messages => {
-      return messages.map(msg => {
-        return msg.attributes.reduce((acc, attribute) => {
-          acc[attribute.name] = attribute.value;
-          return acc;
-        }, {});
-      });
-    };
-
-    let [notNow, never] = convertAttributesToObjects(
-      localization.formatMessagesSync([
-        { id: "popup-screen-sharing-not-now" },
-        { id: "popup-screen-sharing-never" },
-      ])
-    );
-
-    secondaryActions = [
-      {
-        label: notNow.label,
-        accessKey: notNow.accesskey,
-        callback(aState) {
-          aActor.denyRequest(aRequest);
-          SitePermissions.setForPrincipal(
-            principal,
-            "screen",
-            SitePermissions.BLOCK,
-            SitePermissions.SCOPE_TEMPORARY,
-            notification.browser
-          );
-        },
-      },
-      {
-        label: never.label,
-        accessKey: never.accesskey,
-        callback(aState) {
-          aActor.denyRequest(aRequest);
-          SitePermissions.setForPrincipal(
-            principal,
-            "screen",
-            SitePermissions.BLOCK,
-            SitePermissions.SCOPE_PERSISTENT,
-            notification.browser
-          );
-        },
-      },
-    ];
-  } else {
-    secondaryActions = [
-      {
-        label: stringBundle.getString("getUserMedia.dontAllow.label"),
-        accessKey: stringBundle.getString("getUserMedia.dontAllow.accesskey"),
-        callback(aState) {
-          aActor.denyRequest(aRequest);
-          let scope = SitePermissions.SCOPE_TEMPORARY;
-          if (aState && aState.checkboxChecked) {
-            scope = SitePermissions.SCOPE_PERSISTENT;
-          }
-          if (audioDevices.length) {
-            SitePermissions.setForPrincipal(
-              principal,
-              "microphone",
-              SitePermissions.BLOCK,
-              scope,
-              notification.browser
-            );
-          }
-          if (videoDevices.length) {
-            SitePermissions.setForPrincipal(
-              principal,
-              sharingScreen ? "screen" : "camera",
-              SitePermissions.BLOCK,
-              scope,
-              notification.browser
-            );
-          }
-        },
-      },
-    ];
-  }
-
-  let productName = gBrandBundle.GetStringFromName("brandShortName");
-
-  let options = {
-    name: webrtcUI.getHostOrExtensionName(principal.URI),
-    persistent: true,
-    hideClose: true,
-    eventCallback(aTopic, aNewBrowser, isCancel) {
-      if (aTopic == "swapping") {
-        return true;
-      }
-
-      let doc = this.browser.ownerDocument;
-
-      // Clean-up video streams of screensharing previews.
-      if (
-        ((aTopic == "dismissed" || aTopic == "removed") &&
-          requestTypes.includes("Screen")) ||
-        !requestTypes.includes("Screen")
-      ) {
-        let video = doc.getElementById("webRTC-previewVideo");
-        if (video.stream) {
-          video.stream.getTracks().forEach(t => t.stop());
-          video.stream = null;
-          video.src = null;
-          doc.getElementById("webRTC-preview").hidden = true;
-        }
-        let menupopup = doc.getElementById("webRTC-selectWindow-menupopup");
-        if (menupopup._commandEventListener) {
-          menupopup.removeEventListener(
-            "command",
-            menupopup._commandEventListener
-          );
-          menupopup._commandEventListener = null;
-        }
-      }
-
-      // If the notification has been cancelled (e.g. due to entering full-screen), also cancel the webRTC request
-      if (aTopic == "removed" && notification && isCancel) {
-        aActor.denyRequest(aRequest);
-      }
-
-      if (aTopic != "showing") {
-        return false;
-      }
-
       // BLOCK is handled immediately by MediaManager if it has been set
       // persistently in the permission manager. If it has been set on the tab,
       // it is handled synchronously before we add the notification.
       // Handling of ALLOW is delayed until the popupshowing event,
       // to avoid granting permissions automatically to background tabs.
       if (aActor.checkRequestAllowed(aRequest, principal, aBrowser)) {
-        this.remove();
-        return true;
-      }
-
-      function listDevices(menupopup, devices) {
-        while (menupopup.lastChild) {
-          menupopup.removeChild(menupopup.lastChild);
-        }
-        // Removing the child nodes of the menupopup doesn't clear the value
-        // attribute of the menulist. This can have unfortunate side effects
-        // when the list is rebuilt with a different content, so we remove
-        // the value attribute and unset the selectedItem explicitly.
-        menupopup.parentNode.removeAttribute("value");
-        menupopup.parentNode.selectedItem = null;
-
-        for (let device of devices) {
-          addDeviceToList(menupopup, device.name, device.deviceIndex);
-        }
-      }
-
-      function checkDisabledWindowMenuItem() {
-        let list = doc.getElementById("webRTC-selectWindow-menulist");
-        let item = list.selectedItem;
-        let notificationElement = doc.getElementById(
-          "webRTC-shareDevices-notification"
-        );
-        if (!item || item.hasAttribute("disabled")) {
-          notificationElement.setAttribute("invalidselection", "true");
-        } else {
-          notificationElement.removeAttribute("invalidselection");
-        }
-      }
-
-      function listScreenShareDevices(menupopup, devices) {
-        while (menupopup.lastChild) {
-          menupopup.removeChild(menupopup.lastChild);
-        }
-
-        // Removing the child nodes of the menupopup doesn't clear the value
-        // attribute of the menulist. This can have unfortunate side effects
-        // when the list is rebuilt with a different content, so we remove
-        // the value attribute and unset the selectedItem explicitly.
-        menupopup.parentNode.removeAttribute("value");
-        menupopup.parentNode.selectedItem = null;
-
-        let label = doc.getElementById("webRTC-selectWindow-label");
-        const gumStringId = "getUserMedia.selectWindowOrScreen";
-        label.setAttribute(
-          "value",
-          stringBundle.getString(gumStringId + ".label")
-        );
-        label.setAttribute(
-          "accesskey",
-          stringBundle.getString(gumStringId + ".accesskey")
-        );
-
-        // "Select a Window or Screen" is the default because we can't and don't
-        // want to pick a 'default' window to share (Full screen is "scary").
-        addDeviceToList(
-          menupopup,
-          stringBundle.getString("getUserMedia.pickWindowOrScreen.label"),
-          "-1"
-        );
-        menupopup.appendChild(doc.createXULElement("menuseparator"));
-
-        // Build the list of 'devices'.
-        let monitorIndex = 1;
-        for (let i = 0; i < devices.length; ++i) {
-          let device = devices[i];
-          let type = device.mediaSource;
-          let name;
-          // Building screen list from available screens.
-          if (type == "screen") {
-            if (device.name == "Primary Monitor") {
-              name = stringBundle.getString(
-                "getUserMedia.shareEntireScreen.label"
-              );
-            } else {
-              name = stringBundle.getFormattedString(
-                "getUserMedia.shareMonitor.label",
-                [monitorIndex]
-              );
-              ++monitorIndex;
-            }
-          } else {
-            name = device.name;
-            if (type == "application") {
-              // The application names returned by the platform are of the form:
-              // <window count>\x1e<application name>
-              let sepIndex = name.indexOf("\x1e");
-              let count = name.slice(0, sepIndex);
-              let sawcStringId =
-                "getUserMedia.shareApplicationWindowCount.label";
-              name = PluralForm.get(
-                parseInt(count),
-                stringBundle.getString(sawcStringId)
-              )
-                .replace("#1", name.slice(sepIndex + 1))
-                .replace("#2", count);
-            }
-          }
-          let item = addDeviceToList(menupopup, name, i, type);
-          item.deviceId = device.id;
-          item.mediaSource = type;
-          if (device.scary) {
-            item.scary = true;
-          }
-        }
-
-        // Always re-select the "No <type>" item.
-        doc
-          .getElementById("webRTC-selectWindow-menulist")
-          .removeAttribute("value");
-        doc.getElementById("webRTC-all-windows-shared").hidden = true;
-
-        menupopup._commandEventListener = event => {
-          checkDisabledWindowMenuItem();
-          let video = doc.getElementById("webRTC-previewVideo");
-          if (video.stream) {
-            video.stream.getTracks().forEach(t => t.stop());
-            video.stream = null;
-          }
-
-          let type = event.target.mediaSource;
-          let deviceId = event.target.deviceId;
-          if (deviceId == undefined) {
-            doc.getElementById("webRTC-preview").hidden = true;
-            video.src = null;
-            return;
-          }
-
-          let scary = event.target.scary;
-          let warning = doc.getElementById("webRTC-previewWarning");
-          warning.hidden = !scary;
-          let chromeWin = doc.defaultView;
-          if (scary) {
-            warning.hidden = false;
-            let string;
-            let bundle = chromeWin.gNavigatorBundle;
-
-            let learnMoreText = bundle.getString(
-              "getUserMedia.shareScreen.learnMoreLabel"
-            );
-            let baseURL = Services.urlFormatter.formatURLPref(
-              "app.support.baseURL"
-            );
-
-            let learnMore = chromeWin.document.createXULElement("label", {
-              is: "text-link",
-            });
-            learnMore.setAttribute("href", baseURL + "screenshare-safety");
-            learnMore.textContent = learnMoreText;
-
-            if (type == "screen") {
-              string = bundle.getFormattedString(
-                "getUserMedia.shareScreenWarning.message",
-                ["<>"]
-              );
-            } else {
-              let brand = doc
-                .getElementById("bundle_brand")
-                .getString("brandShortName");
-              string = bundle.getFormattedString(
-                "getUserMedia.shareFirefoxWarning.message",
-                [brand, "<>"]
-              );
-            }
-
-            let [pre, post] = string.split("<>");
-            warning.textContent = pre;
-            warning.appendChild(learnMore);
-            warning.appendChild(chromeWin.document.createTextNode(post));
-
-            // On Catalina, we don't want to blow our chance to show the
-            // OS-level helper prompt to enable screen recording if the user
-            // intends to reject anyway. OTOH showing it when they click Allow
-            // is too late. A happy middle is to show it when the user makes a
-            // choice in the picker. This already happens implicitly if the
-            // user chooses "Entire desktop", as a side-effect of our preview,
-            // we just need to also do it if they choose "Firefox". These are
-            // the lone two options when permission is absent on Catalina.
-            // Ironically, these are the two sources marked "scary" from a
-            // web-sharing perspective, which is why this code resides here.
-            // A restart doesn't appear to be necessary in spite of OS wording.
-            let scrStatus = {};
-            OSPermissions.getScreenCapturePermissionState(scrStatus);
-            if (scrStatus.value == OSPermissions.PERMISSION_STATE_DENIED) {
-              OSPermissions.maybeRequestScreenCapturePermission();
-            }
-          }
-
-          let perms = Services.perms;
-          let chromePrincipal = Services.scriptSecurityManager.getSystemPrincipal();
-          perms.addFromPrincipal(
-            chromePrincipal,
-            "MediaManagerVideo",
-            perms.ALLOW_ACTION,
-            perms.EXPIRE_SESSION
-          );
-
-          video.deviceId = deviceId;
-          let constraints = {
-            video: { mediaSource: type, deviceId: { exact: deviceId } },
-          };
-          chromeWin.navigator.mediaDevices.getUserMedia(constraints).then(
-            stream => {
-              if (video.deviceId != deviceId) {
-                // The user has selected a different device or closed the panel
-                // before getUserMedia finished.
-                stream.getTracks().forEach(t => t.stop());
-                return;
-              }
-              video.srcObject = stream;
-              video.stream = stream;
-              doc.getElementById("webRTC-preview").hidden = false;
-              video.onloadedmetadata = function(e) {
-                video.play();
-              };
-            },
-            err => {
-              if (
-                err.name == "OverconstrainedError" &&
-                err.constraint == "deviceId"
-              ) {
-                // Window has disappeared since enumeration, which can happen.
-                // No preview for you.
-                return;
-              }
-              Cu.reportError(
-                `error in preview: ${err.message} ${err.constraint}`
-              );
-            }
-          );
-        };
-        menupopup.addEventListener("command", menupopup._commandEventListener);
-      }
-
-      function addDeviceToList(menupopup, deviceName, deviceIndex, type) {
-        let menuitem = doc.createXULElement("menuitem");
-        menuitem.setAttribute("value", deviceIndex);
-        menuitem.setAttribute("label", deviceName);
-        menuitem.setAttribute("tooltiptext", deviceName);
-        if (type) {
-          menuitem.setAttribute("devicetype", type);
-        }
-
-        if (deviceIndex == "-1") {
-          menuitem.setAttribute("disabled", true);
-        }
-
-        menupopup.appendChild(menuitem);
-        return menuitem;
+        return;
       }
-
-      doc.getElementById("webRTC-selectCamera").hidden =
-        !videoDevices.length || sharingScreen;
-      doc.getElementById("webRTC-selectWindowOrScreen").hidden =
-        !sharingScreen || !videoDevices.length;
-      doc.getElementById("webRTC-selectMicrophone").hidden =
-        !audioDevices.length || sharingAudio;
-
-      let camMenupopup = doc.getElementById("webRTC-selectCamera-menupopup");
-      let windowMenupopup = doc.getElementById("webRTC-selectWindow-menupopup");
-      let micMenupopup = doc.getElementById(
-        "webRTC-selectMicrophone-menupopup"
-      );
-      if (sharingScreen) {
-        listScreenShareDevices(windowMenupopup, videoDevices);
-        checkDisabledWindowMenuItem();
-      } else {
-        listDevices(camMenupopup, videoDevices);
-        doc
-          .getElementById("webRTC-shareDevices-notification")
-          .removeAttribute("invalidselection");
-      }
-
-      if (!sharingAudio) {
-        listDevices(micMenupopup, audioDevices);
-      }
-
-      this.mainAction.callback = async function(aState) {
-        let remember = false;
-        let silenceNotifications = false;
-
-        if (notificationSilencingEnabled && sharingScreen) {
-          silenceNotifications = aState && aState.checkboxChecked;
-        } else {
-          remember = aState && aState.checkboxChecked;
-        }
-
-        let allowedDevices = [];
-        let perms = Services.perms;
-        if (videoDevices.length) {
-          let listId =
-            "webRTC-select" +
-            (sharingScreen ? "Window" : "Camera") +
-            "-menulist";
-          let videoDeviceIndex = doc.getElementById(listId).value;
-          let allowVideoDevice = videoDeviceIndex != "-1";
-          if (allowVideoDevice) {
-            allowedDevices.push(videoDeviceIndex);
-            // Session permission will be removed after use
-            // (it's really one-shot, not for the entire session)
-            perms.addFromPrincipal(
-              principal,
-              "MediaManagerVideo",
-              perms.ALLOW_ACTION,
-              perms.EXPIRE_SESSION
-            );
-            if (!webrtcUI.activePerms.has(aActor.manager.outerWindowId)) {
-              webrtcUI.activePerms.set(aActor.manager.outerWindowId, new Set());
-            }
-
-            for (let device of videoDevices) {
-              if (device.deviceIndex == videoDeviceIndex) {
-                webrtcUI.activePerms
-                  .get(aActor.manager.outerWindowId)
-                  .add(aRequest.windowID + device.mediaSource + device.id);
-                break;
-              }
-            }
-            if (remember) {
-              SitePermissions.setForPrincipal(
-                principal,
-                "camera",
-                SitePermissions.ALLOW
-              );
-            }
-          }
-        }
-        if (audioDevices.length) {
-          if (!sharingAudio) {
-            let audioDeviceIndex = doc.getElementById(
-              "webRTC-selectMicrophone-menulist"
-            ).value;
-            let allowMic = audioDeviceIndex != "-1";
-            if (allowMic) {
-              allowedDevices.push(audioDeviceIndex);
-              if (!webrtcUI.activePerms.has(aActor.manager.outerWindowId)) {
-                webrtcUI.activePerms.set(
-                  aActor.manager.outerWindowId,
-                  new Set()
-                );
-              }
-
-              for (let device of audioDevices) {
-                if (device.deviceIndex == audioDeviceIndex) {
-                  webrtcUI.activePerms
-                    .get(aActor.manager.outerWindowId)
-                    .add(aRequest.windowID + device.mediaSource + device.id);
-                  break;
-                }
-              }
-              if (remember) {
-                SitePermissions.setForPrincipal(
-                  principal,
-                  "microphone",
-                  SitePermissions.ALLOW
-                );
-              }
-            }
-          } else {
-            // Only one device possible for audio capture.
-            allowedDevices.push(0);
-          }
-        }
-
-        if (!allowedDevices.length) {
-          aActor.denyRequest(aRequest);
-          return;
-        }
-
-        if (remember) {
-          // Remember on which URIs we set persistent permissions so that we
-          // can remove them if the user clicks 'Stop Sharing'.
-          aBrowser.getDevicePermissionOrigins("webrtc").add(principal.origin);
-        }
-
-        let camNeeded = !!videoDevices.length && !sharingScreen;
-        let scrNeeded = !!videoDevices.length && sharingScreen;
-        let micNeeded = !!audioDevices.length;
-        let havePermission = await aActor.checkOSPermission(
-          camNeeded,
-          micNeeded,
-          scrNeeded
-        );
-        if (!havePermission) {
-          aActor.denyRequestNoPermission(aRequest);
-          return;
-        }
-
-        aActor.sendAsyncMessage("webrtc:Allow", {
-          callID: aRequest.callID,
-          windowID: aRequest.windowID,
-          devices: allowedDevices,
-          suppressNotifications: silenceNotifications,
-        });
-      };
-
-      // If we haven't handled the permission yet, we want to show the doorhanger.
-      return false;
-    },
-  };
-
-  function shouldShowAlwaysRemember() {
-    // Don't offer "always remember" action in PB mode
-    if (PrivateBrowsingUtils.isBrowserPrivate(aBrowser)) {
-      return false;
-    }
-
-    // Don't offer "always remember" action in third party with no permission
-    // delegation
-    if (aRequest.isThirdPartyOrigin && !aRequest.shouldDelegatePermission) {
-      return false;
-    }
-
-    // Don't offer "always remember" action in maybe unsafe permission
-    // delegation
-    if (aRequest.shouldDelegatePermission && aRequest.secondOrigin) {
-      return false;
-    }
-
-    return true;
-  }
-
-  if (shouldShowAlwaysRemember()) {
-    // Disable the permanent 'Allow' action if the connection isn't secure, or for
-    // screen/audio sharing (because we can't guess which window the user wants to
-    // share without prompting).
-    let reasonForNoPermanentAllow = "";
-    if (sharingScreen) {
-      reasonForNoPermanentAllow =
-        "getUserMedia.reasonForNoPermanentAllow.screen3";
-    } else if (sharingAudio) {
-      reasonForNoPermanentAllow =
-        "getUserMedia.reasonForNoPermanentAllow.audio";
-    } else if (!aRequest.secure) {
-      reasonForNoPermanentAllow =
-        "getUserMedia.reasonForNoPermanentAllow.insecure";
-    }
-
-    if (notificationSilencingEnabled && sharingScreen) {
-      let [
-        silenceNotifications,
-        silenceNotificationsWarning,
-      ] = localization.formatMessagesSync([
-        { id: "popup-silence-notifications-checkbox" },
-        { id: "popup-silence-notifications-checkbox-warning" },
-      ]);
-
-      options.checkbox = {
-        label: silenceNotifications.value,
-        checked: false,
-        checkedState: {
-          disableMainAction: false,
-          warningLabel: silenceNotificationsWarning.value,
-        },
-      };
-    } else {
-      options.checkbox = {
-        label: stringBundle.getString("getUserMedia.remember"),
-        checked: principal.isAddonOrExpandedAddonPrincipal,
-        checkedState: reasonForNoPermanentAllow
-          ? {
-              disableMainAction: true,
-              warningLabel: stringBundle.getFormattedString(
-                reasonForNoPermanentAllow,
-                [productName]
-              ),
-            }
-          : undefined,
-      };
-    }
-  }
-
-  let iconType = "Devices";
-  if (
-    requestTypes.length == 1 &&
-    (requestTypes[0] == "Microphone" || requestTypes[0] == "AudioCapture")
-  ) {
-    iconType = "Microphone";
-  }
-  if (requestTypes.includes("Screen")) {
-    iconType = "Screen";
-  }
-  let anchorId = "webRTC-share" + iconType + "-notification-icon";
-
-  let iconClass = iconType.toLowerCase();
-  if (iconClass == "devices") {
-    iconClass = "camera";
-  }
-  options.popupIconClass = iconClass + "-icon";
-
-  if (aRequest.secondOrigin) {
-    options.secondName = webrtcUI.getHostOrExtensionName(
-      null,
-      aRequest.secondOrigin
-    );
-  }
-
-  notification = chromeDoc.defaultView.PopupNotifications.show(
-    aBrowser,
-    "webRTC-shareDevices",
-    message,
-    anchorId,
-    mainAction,
-    secondaryActions,
-    options
-  );
-  notification.callID = aRequest.callID;
-
-  let schemeHistogram = Services.telemetry.getKeyedHistogramById(
-    "PERMISSION_REQUEST_ORIGIN_SCHEME"
-  );
-  let userInputHistogram = Services.telemetry.getKeyedHistogramById(
-    "PERMISSION_REQUEST_HANDLING_USER_INPUT"
-  );
-
-  let docURI = aRequest.documentURI;
-  let scheme = 0;
-  if (docURI.startsWith("https")) {
-    scheme = 2;
-  } else if (docURI.startsWith("http")) {
-    scheme = 1;
-  }
-
-  for (let requestType of requestTypes) {
-    if (requestType == "AudioCapture") {
-      requestType = "Microphone";
-    }
-    requestType = requestType.toLowerCase();
-
-    schemeHistogram.add(requestType, scheme);
-    userInputHistogram.add(requestType, aRequest.isHandlingUserInput);
-  }
+      aActor.denyRequest(aRequest);
 }
 
 function removePrompt(aBrowser, aCallId) {
-  let chromeWin = aBrowser.ownerGlobal;
-  let notification = chromeWin.PopupNotifications.getNotification(
-    "webRTC-shareDevices",
-    aBrowser
-  );
-  if (notification && notification.callID == aCallId) {
-    notification.remove();
-  }
 }
diff --git a/browser/modules/webrtcUI.jsm b/browser/modules/webrtcUI.jsm
--- a/browser/modules/webrtcUI.jsm
+++ b/browser/modules/webrtcUI.jsm
@@ -97,46 +97,19 @@ var webrtcUI = {
   activePerms: new Map(),
 
   get showGlobalIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showGlobalIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showCameraIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showCameraIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showMicrophoneIndicator() {
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showMicrophoneIndicator) {
-        return true;
-      }
-    }
     return false;
   },
 
   get showScreenSharingIndicator() {
     let list = [""];
-    for (let [, indicators] of this.perTabIndicators) {
-      if (indicators.showScreenSharingIndicator) {
-        list.push(indicators.showScreenSharingIndicator);
-      }
-    }
-
-    let precedence = ["Screen", "Window", "Application", "Browser", ""];
-
-    list.sort((a, b) => {
-      return precedence.indexOf(a) - precedence.indexOf(b);
-    });
-
     return list[0];
   },
 
