diff --git a/old-configure.in b/old-configure.in
--- a/old-configure.in
+++ b/old-configure.in
@@ -1877,6 +1877,7 @@ MOZ_ARG_DISABLE_BOOL(updater,
     MOZ_UPDATER=,
     MOZ_UPDATER=1 )
 
+MOZ_UPDATER=
 if test -n "$MOZ_UPDATER"; then
     AC_DEFINE(MOZ_UPDATER)
 fi
diff --git a/toolkit/mozapps/update/UpdateService.jsm b/toolkit/mozapps/update/UpdateService.jsm
--- a/toolkit/mozapps/update/UpdateService.jsm
+++ b/toolkit/mozapps/update/UpdateService.jsm
@@ -4708,58 +4708,7 @@ Checker.prototype = {
     waitForOtherInstances()
       .then(() => this.getUpdateURL(force))
       .then(url => {
-        if (!url) {
-          return;
-        }
-
-        // It's possible that another check was kicked off and that request sent
-        // while we were waiting for other instances to exit here; if the other
-        // instances were closed and also the other check was started during the
-        // same interval between polls, then here we could now be about to start
-        // a second overlapping check, which should not happen. So make sure we
-        // don't have a request already active before we start a new one.
-        if (this._request) {
-          LOG(
-            "Checker: checkForUpdates: check request already active, aborting"
-          );
-          return;
-        }
-
-        this._request = new XMLHttpRequest();
-        this._request.open("GET", url, true);
-        this._request.channel.notificationCallbacks = new CertUtils.BadCertHandler(
-          false
-        );
-        // Prevent the request from reading from the cache.
-        this._request.channel.loadFlags |= Ci.nsIRequest.LOAD_BYPASS_CACHE;
-        // Prevent the request from writing to the cache.
-        this._request.channel.loadFlags |= Ci.nsIRequest.INHIBIT_CACHING;
-        // Disable cutting edge features, like TLS 1.3, where middleboxes might brick us
-        this._request.channel.QueryInterface(
-          Ci.nsIHttpChannelInternal
-        ).beConservative = true;
-
-        this._request.overrideMimeType("text/xml");
-        // The Cache-Control header is only interpreted by proxies and the
-        // final destination. It does not help if a resource is already
-        // cached locally.
-        this._request.setRequestHeader("Cache-Control", "no-cache");
-        // HTTP/1.0 servers might not implement Cache-Control and
-        // might only implement Pragma: no-cache
-        this._request.setRequestHeader("Pragma", "no-cache");
-
-        var self = this;
-        this._request.addEventListener("error", function(event) {
-          self.onError(event);
-        });
-        this._request.addEventListener("load", function(event) {
-          self.onLoad(event);
-        });
-
-        LOG("Checker:checkForUpdates - sending request to: " + url);
-        this._request.send(null);
-
-        this._callback = listener;
+        listener.onError(null, null);
       });
   },
 
diff --git a/toolkit/xre/nsUpdateDriver.cpp b/toolkit/xre/nsUpdateDriver.cpp
--- a/toolkit/xre/nsUpdateDriver.cpp
+++ b/toolkit/xre/nsUpdateDriver.cpp
@@ -330,74 +330,10 @@ static void ApplyUpdate(nsIFile* greDir,
   nsCOMPtr<nsIFile> updater;
   nsAutoCString updaterPath;
   nsAutoCString updateDirPath;
-#if defined(XP_WIN)
-  // Get an nsIFile reference for the updater in the installation dir.
-  if (!GetFile(greDir, nsLiteralCString(UPDATER_BIN), updater)) {
-    return;
-  }
-
-  // Get the path to the updater.
-  nsAutoString updaterPathW;
-  rv = updater->GetPath(updaterPathW);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-  CopyUTF16toUTF8(updaterPathW, updaterPath);
-
-  // Get the path to the update dir.
-  nsAutoString updateDirPathW;
-  rv = updateDir->GetPath(updateDirPathW);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-  CopyUTF16toUTF8(updateDirPathW, updateDirPath);
-#elif defined(XP_MACOSX)
-  // Get an nsIFile reference for the updater in the installation dir.
-  if (!GetFile(appDir, nsLiteralCString(UPDATER_APP), updater)) {
-    return;
-  }
-  rv = updater->AppendNative("Contents"_ns);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-  rv = updater->AppendNative("MacOS"_ns);
+  rv = NS_ERROR_NOT_IMPLEMENTED;
   if (NS_FAILED(rv)) {
     return;
   }
-  rv = updater->AppendNative(nsLiteralCString(UPDATER_BIN));
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // Get the path to the updater.
-  rv = updater->GetNativePath(updaterPath);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // Get the path to the update dir.
-  rv = updateDir->GetNativePath(updateDirPath);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-#else
-  // Get an nsIFile reference for the updater in the installation dir.
-  if (!GetFile(greDir, nsLiteralCString(UPDATER_BIN), updater)) {
-    return;
-  }
-
-  // Get the path to the updater.
-  rv = updater->GetNativePath(updaterPath);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-
-  // Get the path to the update dir.
-  rv = updateDir->GetNativePath(updateDirPath);
-  if (NS_FAILED(rv)) {
-    return;
-  }
-#endif
 
   // appFilePath and workingDirPath are only used when the application will be
   // restarted.
